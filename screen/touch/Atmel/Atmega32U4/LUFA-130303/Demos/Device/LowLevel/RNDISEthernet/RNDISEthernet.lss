
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002bf0  00002c84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002bf0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002cca  2**0
                  ALLOC
  3 .stab         0000108c  00000000  00000000  00002ccc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009e0  00000000  00000000  00003d58  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000520  00000000  00000000  00004738  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000d48  00000000  00000000  00004c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007f44  00000000  00000000  000059a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002134  00000000  00000000  0000d8e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00006732  00000000  00000000  0000fa18  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000760  00000000  00000000  0001614c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000035a0  00000000  00000000  000168ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000438b  00000000  00000000  00019e4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000f49  00000000  00000000  0001e1d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000770  00000000  00000000  0001f120  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop
       4:	39 c2       	rjmp	.+1138   	; 0x478 <__bad_interrupt>
       6:	00 00       	nop
       8:	37 c2       	rjmp	.+1134   	; 0x478 <__bad_interrupt>
       a:	00 00       	nop
       c:	35 c2       	rjmp	.+1130   	; 0x478 <__bad_interrupt>
       e:	00 00       	nop
      10:	33 c2       	rjmp	.+1126   	; 0x478 <__bad_interrupt>
      12:	00 00       	nop
      14:	31 c2       	rjmp	.+1122   	; 0x478 <__bad_interrupt>
      16:	00 00       	nop
      18:	2f c2       	rjmp	.+1118   	; 0x478 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2d c2       	rjmp	.+1114   	; 0x478 <__bad_interrupt>
      1e:	00 00       	nop
      20:	2b c2       	rjmp	.+1110   	; 0x478 <__bad_interrupt>
      22:	00 00       	nop
      24:	29 c2       	rjmp	.+1106   	; 0x478 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 13 13 	jmp	0x2626	; 0x2626 <__vector_10>
      2c:	25 c2       	rjmp	.+1098   	; 0x478 <__bad_interrupt>
      2e:	00 00       	nop
      30:	23 c2       	rjmp	.+1094   	; 0x478 <__bad_interrupt>
      32:	00 00       	nop
      34:	21 c2       	rjmp	.+1090   	; 0x478 <__bad_interrupt>
      36:	00 00       	nop
      38:	1f c2       	rjmp	.+1086   	; 0x478 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1d c2       	rjmp	.+1082   	; 0x478 <__bad_interrupt>
      3e:	00 00       	nop
      40:	1b c2       	rjmp	.+1078   	; 0x478 <__bad_interrupt>
      42:	00 00       	nop
      44:	19 c2       	rjmp	.+1074   	; 0x478 <__bad_interrupt>
      46:	00 00       	nop
      48:	17 c2       	rjmp	.+1070   	; 0x478 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	15 c2       	rjmp	.+1066   	; 0x478 <__bad_interrupt>
      4e:	00 00       	nop
      50:	13 c2       	rjmp	.+1062   	; 0x478 <__bad_interrupt>
      52:	00 00       	nop
      54:	11 c2       	rjmp	.+1058   	; 0x478 <__bad_interrupt>
      56:	00 00       	nop
      58:	0f c2       	rjmp	.+1054   	; 0x478 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0d c2       	rjmp	.+1050   	; 0x478 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0b c2       	rjmp	.+1046   	; 0x478 <__bad_interrupt>
      62:	00 00       	nop
      64:	09 c2       	rjmp	.+1042   	; 0x478 <__bad_interrupt>
      66:	00 00       	nop
      68:	07 c2       	rjmp	.+1038   	; 0x478 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	05 c2       	rjmp	.+1034   	; 0x478 <__bad_interrupt>
      6e:	00 00       	nop
      70:	03 c2       	rjmp	.+1030   	; 0x478 <__bad_interrupt>
      72:	00 00       	nop
      74:	01 c2       	rjmp	.+1026   	; 0x478 <__bad_interrupt>
      76:	00 00       	nop
      78:	ff c1       	rjmp	.+1022   	; 0x478 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fd c1       	rjmp	.+1018   	; 0x478 <__bad_interrupt>
      7e:	00 00       	nop
      80:	fb c1       	rjmp	.+1014   	; 0x478 <__bad_interrupt>
      82:	00 00       	nop
      84:	f9 c1       	rjmp	.+1010   	; 0x478 <__bad_interrupt>
      86:	00 00       	nop
      88:	f7 c1       	rjmp	.+1006   	; 0x478 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f5 c1       	rjmp	.+1002   	; 0x478 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f3 c1       	rjmp	.+998    	; 0x478 <__bad_interrupt>
      92:	00 00       	nop
      94:	f1 c1       	rjmp	.+994    	; 0x478 <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <AdapterSupportedOIDList>:
     130:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     140:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     150:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     160:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     170:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     180:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     190:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

0000019c <AdapterVendorDescription>:
     19c:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     1ac:	65 72 00                                            er.

000001af <AdapterMACAddress>:
     1af:	02 00 02 00 02 00                                   ......

000001b5 <HTTP200Header>:
     1b5:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     1c5:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     1d5:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     1e5:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     1f5:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     205:	0a 0d 0a 00                                         ....

00000209 <HTTP404Header>:
     209:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     219:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     229:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     239:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     249:	0a 00                                               ..

0000024b <HTTPPage>:
     24b:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     25b:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     26b:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     27b:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     28b:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     29b:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     2ab:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     2bb:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     2cb:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     2db:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     2eb:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     2fb:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     30b:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     31b:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     32b:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     33b:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     34b:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     35b:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     36b:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     37b:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     38b:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     39b:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     3ab:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     3bb:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     3cb:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     3db:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     3eb:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     3fb:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     40b:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     41b:	3c 2f 69 3e 31 33 30 33 30 33 09 09 3c 2f 70 3e     </i>130303..</p>
     42b:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.
     43b:	00                                                  .

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	e0 ef       	ldi	r30, 0xF0	; 240
     450:	fb e2       	ldi	r31, 0x2B	; 43
     452:	00 e0       	ldi	r16, 0x00	; 0
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a6 34       	cpi	r26, 0x46	; 70
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>

00000462 <__do_clear_bss>:
     462:	13 e1       	ldi	r17, 0x13	; 19
     464:	a6 e4       	ldi	r26, 0x46	; 70
     466:	b1 e0       	ldi	r27, 0x01	; 1
     468:	01 c0       	rjmp	.+2      	; 0x46c <.do_clear_bss_start>

0000046a <.do_clear_bss_loop>:
     46a:	1d 92       	st	X+, r1

0000046c <.do_clear_bss_start>:
     46c:	a5 3f       	cpi	r26, 0xF5	; 245
     46e:	b1 07       	cpc	r27, r17
     470:	e1 f7       	brne	.-8      	; 0x46a <.do_clear_bss_loop>
     472:	95 d1       	rcall	.+810    	; 0x79e <main>
     474:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <_exit>

00000478 <__bad_interrupt>:
     478:	c3 cd       	rjmp	.-1146   	; 0x0 <__vectors>

0000047a <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     47a:	9b b1       	in	r25, 0x0b	; 11
     47c:	9f 70       	andi	r25, 0x0F	; 15
     47e:	98 2b       	or	r25, r24
     480:	9b b9       	out	0x0b, r25	; 11
			}
     482:	08 95       	ret

00000484 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     484:	84 b7       	in	r24, 0x34	; 52
     486:	87 7f       	andi	r24, 0xF7	; 247
     488:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     48a:	28 e1       	ldi	r18, 0x18	; 24
     48c:	0f b6       	in	r0, 0x3f	; 63
     48e:	f8 94       	cli
     490:	20 93 60 00 	sts	0x0060, r18
     494:	10 92 60 00 	sts	0x0060, r1
     498:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	80 e8       	ldi	r24, 0x80	; 128
     49e:	0f b6       	in	r0, 0x3f	; 63
     4a0:	f8 94       	cli
     4a2:	80 93 61 00 	sts	0x0061, r24
     4a6:	90 93 61 00 	sts	0x0061, r25
     4aa:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4ac:	8a b1       	in	r24, 0x0a	; 10
     4ae:	80 6f       	ori	r24, 0xF0	; 240
     4b0:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4b2:	8b b1       	in	r24, 0x0b	; 11
     4b4:	8f 70       	andi	r24, 0x0F	; 15
     4b6:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4b8:	83 e3       	ldi	r24, 0x33	; 51
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	90 93 cd 00 	sts	0x00CD, r25
     4c0:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4c4:	86 e0       	ldi	r24, 0x06	; 6
     4c6:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4ca:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4ce:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     4d2:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4d4:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4d6:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <USB_Init>

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
     4da:	80 e0       	ldi	r24, 0x00	; 0
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	0c 94 7c 15 	jmp	0x2af8	; 0x2af8 <Serial_CreateStream>

000004e2 <EVENT_USB_Device_Connect>:
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     4e2:	80 ea       	ldi	r24, 0xA0	; 160
}
     4e4:	ca cf       	rjmp	.-108    	; 0x47a <LEDs_SetAllLEDs>

000004e6 <EVENT_USB_Device_Disconnect>:
 *  the status LEDs and stops all the relevant tasks.
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     4e6:	80 e1       	ldi	r24, 0x10	; 16
}
     4e8:	c8 cf       	rjmp	.-112    	; 0x47a <LEDs_SetAllLEDs>

000004ea <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     4ea:	0f 93       	push	r16
     4ec:	1f 93       	push	r17
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	61 e8       	ldi	r22, 0x81	; 129
     4f2:	42 e3       	ldi	r20, 0x32	; 50
     4f4:	0e 94 27 12 	call	0x244e	; 0x244e <Endpoint_ConfigureEndpoint_Prv>
     4f8:	08 2f       	mov	r16, r24
     4fa:	82 e0       	ldi	r24, 0x02	; 2
     4fc:	60 e8       	ldi	r22, 0x80	; 128
     4fe:	42 e3       	ldi	r20, 0x32	; 50
     500:	0e 94 27 12 	call	0x244e	; 0x244e <Endpoint_ConfigureEndpoint_Prv>
     504:	18 2f       	mov	r17, r24
     506:	83 e0       	ldi	r24, 0x03	; 3
     508:	61 ec       	ldi	r22, 0xC1	; 193
     50a:	42 e0       	ldi	r20, 0x02	; 2
     50c:	0e 94 27 12 	call	0x244e	; 0x244e <Endpoint_ConfigureEndpoint_Prv>
	bool ConfigSuccess = true;

	/* Setup RNDIS Data Endpoints */
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     510:	20 2f       	mov	r18, r16
     512:	30 e0       	ldi	r19, 0x00	; 0
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     514:	41 2f       	mov	r20, r17
     516:	50 e0       	ldi	r21, 0x00	; 0
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	/* Setup RNDIS Data Endpoints */
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     518:	24 23       	and	r18, r20
     51a:	35 23       	and	r19, r21
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPADDR, EP_TYPE_BULK, CDC_TXRX_EPSIZE, 1);
     51c:	21 70       	andi	r18, 0x01	; 1
     51e:	30 70       	andi	r19, 0x00	; 0
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPADDR, EP_TYPE_INTERRUPT, CDC_NOTIFICATION_EPSIZE, 1);
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	28 23       	and	r18, r24
     524:	39 23       	and	r19, r25

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     526:	21 15       	cp	r18, r1
     528:	31 05       	cpc	r19, r1
     52a:	11 f0       	breq	.+4      	; 0x530 <EVENT_USB_Device_ConfigurationChanged+0x46>
     52c:	80 e6       	ldi	r24, 0x60	; 96
     52e:	01 c0       	rjmp	.+2      	; 0x532 <EVENT_USB_Device_ConfigurationChanged+0x48>
     530:	80 e9       	ldi	r24, 0x90	; 144
     532:	a3 df       	rcall	.-186    	; 0x47a <LEDs_SetAllLEDs>
}
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	08 95       	ret

0000053a <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     53a:	80 91 da 13 	lds	r24, 0x13DA
     53e:	88 23       	and	r24, r24
     540:	21 f0       	breq	.+8      	; 0x54a <EVENT_USB_Device_ControlRequest+0x10>
     542:	81 30       	cpi	r24, 0x01	; 1
     544:	09 f0       	breq	.+2      	; 0x548 <EVENT_USB_Device_ControlRequest+0xe>
     546:	4f c0       	rjmp	.+158    	; 0x5e6 <EVENT_USB_Device_ControlRequest+0xac>
     548:	18 c0       	rjmp	.+48     	; 0x57a <EVENT_USB_Device_ControlRequest+0x40>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     54a:	80 91 d9 13 	lds	r24, 0x13D9
     54e:	81 32       	cpi	r24, 0x21	; 33
     550:	09 f0       	breq	.+2      	; 0x554 <EVENT_USB_Device_ControlRequest+0x1a>
     552:	49 c0       	rjmp	.+146    	; 0x5e6 <EVENT_USB_Device_ControlRequest+0xac>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     554:	80 91 e8 00 	lds	r24, 0x00E8
     558:	87 7f       	andi	r24, 0xF7	; 247
     55a:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     55e:	60 91 df 13 	lds	r22, 0x13DF
     562:	70 91 e0 13 	lds	r23, 0x13E0
     566:	89 e0       	ldi	r24, 0x09	; 9
     568:	9d e0       	ldi	r25, 0x0D	; 13
     56a:	0e 94 88 11 	call	0x2310	; 0x2310 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     56e:	80 91 e8 00 	lds	r24, 0x00E8
     572:	8e 77       	andi	r24, 0x7E	; 126
     574:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     578:	fb c1       	rjmp	.+1014   	; 0x970 <ProcessRNDISControlMessage>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     57a:	80 91 d9 13 	lds	r24, 0x13D9
     57e:	81 3a       	cpi	r24, 0xA1	; 161
     580:	91 f5       	brne	.+100    	; 0x5e6 <EVENT_USB_Device_ControlRequest+0xac>
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     582:	e0 91 20 01 	lds	r30, 0x0120
     586:	f0 91 21 01 	lds	r31, 0x0121
     58a:	84 81       	ldd	r24, Z+4	; 0x04
     58c:	95 81       	ldd	r25, Z+5	; 0x05
     58e:	a6 81       	ldd	r26, Z+6	; 0x06
     590:	b7 81       	ldd	r27, Z+7	; 0x07
     592:	00 97       	sbiw	r24, 0x00	; 0
     594:	a1 05       	cpc	r26, r1
     596:	b1 05       	cpc	r27, r1
     598:	51 f4       	brne	.+20     	; 0x5ae <EVENT_USB_Device_ControlRequest+0x74>
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     59a:	10 92 09 0d 	sts	0x0D09, r1
					MessageHeader->MessageLength = 1;
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	a0 e0       	ldi	r26, 0x00	; 0
     5a4:	b0 e0       	ldi	r27, 0x00	; 0
     5a6:	84 83       	std	Z+4, r24	; 0x04
     5a8:	95 83       	std	Z+5, r25	; 0x05
     5aa:	a6 83       	std	Z+6, r26	; 0x06
     5ac:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     5ae:	80 91 e8 00 	lds	r24, 0x00E8
     5b2:	87 7f       	andi	r24, 0xF7	; 247
     5b4:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     5b8:	e0 91 20 01 	lds	r30, 0x0120
     5bc:	f0 91 21 01 	lds	r31, 0x0121
     5c0:	64 81       	ldd	r22, Z+4	; 0x04
     5c2:	75 81       	ldd	r23, Z+5	; 0x05
     5c4:	89 e0       	ldi	r24, 0x09	; 9
     5c6:	9d e0       	ldi	r25, 0x0D	; 13
     5c8:	0e 94 2a 11 	call	0x2254	; 0x2254 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     5cc:	80 91 e8 00 	lds	r24, 0x00E8
     5d0:	8b 77       	andi	r24, 0x7B	; 123
     5d2:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     5d6:	e0 91 20 01 	lds	r30, 0x0120
     5da:	f0 91 21 01 	lds	r31, 0x0121
     5de:	14 82       	std	Z+4, r1	; 0x04
     5e0:	15 82       	std	Z+5, r1	; 0x05
     5e2:	16 82       	std	Z+6, r1	; 0x06
     5e4:	17 82       	std	Z+7, r1	; 0x07
     5e6:	08 95       	ret

000005e8 <RNDIS_Task>:
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     5e8:	df 93       	push	r29
     5ea:	cf 93       	push	r28
     5ec:	cd b7       	in	r28, 0x3d	; 61
     5ee:	de b7       	in	r29, 0x3e	; 62
     5f0:	ac 97       	sbiw	r28, 0x2c	; 44
     5f2:	0f b6       	in	r0, 0x3f	; 63
     5f4:	f8 94       	cli
     5f6:	de bf       	out	0x3e, r29	; 62
     5f8:	0f be       	out	0x3f, r0	; 63
     5fa:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     5fc:	83 e0       	ldi	r24, 0x03	; 3
     5fe:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     602:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPADDR);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     606:	80 ff       	sbrs	r24, 0
     608:	1c c0       	rjmp	.+56     	; 0x642 <RNDIS_Task+0x5a>
     60a:	80 91 46 01 	lds	r24, 0x0146
     60e:	88 23       	and	r24, r24
     610:	c1 f0       	breq	.+48     	; 0x642 <RNDIS_Task+0x5a>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
     612:	de 01       	movw	r26, r28
     614:	11 96       	adiw	r26, 0x01	; 1
     616:	e0 e0       	ldi	r30, 0x00	; 0
     618:	f1 e0       	ldi	r31, 0x01	; 1
     61a:	88 e0       	ldi	r24, 0x08	; 8
     61c:	01 90       	ld	r0, Z+
     61e:	0d 92       	st	X+, r0
     620:	81 50       	subi	r24, 0x01	; 1
     622:	e1 f7       	brne	.-8      	; 0x61c <RNDIS_Task+0x34>
				.wIndex        = 0,
				.wLength       = 0,
			};

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);
     624:	ce 01       	movw	r24, r28
     626:	01 96       	adiw	r24, 0x01	; 1
     628:	68 e0       	ldi	r22, 0x08	; 8
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	40 e0       	ldi	r20, 0x00	; 0
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	0e 94 6e 10 	call	0x20dc	; 0x20dc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     634:	80 91 e8 00 	lds	r24, 0x00E8
     638:	8e 77       	andi	r24, 0x7E	; 126
     63a:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     63e:	10 92 46 01 	sts	0x0146, r1
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     642:	20 91 47 01 	lds	r18, 0x0147
     646:	22 30       	cpi	r18, 0x02	; 2
     648:	09 f0       	breq	.+2      	; 0x64c <RNDIS_Task+0x64>
     64a:	90 c0       	rjmp	.+288    	; 0x76c <RNDIS_Task+0x184>
     64c:	e0 91 20 01 	lds	r30, 0x0120
     650:	f0 91 21 01 	lds	r31, 0x0121
     654:	84 81       	ldd	r24, Z+4	; 0x04
     656:	95 81       	ldd	r25, Z+5	; 0x05
     658:	a6 81       	ldd	r26, Z+6	; 0x06
     65a:	b7 81       	ldd	r27, Z+7	; 0x07
     65c:	00 97       	sbiw	r24, 0x00	; 0
     65e:	a1 05       	cpc	r26, r1
     660:	b1 05       	cpc	r27, r1
     662:	09 f0       	breq	.+2      	; 0x666 <RNDIS_Task+0x7e>
     664:	83 c0       	rjmp	.+262    	; 0x76c <RNDIS_Task+0x184>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     666:	20 93 e9 00 	sts	0x00E9, r18
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     66a:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPADDR);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength))
     66e:	82 ff       	sbrs	r24, 2
     670:	32 c0       	rjmp	.+100    	; 0x6d6 <RNDIS_Task+0xee>
     672:	80 91 29 07 	lds	r24, 0x0729
     676:	90 91 2a 07 	lds	r25, 0x072A
     67a:	00 97       	sbiw	r24, 0x00	; 0
     67c:	61 f5       	brne	.+88     	; 0x6d6 <RNDIS_Task+0xee>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     67e:	ce 01       	movw	r24, r28
     680:	01 96       	adiw	r24, 0x01	; 1
     682:	6c e2       	ldi	r22, 0x2C	; 44
     684:	70 e0       	ldi	r23, 0x00	; 0
     686:	40 e0       	ldi	r20, 0x00	; 0
     688:	50 e0       	ldi	r21, 0x00	; 0
     68a:	0e 94 cc 10 	call	0x2198	; 0x2198 <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     68e:	2d 85       	ldd	r18, Y+13	; 0x0d
     690:	3e 85       	ldd	r19, Y+14	; 0x0e
     692:	4f 85       	ldd	r20, Y+15	; 0x0f
     694:	58 89       	ldd	r21, Y+16	; 0x10
     696:	2d 3d       	cpi	r18, 0xDD	; 221
     698:	85 e0       	ldi	r24, 0x05	; 5
     69a:	38 07       	cpc	r19, r24
     69c:	80 e0       	ldi	r24, 0x00	; 0
     69e:	48 07       	cpc	r20, r24
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	58 07       	cpc	r21, r24
     6a4:	30 f0       	brcs	.+12     	; 0x6b2 <RNDIS_Task+0xca>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     6a6:	80 91 eb 00 	lds	r24, 0x00EB
     6aa:	80 62       	ori	r24, 0x20	; 32
     6ac:	80 93 eb 00 	sts	0x00EB, r24
			{
				Endpoint_StallTransaction();
				return;
     6b0:	5d c0       	rjmp	.+186    	; 0x76c <RNDIS_Task+0x184>
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength, NULL);
     6b2:	8d e4       	ldi	r24, 0x4D	; 77
     6b4:	91 e0       	ldi	r25, 0x01	; 1
     6b6:	b9 01       	movw	r22, r18
     6b8:	40 e0       	ldi	r20, 0x00	; 0
     6ba:	50 e0       	ldi	r21, 0x00	; 0
     6bc:	0e 94 cc 10 	call	0x2198	; 0x2198 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     6c0:	80 91 e8 00 	lds	r24, 0x00E8
     6c4:	8b 77       	andi	r24, 0x7B	; 123
     6c6:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     6ca:	8d 85       	ldd	r24, Y+13	; 0x0d
     6cc:	9e 85       	ldd	r25, Y+14	; 0x0e
     6ce:	90 93 2a 07 	sts	0x072A, r25
     6d2:	80 93 29 07 	sts	0x0729, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     6dc:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPADDR);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameLength)
     6e0:	80 ff       	sbrs	r24, 0
     6e2:	44 c0       	rjmp	.+136    	; 0x76c <RNDIS_Task+0x184>
     6e4:	20 91 07 0d 	lds	r18, 0x0D07
     6e8:	30 91 08 0d 	lds	r19, 0x0D08
     6ec:	21 15       	cp	r18, r1
     6ee:	31 05       	cpc	r19, r1
     6f0:	e9 f1       	breq	.+122    	; 0x76c <RNDIS_Task+0x184>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     6f2:	ce 01       	movw	r24, r28
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	4c e2       	ldi	r20, 0x2C	; 44
     6f8:	fc 01       	movw	r30, r24
     6fa:	11 92       	st	Z+, r1
     6fc:	4a 95       	dec	r20
     6fe:	e9 f7       	brne	.-6      	; 0x6fa <RNDIS_Task+0x112>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     700:	41 e0       	ldi	r20, 0x01	; 1
     702:	50 e0       	ldi	r21, 0x00	; 0
     704:	60 e0       	ldi	r22, 0x00	; 0
     706:	70 e0       	ldi	r23, 0x00	; 0
     708:	49 83       	std	Y+1, r20	; 0x01
     70a:	5a 83       	std	Y+2, r21	; 0x02
     70c:	6b 83       	std	Y+3, r22	; 0x03
     70e:	7c 83       	std	Y+4, r23	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     710:	a9 01       	movw	r20, r18
     712:	44 5d       	subi	r20, 0xD4	; 212
     714:	5f 4f       	sbci	r21, 0xFF	; 255
     716:	60 e0       	ldi	r22, 0x00	; 0
     718:	70 e0       	ldi	r23, 0x00	; 0
     71a:	4d 83       	std	Y+5, r20	; 0x05
     71c:	5e 83       	std	Y+6, r21	; 0x06
     71e:	6f 83       	std	Y+7, r22	; 0x07
     720:	78 87       	std	Y+8, r23	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     722:	44 e2       	ldi	r20, 0x24	; 36
     724:	50 e0       	ldi	r21, 0x00	; 0
     726:	60 e0       	ldi	r22, 0x00	; 0
     728:	70 e0       	ldi	r23, 0x00	; 0
     72a:	49 87       	std	Y+9, r20	; 0x09
     72c:	5a 87       	std	Y+10, r21	; 0x0a
     72e:	6b 87       	std	Y+11, r22	; 0x0b
     730:	7c 87       	std	Y+12, r23	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     732:	40 e0       	ldi	r20, 0x00	; 0
     734:	50 e0       	ldi	r21, 0x00	; 0
     736:	2d 87       	std	Y+13, r18	; 0x0d
     738:	3e 87       	std	Y+14, r19	; 0x0e
     73a:	4f 87       	std	Y+15, r20	; 0x0f
     73c:	58 8b       	std	Y+16, r21	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     73e:	6c e2       	ldi	r22, 0x2C	; 44
     740:	70 e0       	ldi	r23, 0x00	; 0
     742:	40 e0       	ldi	r20, 0x00	; 0
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	0e 94 6e 10 	call	0x20dc	; 0x20dc <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     74a:	6d 85       	ldd	r22, Y+13	; 0x0d
     74c:	7e 85       	ldd	r23, Y+14	; 0x0e
     74e:	8b e2       	ldi	r24, 0x2B	; 43
     750:	97 e0       	ldi	r25, 0x07	; 7
     752:	40 e0       	ldi	r20, 0x00	; 0
     754:	50 e0       	ldi	r21, 0x00	; 0
     756:	0e 94 6e 10 	call	0x20dc	; 0x20dc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     75a:	80 91 e8 00 	lds	r24, 0x00E8
     75e:	8e 77       	andi	r24, 0x7E	; 126
     760:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     764:	10 92 08 0d 	sts	0x0D08, r1
     768:	10 92 07 0d 	sts	0x0D07, r1
		}
	}
}
     76c:	ac 96       	adiw	r28, 0x2c	; 44
     76e:	0f b6       	in	r0, 0x3f	; 63
     770:	f8 94       	cli
     772:	de bf       	out	0x3e, r29	; 62
     774:	0f be       	out	0x3f, r0	; 63
     776:	cd bf       	out	0x3d, r28	; 61
     778:	cf 91       	pop	r28
     77a:	df 91       	pop	r29
     77c:	08 95       	ret

0000077e <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     77e:	80 91 d8 13 	lds	r24, 0x13D8
     782:	84 30       	cpi	r24, 0x04	; 4
     784:	59 f4       	brne	.+22     	; 0x79c <Ethernet_Task+0x1e>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     786:	80 91 29 07 	lds	r24, 0x0729
     78a:	90 91 2a 07 	lds	r25, 0x072A
     78e:	00 97       	sbiw	r24, 0x00	; 0
     790:	29 f0       	breq	.+10     	; 0x79c <Ethernet_Task+0x1e>
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     792:	80 e2       	ldi	r24, 0x20	; 32
     794:	72 de       	rcall	.-796    	; 0x47a <LEDs_SetAllLEDs>

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     796:	41 d0       	rcall	.+130    	; 0x81a <Ethernet_ProcessPacket>

		/* Indicate packet processing complete */
		LEDs_SetAllLEDs(LEDMASK_USB_READY);
     798:	80 e6       	ldi	r24, 0x60	; 96
     79a:	6f ce       	rjmp	.-802    	; 0x47a <LEDs_SetAllLEDs>
     79c:	08 95       	ret

0000079e <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     79e:	72 de       	rcall	.-796    	; 0x484 <SetupHardware>

	/* Webserver Initialization */
	TCP_Init();
     7a0:	e5 d5       	rcall	.+3018   	; 0x136c <TCP_Init>
	Webserver_Init();
     7a2:	0e 94 68 10 	call	0x20d0	; 0x20d0 <Webserver_Init>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     7a6:	80 e1       	ldi	r24, 0x10	; 16
     7a8:	68 de       	rcall	.-816    	; 0x47a <LEDs_SetAllLEDs>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     7aa:	78 94       	sei
	GlobalInterruptEnable();

	for (;;)
	{
		Ethernet_Task();
     7ac:	e8 df       	rcall	.-48     	; 0x77e <Ethernet_Task>
		TCP_Task();
     7ae:	93 d4       	rcall	.+2342   	; 0x10d6 <TCP_Task>
		RNDIS_Task();
     7b0:	1b df       	rcall	.-458    	; 0x5e8 <RNDIS_Task>
		USB_USBTask();
     7b2:	0e 94 44 15 	call	0x2a88	; 0x2a88 <USB_USBTask>
     7b6:	fa cf       	rjmp	.-12     	; 0x7ac <main+0xe>

000007b8 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     7b8:	92 30       	cpi	r25, 0x02	; 2
     7ba:	29 f0       	breq	.+10     	; 0x7c6 <CALLBACK_USB_GetDescriptor+0xe>
     7bc:	93 30       	cpi	r25, 0x03	; 3
     7be:	41 f0       	breq	.+16     	; 0x7d0 <CALLBACK_USB_GetDescriptor+0x18>
     7c0:	91 30       	cpi	r25, 0x01	; 1
     7c2:	e9 f4       	brne	.+58     	; 0x7fe <CALLBACK_USB_GetDescriptor+0x46>
     7c4:	17 c0       	rjmp	.+46     	; 0x7f4 <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     7c6:	2e e3       	ldi	r18, 0x3E	; 62
     7c8:	30 e0       	ldi	r19, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     7ca:	ea ea       	ldi	r30, 0xAA	; 170
     7cc:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     7ce:	1b c0       	rjmp	.+54     	; 0x806 <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     7d0:	81 30       	cpi	r24, 0x01	; 1
     7d2:	41 f0       	breq	.+16     	; 0x7e4 <CALLBACK_USB_GetDescriptor+0x2c>
     7d4:	81 30       	cpi	r24, 0x01	; 1
     7d6:	18 f0       	brcs	.+6      	; 0x7de <CALLBACK_USB_GetDescriptor+0x26>
     7d8:	82 30       	cpi	r24, 0x02	; 2
     7da:	89 f4       	brne	.+34     	; 0x7fe <CALLBACK_USB_GetDescriptor+0x46>
     7dc:	06 c0       	rjmp	.+12     	; 0x7ea <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     7de:	e8 ee       	ldi	r30, 0xE8	; 232
     7e0:	f0 e0       	ldi	r31, 0x00	; 0
     7e2:	05 c0       	rjmp	.+10     	; 0x7ee <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     7e4:	ec ee       	ldi	r30, 0xEC	; 236
     7e6:	f0 e0       	ldi	r31, 0x00	; 0
     7e8:	02 c0       	rjmp	.+4      	; 0x7ee <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     7ea:	e6 e0       	ldi	r30, 0x06	; 6
     7ec:	f1 e0       	ldi	r31, 0x01	; 1
     7ee:	24 91       	lpm	r18, Z+
     7f0:	30 e0       	ldi	r19, 0x00	; 0
					break;
     7f2:	09 c0       	rjmp	.+18     	; 0x806 <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     7f4:	22 e1       	ldi	r18, 0x12	; 18
     7f6:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     7f8:	e8 e9       	ldi	r30, 0x98	; 152
     7fa:	f0 e0       	ldi	r31, 0x00	; 0
     7fc:	04 c0       	rjmp	.+8      	; 0x806 <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	30 e0       	ldi	r19, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     802:	e0 e0       	ldi	r30, 0x00	; 0
     804:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     806:	da 01       	movw	r26, r20
     808:	11 96       	adiw	r26, 0x01	; 1
     80a:	fc 93       	st	X, r31
     80c:	ee 93       	st	-X, r30
	return Size;
}
     80e:	c9 01       	movw	r24, r18
     810:	08 95       	ret

00000812 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     812:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     814:	89 2f       	mov	r24, r25
     816:	92 2f       	mov	r25, r18
     818:	08 95       	ret

0000081a <Ethernet_ProcessPacket>:

/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
     81a:	ef 92       	push	r14
     81c:	ff 92       	push	r15
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     822:	cd e4       	ldi	r28, 0x4D	; 77
     824:	d1 e0       	ldi	r29, 0x01	; 1
     826:	ce 01       	movw	r24, r28
     828:	9c d0       	rcall	.+312    	; 0x962 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     82a:	ce 01       	movw	r24, r28
     82c:	68 e0       	ldi	r22, 0x08	; 8
     82e:	71 e0       	ldi	r23, 0x01	; 1
     830:	46 e0       	ldi	r20, 0x06	; 6
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <memcmp>
     838:	00 97       	sbiw	r24, 0x00	; 0
     83a:	51 f0       	breq	.+20     	; 0x850 <Ethernet_ProcessPacket+0x36>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     83c:	ce 01       	movw	r24, r28
     83e:	62 e1       	ldi	r22, 0x12	; 18
     840:	71 e0       	ldi	r23, 0x01	; 1
     842:	46 e0       	ldi	r20, 0x06	; 6
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <memcmp>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     84a:	00 97       	sbiw	r24, 0x00	; 0
     84c:	09 f0       	breq	.+2      	; 0x850 <Ethernet_ProcessPacket+0x36>
     84e:	4b c0       	rjmp	.+150    	; 0x8e6 <Ethernet_ProcessPacket+0xcc>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
     850:	80 91 29 07 	lds	r24, 0x0729
     854:	90 91 2a 07 	lds	r25, 0x072A
     858:	dc df       	rcall	.-72     	; 0x812 <SwapEndian_16>

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     85a:	26 e0       	ldi	r18, 0x06	; 6
     85c:	81 30       	cpi	r24, 0x01	; 1
     85e:	92 07       	cpc	r25, r18
     860:	08 f4       	brcc	.+2      	; 0x864 <Ethernet_ProcessPacket+0x4a>
     862:	41 c0       	rjmp	.+130    	; 0x8e6 <Ethernet_ProcessPacket+0xcc>
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     864:	80 91 59 01 	lds	r24, 0x0159
     868:	90 91 5a 01 	lds	r25, 0x015A
     86c:	d2 df       	rcall	.-92     	; 0x812 <SwapEndian_16>
     86e:	38 e0       	ldi	r19, 0x08	; 8
     870:	80 30       	cpi	r24, 0x00	; 0
     872:	93 07       	cpc	r25, r19
     874:	59 f0       	breq	.+22     	; 0x88c <Ethernet_ProcessPacket+0x72>
     876:	28 e0       	ldi	r18, 0x08	; 8
     878:	86 30       	cpi	r24, 0x06	; 6
     87a:	92 07       	cpc	r25, r18
     87c:	a1 f5       	brne	.+104    	; 0x8e6 <Ethernet_ProcessPacket+0xcc>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     87e:	8b e5       	ldi	r24, 0x5B	; 91
     880:	91 e0       	ldi	r25, 0x01	; 1
     882:	69 e3       	ldi	r22, 0x39	; 57
     884:	77 e0       	ldi	r23, 0x07	; 7
     886:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <ARP_ProcessARPPacket>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     88a:	06 c0       	rjmp	.+12     	; 0x898 <Ethernet_ProcessPacket+0x7e>
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     88c:	8b e5       	ldi	r24, 0x5B	; 91
     88e:	91 e0       	ldi	r25, 0x01	; 1
     890:	69 e3       	ldi	r22, 0x39	; 57
     892:	77 e0       	ldi	r23, 0x07	; 7
     894:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <IP_ProcessIPPacket>
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     898:	18 16       	cp	r1, r24
     89a:	19 06       	cpc	r1, r25
     89c:	04 f5       	brge	.+64     	; 0x8de <Ethernet_ProcessPacket+0xc4>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     89e:	a1 e3       	ldi	r26, 0x31	; 49
     8a0:	b7 e0       	ldi	r27, 0x07	; 7
     8a2:	e8 e0       	ldi	r30, 0x08	; 8
     8a4:	f1 e0       	ldi	r31, 0x01	; 1
     8a6:	26 e0       	ldi	r18, 0x06	; 6
     8a8:	01 90       	ld	r0, Z+
     8aa:	0d 92       	st	X+, r0
     8ac:	21 50       	subi	r18, 0x01	; 1
     8ae:	e1 f7       	brne	.-8      	; 0x8a8 <Ethernet_ProcessPacket+0x8e>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     8b0:	ab e2       	ldi	r26, 0x2B	; 43
     8b2:	b7 e0       	ldi	r27, 0x07	; 7
     8b4:	e3 e5       	ldi	r30, 0x53	; 83
     8b6:	f1 e0       	ldi	r31, 0x01	; 1
     8b8:	26 e0       	ldi	r18, 0x06	; 6
     8ba:	01 90       	ld	r0, Z+
     8bc:	0d 92       	st	X+, r0
     8be:	21 50       	subi	r18, 0x01	; 1
     8c0:	e1 f7       	brne	.-8      	; 0x8ba <Ethernet_ProcessPacket+0xa0>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     8c2:	20 91 59 01 	lds	r18, 0x0159
     8c6:	30 91 5a 01 	lds	r19, 0x015A
     8ca:	30 93 38 07 	sts	0x0738, r19
     8ce:	20 93 37 07 	sts	0x0737, r18

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     8d2:	0e 96       	adiw	r24, 0x0e	; 14
     8d4:	90 93 08 0d 	sts	0x0D08, r25
     8d8:	80 93 07 0d 	sts	0x0D07, r24
     8dc:	04 c0       	rjmp	.+8      	; 0x8e6 <Ethernet_ProcessPacket+0xcc>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     8de:	3f ef       	ldi	r19, 0xFF	; 255
     8e0:	8f 3f       	cpi	r24, 0xFF	; 255
     8e2:	93 07       	cpc	r25, r19
     8e4:	21 f0       	breq	.+8      	; 0x8ee <Ethernet_ProcessPacket+0xd4>
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     8e6:	10 92 2a 07 	sts	0x072A, r1
     8ea:	10 92 29 07 	sts	0x0729, r1
	}
}
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	ff 90       	pop	r15
     8f4:	ef 90       	pop	r14
     8f6:	08 95       	ret

000008f8 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     8f8:	cf 93       	push	r28
     8fa:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     8fc:	76 95       	lsr	r23
     8fe:	67 95       	ror	r22
     900:	28 2f       	mov	r18, r24
     902:	39 2f       	mov	r19, r25
     904:	e9 01       	movw	r28, r18
     906:	e0 e0       	ldi	r30, 0x00	; 0
     908:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     90a:	80 e0       	ldi	r24, 0x00	; 0
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	dc 01       	movw	r26, r24

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     910:	09 c0       	rjmp	.+18     	; 0x924 <Ethernet_Checksum16+0x2c>
	  Checksum += Words[CurrWord];
     912:	29 91       	ld	r18, Y+
     914:	39 91       	ld	r19, Y+
     916:	40 e0       	ldi	r20, 0x00	; 0
     918:	50 e0       	ldi	r21, 0x00	; 0
     91a:	82 0f       	add	r24, r18
     91c:	93 1f       	adc	r25, r19
     91e:	a4 1f       	adc	r26, r20
     920:	b5 1f       	adc	r27, r21
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     922:	31 96       	adiw	r30, 0x01	; 1
     924:	e6 17       	cp	r30, r22
     926:	f7 07       	cpc	r31, r23
     928:	a0 f3       	brcs	.-24     	; 0x912 <Ethernet_Checksum16+0x1a>
     92a:	0b c0       	rjmp	.+22     	; 0x942 <Ethernet_Checksum16+0x4a>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     92c:	9c 01       	movw	r18, r24
     92e:	ad 01       	movw	r20, r26
     930:	40 70       	andi	r20, 0x00	; 0
     932:	50 70       	andi	r21, 0x00	; 0
     934:	cd 01       	movw	r24, r26
     936:	aa 27       	eor	r26, r26
     938:	bb 27       	eor	r27, r27
     93a:	82 0f       	add	r24, r18
     93c:	93 1f       	adc	r25, r19
     93e:	a4 1f       	adc	r26, r20
     940:	b5 1f       	adc	r27, r21
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     942:	9c 01       	movw	r18, r24
     944:	ad 01       	movw	r20, r26
     946:	20 70       	andi	r18, 0x00	; 0
     948:	30 70       	andi	r19, 0x00	; 0
     94a:	21 15       	cp	r18, r1
     94c:	31 05       	cpc	r19, r1
     94e:	41 05       	cpc	r20, r1
     950:	51 05       	cpc	r21, r1
     952:	61 f7       	brne	.-40     	; 0x92c <Ethernet_Checksum16+0x34>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     954:	9c 01       	movw	r18, r24
     956:	20 95       	com	r18
     958:	30 95       	com	r19
}
     95a:	c9 01       	movw	r24, r18
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	08 95       	ret

00000962 <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     962:	08 95       	ret

00000964 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     964:	08 95       	ret

00000966 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     966:	08 95       	ret

00000968 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     968:	08 95       	ret

0000096a <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     96a:	08 95       	ret

0000096c <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     96c:	08 95       	ret

0000096e <DecodeDHCPHeader>:
		}

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}
	#endif
}
     96e:	08 95       	ret

00000970 <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
     970:	e0 91 20 01 	lds	r30, 0x0120
     974:	f0 91 21 01 	lds	r31, 0x0121
     978:	80 81       	ld	r24, Z
     97a:	91 81       	ldd	r25, Z+1	; 0x01
     97c:	a2 81       	ldd	r26, Z+2	; 0x02
     97e:	b3 81       	ldd	r27, Z+3	; 0x03
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	91 05       	cpc	r25, r1
     984:	a1 05       	cpc	r26, r1
     986:	b1 05       	cpc	r27, r1
     988:	09 f4       	brne	.+2      	; 0x98c <ProcessRNDISControlMessage+0x1c>
     98a:	a3 c0       	rjmp	.+326    	; 0xad2 <ProcessRNDISControlMessage+0x162>
     98c:	85 30       	cpi	r24, 0x05	; 5
     98e:	91 05       	cpc	r25, r1
     990:	a1 05       	cpc	r26, r1
     992:	b1 05       	cpc	r27, r1
     994:	60 f4       	brcc	.+24     	; 0x9ae <ProcessRNDISControlMessage+0x3e>
     996:	82 30       	cpi	r24, 0x02	; 2
     998:	91 05       	cpc	r25, r1
     99a:	a1 05       	cpc	r26, r1
     99c:	b1 05       	cpc	r27, r1
     99e:	d1 f0       	breq	.+52     	; 0x9d4 <ProcessRNDISControlMessage+0x64>
     9a0:	83 30       	cpi	r24, 0x03	; 3
     9a2:	91 05       	cpc	r25, r1
     9a4:	a1 05       	cpc	r26, r1
     9a6:	b1 05       	cpc	r27, r1
     9a8:	09 f0       	breq	.+2      	; 0x9ac <ProcessRNDISControlMessage+0x3c>
     9aa:	ca c2       	rjmp	.+1428   	; 0xf40 <ProcessRNDISControlMessage+0x5d0>
     9ac:	89 c0       	rjmp	.+274    	; 0xac0 <ProcessRNDISControlMessage+0x150>
     9ae:	86 30       	cpi	r24, 0x06	; 6
     9b0:	91 05       	cpc	r25, r1
     9b2:	a1 05       	cpc	r26, r1
     9b4:	b1 05       	cpc	r27, r1
     9b6:	09 f4       	brne	.+2      	; 0x9ba <ProcessRNDISControlMessage+0x4a>
     9b8:	3c c2       	rjmp	.+1144   	; 0xe32 <ProcessRNDISControlMessage+0x4c2>
     9ba:	86 30       	cpi	r24, 0x06	; 6
     9bc:	91 05       	cpc	r25, r1
     9be:	a1 05       	cpc	r26, r1
     9c0:	b1 05       	cpc	r27, r1
     9c2:	08 f4       	brcc	.+2      	; 0x9c6 <ProcessRNDISControlMessage+0x56>
     9c4:	e6 c1       	rjmp	.+972    	; 0xd92 <ProcessRNDISControlMessage+0x422>
     9c6:	88 30       	cpi	r24, 0x08	; 8
     9c8:	91 05       	cpc	r25, r1
     9ca:	a1 05       	cpc	r26, r1
     9cc:	b1 05       	cpc	r27, r1
     9ce:	09 f0       	breq	.+2      	; 0x9d2 <ProcessRNDISControlMessage+0x62>
     9d0:	b7 c2       	rjmp	.+1390   	; 0xf40 <ProcessRNDISControlMessage+0x5d0>
     9d2:	53 c2       	rjmp	.+1190   	; 0xe7a <ProcessRNDISControlMessage+0x50a>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
     9d4:	21 e0       	ldi	r18, 0x01	; 1
     9d6:	20 93 46 01 	sts	0x0146, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
     9da:	82 e0       	ldi	r24, 0x02	; 2
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	a0 e0       	ldi	r26, 0x00	; 0
     9e0:	b0 e8       	ldi	r27, 0x80	; 128
     9e2:	80 93 09 0d 	sts	0x0D09, r24
     9e6:	90 93 0a 0d 	sts	0x0D0A, r25
     9ea:	a0 93 0b 0d 	sts	0x0D0B, r26
     9ee:	b0 93 0c 0d 	sts	0x0D0C, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
     9f2:	84 e3       	ldi	r24, 0x34	; 52
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	a0 e0       	ldi	r26, 0x00	; 0
     9f8:	b0 e0       	ldi	r27, 0x00	; 0
     9fa:	80 93 0d 0d 	sts	0x0D0D, r24
     9fe:	90 93 0e 0d 	sts	0x0D0E, r25
     a02:	a0 93 0f 0d 	sts	0x0D0F, r26
     a06:	b0 93 10 0d 	sts	0x0D10, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
     a0a:	10 92 15 0d 	sts	0x0D15, r1
     a0e:	10 92 16 0d 	sts	0x0D16, r1
     a12:	10 92 17 0d 	sts	0x0D17, r1
     a16:	10 92 18 0d 	sts	0x0D18, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	90 e0       	ldi	r25, 0x00	; 0
     a1e:	a0 e0       	ldi	r26, 0x00	; 0
     a20:	b0 e0       	ldi	r27, 0x00	; 0
     a22:	80 93 19 0d 	sts	0x0D19, r24
     a26:	90 93 1a 0d 	sts	0x0D1A, r25
     a2a:	a0 93 1b 0d 	sts	0x0D1B, r26
     a2e:	b0 93 1c 0d 	sts	0x0D1C, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
     a32:	10 92 1d 0d 	sts	0x0D1D, r1
     a36:	10 92 1e 0d 	sts	0x0D1E, r1
     a3a:	10 92 1f 0d 	sts	0x0D1F, r1
     a3e:	10 92 20 0d 	sts	0x0D20, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
     a42:	80 93 21 0d 	sts	0x0D21, r24
     a46:	90 93 22 0d 	sts	0x0D22, r25
     a4a:	a0 93 23 0d 	sts	0x0D23, r26
     a4e:	b0 93 24 0d 	sts	0x0D24, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
     a52:	10 92 25 0d 	sts	0x0D25, r1
     a56:	10 92 26 0d 	sts	0x0D26, r1
     a5a:	10 92 27 0d 	sts	0x0D27, r1
     a5e:	10 92 28 0d 	sts	0x0D28, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
     a62:	80 93 29 0d 	sts	0x0D29, r24
     a66:	90 93 2a 0d 	sts	0x0D2A, r25
     a6a:	a0 93 2b 0d 	sts	0x0D2B, r26
     a6e:	b0 93 2c 0d 	sts	0x0D2C, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
     a72:	88 e0       	ldi	r24, 0x08	; 8
     a74:	96 e0       	ldi	r25, 0x06	; 6
     a76:	a0 e0       	ldi	r26, 0x00	; 0
     a78:	b0 e0       	ldi	r27, 0x00	; 0
     a7a:	80 93 2d 0d 	sts	0x0D2D, r24
     a7e:	90 93 2e 0d 	sts	0x0D2E, r25
     a82:	a0 93 2f 0d 	sts	0x0D2F, r26
     a86:	b0 93 30 0d 	sts	0x0D30, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
     a8a:	10 92 31 0d 	sts	0x0D31, r1
     a8e:	10 92 32 0d 	sts	0x0D32, r1
     a92:	10 92 33 0d 	sts	0x0D33, r1
     a96:	10 92 34 0d 	sts	0x0D34, r1
			INITIALIZE_Response->AFListOffset          = 0;
     a9a:	10 92 35 0d 	sts	0x0D35, r1
     a9e:	10 92 36 0d 	sts	0x0D36, r1
     aa2:	10 92 37 0d 	sts	0x0D37, r1
     aa6:	10 92 38 0d 	sts	0x0D38, r1
			INITIALIZE_Response->AFListSize            = 0;
     aaa:	10 92 39 0d 	sts	0x0D39, r1
     aae:	10 92 3a 0d 	sts	0x0D3A, r1
     ab2:	10 92 3b 0d 	sts	0x0D3B, r1
     ab6:	10 92 3c 0d 	sts	0x0D3C, r1

			CurrRNDISState = RNDIS_Initialized;
     aba:	20 93 47 01 	sts	0x0147, r18

			break;
     abe:	08 95       	ret
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
     ac0:	10 92 46 01 	sts	0x0146, r1
			MessageHeader->MessageLength = 0;
     ac4:	14 82       	std	Z+4, r1	; 0x04
     ac6:	15 82       	std	Z+5, r1	; 0x05
     ac8:	16 82       	std	Z+6, r1	; 0x06
     aca:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
     acc:	10 92 47 01 	sts	0x0147, r1

			break;
     ad0:	08 95       	ret
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	80 93 46 01 	sts	0x0146, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
			uint32_t                Query_Oid      = QUERY_Message->Oid;
     ad8:	80 91 15 0d 	lds	r24, 0x0D15
     adc:	90 91 16 0d 	lds	r25, 0x0D16
     ae0:	a0 91 17 0d 	lds	r26, 0x0D17
     ae4:	b0 91 18 0d 	lds	r27, 0x0D18
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
     ae8:	24 e0       	ldi	r18, 0x04	; 4
     aea:	30 e0       	ldi	r19, 0x00	; 0
     aec:	40 e0       	ldi	r20, 0x00	; 0
     aee:	50 e8       	ldi	r21, 0x80	; 128
     af0:	20 93 09 0d 	sts	0x0D09, r18
     af4:	30 93 0a 0d 	sts	0x0D0A, r19
     af8:	40 93 0b 0d 	sts	0x0D0B, r20
     afc:	50 93 0c 0d 	sts	0x0D0C, r21
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
     b00:	28 e1       	ldi	r18, 0x18	; 24
     b02:	30 e0       	ldi	r19, 0x00	; 0
     b04:	40 e0       	ldi	r20, 0x00	; 0
     b06:	50 e0       	ldi	r21, 0x00	; 0
     b08:	20 93 0d 0d 	sts	0x0D0D, r18
     b0c:	30 93 0e 0d 	sts	0x0D0E, r19
     b10:	40 93 0f 0d 	sts	0x0D0F, r20
     b14:	50 93 10 0d 	sts	0x0D10, r21
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
     b18:	8e 30       	cpi	r24, 0x0E	; 14
     b1a:	21 e0       	ldi	r18, 0x01	; 1
     b1c:	92 07       	cpc	r25, r18
     b1e:	21 e0       	ldi	r18, 0x01	; 1
     b20:	a2 07       	cpc	r26, r18
     b22:	20 e0       	ldi	r18, 0x00	; 0
     b24:	b2 07       	cpc	r27, r18
     b26:	09 f4       	brne	.+2      	; 0xb2a <ProcessRNDISControlMessage+0x1ba>
     b28:	f6 c0       	rjmp	.+492    	; 0xd16 <ProcessRNDISControlMessage+0x3a6>
     b2a:	8f 30       	cpi	r24, 0x0F	; 15
     b2c:	61 e0       	ldi	r22, 0x01	; 1
     b2e:	96 07       	cpc	r25, r22
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	a6 07       	cpc	r26, r22
     b34:	60 e0       	ldi	r22, 0x00	; 0
     b36:	b6 07       	cpc	r27, r22
     b38:	08 f0       	brcs	.+2      	; 0xb3c <ProcessRNDISControlMessage+0x1cc>
     b3a:	64 c0       	rjmp	.+200    	; 0xc04 <ProcessRNDISControlMessage+0x294>
     b3c:	86 30       	cpi	r24, 0x06	; 6
     b3e:	e1 e0       	ldi	r30, 0x01	; 1
     b40:	9e 07       	cpc	r25, r30
     b42:	e1 e0       	ldi	r30, 0x01	; 1
     b44:	ae 07       	cpc	r26, r30
     b46:	e0 e0       	ldi	r30, 0x00	; 0
     b48:	be 07       	cpc	r27, r30
     b4a:	09 f4       	brne	.+2      	; 0xb4e <ProcessRNDISControlMessage+0x1de>
     b4c:	bf c0       	rjmp	.+382    	; 0xccc <ProcessRNDISControlMessage+0x35c>
     b4e:	87 30       	cpi	r24, 0x07	; 7
     b50:	f1 e0       	ldi	r31, 0x01	; 1
     b52:	9f 07       	cpc	r25, r31
     b54:	f1 e0       	ldi	r31, 0x01	; 1
     b56:	af 07       	cpc	r26, r31
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	bf 07       	cpc	r27, r31
     b5c:	28 f5       	brcc	.+74     	; 0xba8 <ProcessRNDISControlMessage+0x238>
     b5e:	82 30       	cpi	r24, 0x02	; 2
     b60:	21 e0       	ldi	r18, 0x01	; 1
     b62:	92 07       	cpc	r25, r18
     b64:	21 e0       	ldi	r18, 0x01	; 1
     b66:	a2 07       	cpc	r26, r18
     b68:	20 e0       	ldi	r18, 0x00	; 0
     b6a:	b2 07       	cpc	r27, r18
     b6c:	09 f4       	brne	.+2      	; 0xb70 <ProcessRNDISControlMessage+0x200>
     b6e:	dc c0       	rjmp	.+440    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
     b70:	83 30       	cpi	r24, 0x03	; 3
     b72:	61 e0       	ldi	r22, 0x01	; 1
     b74:	96 07       	cpc	r25, r22
     b76:	61 e0       	ldi	r22, 0x01	; 1
     b78:	a6 07       	cpc	r26, r22
     b7a:	60 e0       	ldi	r22, 0x00	; 0
     b7c:	b6 07       	cpc	r27, r22
     b7e:	50 f4       	brcc	.+20     	; 0xb94 <ProcessRNDISControlMessage+0x224>
     b80:	81 30       	cpi	r24, 0x01	; 1
     b82:	e1 e0       	ldi	r30, 0x01	; 1
     b84:	9e 07       	cpc	r25, r30
     b86:	e1 e0       	ldi	r30, 0x01	; 1
     b88:	ae 07       	cpc	r26, r30
     b8a:	e0 e0       	ldi	r30, 0x00	; 0
     b8c:	be 07       	cpc	r27, r30
     b8e:	09 f0       	breq	.+2      	; 0xb92 <ProcessRNDISControlMessage+0x222>
     b90:	e3 c0       	rjmp	.+454    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     b92:	8c c0       	rjmp	.+280    	; 0xcac <ProcessRNDISControlMessage+0x33c>
     b94:	85 30       	cpi	r24, 0x05	; 5
     b96:	f1 e0       	ldi	r31, 0x01	; 1
     b98:	9f 07       	cpc	r25, r31
     b9a:	f1 e0       	ldi	r31, 0x01	; 1
     b9c:	af 07       	cpc	r26, r31
     b9e:	f0 e0       	ldi	r31, 0x00	; 0
     ba0:	bf 07       	cpc	r27, r31
     ba2:	08 f0       	brcs	.+2      	; 0xba6 <ProcessRNDISControlMessage+0x236>
     ba4:	d9 c0       	rjmp	.+434    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     ba6:	c0 c0       	rjmp	.+384    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
     ba8:	8c 30       	cpi	r24, 0x0C	; 12
     baa:	21 e0       	ldi	r18, 0x01	; 1
     bac:	92 07       	cpc	r25, r18
     bae:	21 e0       	ldi	r18, 0x01	; 1
     bb0:	a2 07       	cpc	r26, r18
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	b2 07       	cpc	r27, r18
     bb6:	98 f4       	brcc	.+38     	; 0xbde <ProcessRNDISControlMessage+0x26e>
     bb8:	8a 30       	cpi	r24, 0x0A	; 10
     bba:	61 e0       	ldi	r22, 0x01	; 1
     bbc:	96 07       	cpc	r25, r22
     bbe:	61 e0       	ldi	r22, 0x01	; 1
     bc0:	a6 07       	cpc	r26, r22
     bc2:	60 e0       	ldi	r22, 0x00	; 0
     bc4:	b6 07       	cpc	r27, r22
     bc6:	08 f0       	brcs	.+2      	; 0xbca <ProcessRNDISControlMessage+0x25a>
     bc8:	81 c0       	rjmp	.+258    	; 0xccc <ProcessRNDISControlMessage+0x35c>
     bca:	87 30       	cpi	r24, 0x07	; 7
     bcc:	e1 e0       	ldi	r30, 0x01	; 1
     bce:	9e 07       	cpc	r25, r30
     bd0:	e1 e0       	ldi	r30, 0x01	; 1
     bd2:	ae 07       	cpc	r26, r30
     bd4:	e0 e0       	ldi	r30, 0x00	; 0
     bd6:	be 07       	cpc	r27, r30
     bd8:	09 f0       	breq	.+2      	; 0xbdc <ProcessRNDISControlMessage+0x26c>
     bda:	be c0       	rjmp	.+380    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     bdc:	87 c0       	rjmp	.+270    	; 0xcec <ProcessRNDISControlMessage+0x37c>
     bde:	8c 30       	cpi	r24, 0x0C	; 12
     be0:	f1 e0       	ldi	r31, 0x01	; 1
     be2:	9f 07       	cpc	r25, r31
     be4:	f1 e0       	ldi	r31, 0x01	; 1
     be6:	af 07       	cpc	r26, r31
     be8:	f0 e0       	ldi	r31, 0x00	; 0
     bea:	bf 07       	cpc	r27, r31
     bec:	09 f4       	brne	.+2      	; 0xbf0 <ProcessRNDISControlMessage+0x280>
     bee:	69 c0       	rjmp	.+210    	; 0xcc2 <ProcessRNDISControlMessage+0x352>
     bf0:	8d 30       	cpi	r24, 0x0D	; 13
     bf2:	21 e0       	ldi	r18, 0x01	; 1
     bf4:	92 07       	cpc	r25, r18
     bf6:	21 e0       	ldi	r18, 0x01	; 1
     bf8:	a2 07       	cpc	r26, r18
     bfa:	20 e0       	ldi	r18, 0x00	; 0
     bfc:	b2 07       	cpc	r27, r18
     bfe:	09 f0       	breq	.+2      	; 0xc02 <ProcessRNDISControlMessage+0x292>
     c00:	ab c0       	rjmp	.+342    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     c02:	69 c0       	rjmp	.+210    	; 0xcd6 <ProcessRNDISControlMessage+0x366>
     c04:	86 30       	cpi	r24, 0x06	; 6
     c06:	61 e0       	ldi	r22, 0x01	; 1
     c08:	96 07       	cpc	r25, r22
     c0a:	62 e0       	ldi	r22, 0x02	; 2
     c0c:	a6 07       	cpc	r26, r22
     c0e:	60 e0       	ldi	r22, 0x00	; 0
     c10:	b6 07       	cpc	r27, r22
     c12:	28 f5       	brcc	.+74     	; 0xc5e <ProcessRNDISControlMessage+0x2ee>
     c14:	81 30       	cpi	r24, 0x01	; 1
     c16:	e1 e0       	ldi	r30, 0x01	; 1
     c18:	9e 07       	cpc	r25, r30
     c1a:	e2 e0       	ldi	r30, 0x02	; 2
     c1c:	ae 07       	cpc	r26, r30
     c1e:	e0 e0       	ldi	r30, 0x00	; 0
     c20:	be 07       	cpc	r27, r30
     c22:	08 f0       	brcs	.+2      	; 0xc26 <ProcessRNDISControlMessage+0x2b6>
     c24:	81 c0       	rjmp	.+258    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
     c26:	84 31       	cpi	r24, 0x14	; 20
     c28:	f1 e0       	ldi	r31, 0x01	; 1
     c2a:	9f 07       	cpc	r25, r31
     c2c:	f1 e0       	ldi	r31, 0x01	; 1
     c2e:	af 07       	cpc	r26, r31
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	bf 07       	cpc	r27, r31
     c34:	09 f4       	brne	.+2      	; 0xc38 <ProcessRNDISControlMessage+0x2c8>
     c36:	78 c0       	rjmp	.+240    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
     c38:	82 30       	cpi	r24, 0x02	; 2
     c3a:	22 e0       	ldi	r18, 0x02	; 2
     c3c:	92 07       	cpc	r25, r18
     c3e:	21 e0       	ldi	r18, 0x01	; 1
     c40:	a2 07       	cpc	r26, r18
     c42:	20 e0       	ldi	r18, 0x00	; 0
     c44:	b2 07       	cpc	r27, r18
     c46:	09 f4       	brne	.+2      	; 0xc4a <ProcessRNDISControlMessage+0x2da>
     c48:	6f c0       	rjmp	.+222    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
     c4a:	81 31       	cpi	r24, 0x11	; 17
     c4c:	61 e0       	ldi	r22, 0x01	; 1
     c4e:	96 07       	cpc	r25, r22
     c50:	61 e0       	ldi	r22, 0x01	; 1
     c52:	a6 07       	cpc	r26, r22
     c54:	60 e0       	ldi	r22, 0x00	; 0
     c56:	b6 07       	cpc	r27, r22
     c58:	09 f0       	breq	.+2      	; 0xc5c <ProcessRNDISControlMessage+0x2ec>
     c5a:	7e c0       	rjmp	.+252    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     c5c:	6e c0       	rjmp	.+220    	; 0xd3a <ProcessRNDISControlMessage+0x3ca>
     c5e:	84 30       	cpi	r24, 0x04	; 4
     c60:	e1 e0       	ldi	r30, 0x01	; 1
     c62:	9e 07       	cpc	r25, r30
     c64:	e1 e0       	ldi	r30, 0x01	; 1
     c66:	ae 07       	cpc	r26, r30
     c68:	e1 e0       	ldi	r30, 0x01	; 1
     c6a:	be 07       	cpc	r27, r30
     c6c:	09 f4       	brne	.+2      	; 0xc70 <ProcessRNDISControlMessage+0x300>
     c6e:	4e c0       	rjmp	.+156    	; 0xd0c <ProcessRNDISControlMessage+0x39c>
     c70:	85 30       	cpi	r24, 0x05	; 5
     c72:	f1 e0       	ldi	r31, 0x01	; 1
     c74:	9f 07       	cpc	r25, r31
     c76:	f1 e0       	ldi	r31, 0x01	; 1
     c78:	af 07       	cpc	r26, r31
     c7a:	f1 e0       	ldi	r31, 0x01	; 1
     c7c:	bf 07       	cpc	r27, r31
     c7e:	58 f4       	brcc	.+22     	; 0xc96 <ProcessRNDISControlMessage+0x326>
     c80:	81 50       	subi	r24, 0x01	; 1
     c82:	91 40       	sbci	r25, 0x01	; 1
     c84:	a1 40       	sbci	r26, 0x01	; 1
     c86:	b1 40       	sbci	r27, 0x01	; 1
     c88:	82 30       	cpi	r24, 0x02	; 2
     c8a:	91 05       	cpc	r25, r1
     c8c:	a1 05       	cpc	r26, r1
     c8e:	b1 05       	cpc	r27, r1
     c90:	08 f0       	brcs	.+2      	; 0xc94 <ProcessRNDISControlMessage+0x324>
     c92:	62 c0       	rjmp	.+196    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     c94:	30 c0       	rjmp	.+96     	; 0xcf6 <ProcessRNDISControlMessage+0x386>
     c96:	81 50       	subi	r24, 0x01	; 1
     c98:	91 40       	sbci	r25, 0x01	; 1
     c9a:	a2 40       	sbci	r26, 0x02	; 2
     c9c:	b1 40       	sbci	r27, 0x01	; 1
     c9e:	83 30       	cpi	r24, 0x03	; 3
     ca0:	91 05       	cpc	r25, r1
     ca2:	a1 05       	cpc	r26, r1
     ca4:	b1 05       	cpc	r27, r1
     ca6:	08 f0       	brcs	.+2      	; 0xcaa <ProcessRNDISControlMessage+0x33a>
     ca8:	57 c0       	rjmp	.+174    	; 0xd58 <ProcessRNDISControlMessage+0x3e8>
     caa:	3e c0       	rjmp	.+124    	; 0xd28 <ProcessRNDISControlMessage+0x3b8>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
     cac:	81 e2       	ldi	r24, 0x21	; 33
     cae:	9d e0       	ldi	r25, 0x0D	; 13
     cb0:	60 e3       	ldi	r22, 0x30	; 48
     cb2:	71 e0       	ldi	r23, 0x01	; 1
     cb4:	4c e6       	ldi	r20, 0x6C	; 108
     cb6:	50 e0       	ldi	r21, 0x00	; 0
     cb8:	0e 94 99 15 	call	0x2b32	; 0x2b32 <memcpy_P>
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
     cbc:	2c e6       	ldi	r18, 0x6C	; 108
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	00 c1       	rjmp	.+512    	; 0xec2 <ProcessRNDISControlMessage+0x552>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
     cc2:	8f ef       	ldi	r24, 0xFF	; 255
     cc4:	9f ef       	ldi	r25, 0xFF	; 255
     cc6:	af ef       	ldi	r26, 0xFF	; 255
     cc8:	b0 e0       	ldi	r27, 0x00	; 0
     cca:	3b c0       	rjmp	.+118    	; 0xd42 <ProcessRNDISControlMessage+0x3d2>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
     ccc:	8c ed       	ldi	r24, 0xDC	; 220
     cce:	95 e0       	ldi	r25, 0x05	; 5
     cd0:	a0 e0       	ldi	r26, 0x00	; 0
     cd2:	b0 e0       	ldi	r27, 0x00	; 0
     cd4:	36 c0       	rjmp	.+108    	; 0xd42 <ProcessRNDISControlMessage+0x3d2>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
     cd6:	81 e2       	ldi	r24, 0x21	; 33
     cd8:	9d e0       	ldi	r25, 0x0D	; 13
     cda:	6c e9       	ldi	r22, 0x9C	; 156
     cdc:	71 e0       	ldi	r23, 0x01	; 1
     cde:	43 e1       	ldi	r20, 0x13	; 19
     ce0:	50 e0       	ldi	r21, 0x00	; 0
     ce2:	0e 94 99 15 	call	0x2b32	; 0x2b32 <memcpy_P>
			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);
     ce6:	23 e1       	ldi	r18, 0x13	; 19
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	eb c0       	rjmp	.+470    	; 0xec2 <ProcessRNDISControlMessage+0x552>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
     cec:	80 ea       	ldi	r24, 0xA0	; 160
     cee:	96 e8       	ldi	r25, 0x86	; 134
     cf0:	a1 e0       	ldi	r26, 0x01	; 1
     cf2:	b0 e0       	ldi	r27, 0x00	; 0
     cf4:	26 c0       	rjmp	.+76     	; 0xd42 <ProcessRNDISControlMessage+0x3d2>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
     cf6:	81 e2       	ldi	r24, 0x21	; 33
     cf8:	9d e0       	ldi	r25, 0x0D	; 13
     cfa:	6f ea       	ldi	r22, 0xAF	; 175
     cfc:	71 e0       	ldi	r23, 0x01	; 1
     cfe:	46 e0       	ldi	r20, 0x06	; 6
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	0e 94 99 15 	call	0x2b32	; 0x2b32 <memcpy_P>
			*((uint32_t*)ResponseData) = 100000;

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
     d06:	26 e0       	ldi	r18, 0x06	; 6
     d08:	30 e0       	ldi	r19, 0x00	; 0
     d0a:	db c0       	rjmp	.+438    	; 0xec2 <ProcessRNDISControlMessage+0x552>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	a0 e0       	ldi	r26, 0x00	; 0
     d12:	b0 e0       	ldi	r27, 0x00	; 0
     d14:	16 c0       	rjmp	.+44     	; 0xd42 <ProcessRNDISControlMessage+0x3d2>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
     d16:	80 91 48 01 	lds	r24, 0x0148
     d1a:	90 91 49 01 	lds	r25, 0x0149
     d1e:	a0 91 4a 01 	lds	r26, 0x014A
     d22:	b0 91 4b 01 	lds	r27, 0x014B
     d26:	0d c0       	rjmp	.+26     	; 0xd42 <ProcessRNDISControlMessage+0x3d2>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
     d28:	10 92 21 0d 	sts	0x0D21, r1
     d2c:	10 92 22 0d 	sts	0x0D22, r1
     d30:	10 92 23 0d 	sts	0x0D23, r1
     d34:	10 92 24 0d 	sts	0x0D24, r1
     d38:	0c c0       	rjmp	.+24     	; 0xd52 <ProcessRNDISControlMessage+0x3e2>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
     d3a:	80 e6       	ldi	r24, 0x60	; 96
     d3c:	96 e0       	ldi	r25, 0x06	; 6
     d3e:	a0 e0       	ldi	r26, 0x00	; 0
     d40:	b0 e0       	ldi	r27, 0x00	; 0
     d42:	80 93 21 0d 	sts	0x0D21, r24
     d46:	90 93 22 0d 	sts	0x0D22, r25
     d4a:	a0 93 23 0d 	sts	0x0D23, r26
     d4e:	b0 93 24 0d 	sts	0x0D24, r27
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
     d52:	24 e0       	ldi	r18, 0x04	; 4
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	b5 c0       	rjmp	.+362    	; 0xec2 <ProcessRNDISControlMessage+0x552>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     d58:	8b eb       	ldi	r24, 0xBB	; 187
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	a0 e0       	ldi	r26, 0x00	; 0
     d5e:	b0 ec       	ldi	r27, 0xC0	; 192
     d60:	80 93 15 0d 	sts	0x0D15, r24
     d64:	90 93 16 0d 	sts	0x0D16, r25
     d68:	a0 93 17 0d 	sts	0x0D17, r26
     d6c:	b0 93 18 0d 	sts	0x0D18, r27

				QUERY_Response->InformationBufferLength = 0;
     d70:	10 92 19 0d 	sts	0x0D19, r1
     d74:	10 92 1a 0d 	sts	0x0D1A, r1
     d78:	10 92 1b 0d 	sts	0x0D1B, r1
     d7c:	10 92 1c 0d 	sts	0x0D1C, r1
				QUERY_Response->InformationBufferOffset = 0;
     d80:	10 92 1d 0d 	sts	0x0D1D, r1
     d84:	10 92 1e 0d 	sts	0x0D1E, r1
     d88:	10 92 1f 0d 	sts	0x0D1F, r1
     d8c:	10 92 20 0d 	sts	0x0D20, r1
     d90:	08 95       	ret

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	80 93 46 01 	sts	0x0146, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
     d98:	80 91 15 0d 	lds	r24, 0x0D15
     d9c:	90 91 16 0d 	lds	r25, 0x0D16
     da0:	a0 91 17 0d 	lds	r26, 0x0D17
     da4:	b0 91 18 0d 	lds	r27, 0x0D18

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
     da8:	25 e0       	ldi	r18, 0x05	; 5
     daa:	30 e0       	ldi	r19, 0x00	; 0
     dac:	40 e0       	ldi	r20, 0x00	; 0
     dae:	50 e8       	ldi	r21, 0x80	; 128
     db0:	20 93 09 0d 	sts	0x0D09, r18
     db4:	30 93 0a 0d 	sts	0x0D0A, r19
     db8:	40 93 0b 0d 	sts	0x0D0B, r20
     dbc:	50 93 0c 0d 	sts	0x0D0C, r21
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
     dc0:	20 e1       	ldi	r18, 0x10	; 16
     dc2:	30 e0       	ldi	r19, 0x00	; 0
     dc4:	40 e0       	ldi	r20, 0x00	; 0
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	20 93 0d 0d 	sts	0x0D0D, r18
     dcc:	30 93 0e 0d 	sts	0x0D0E, r19
     dd0:	40 93 0f 0d 	sts	0x0D0F, r20
     dd4:	50 93 10 0d 	sts	0x0D10, r21
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
     dd8:	20 91 1d 0d 	lds	r18, 0x0D1D
     ddc:	30 91 1e 0d 	lds	r19, 0x0D1E
     de0:	40 91 1f 0d 	lds	r20, 0x0D1F
     de4:	50 91 20 0d 	lds	r21, 0x0D20
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
     de8:	8e 30       	cpi	r24, 0x0E	; 14
     dea:	61 e0       	ldi	r22, 0x01	; 1
     dec:	96 07       	cpc	r25, r22
     dee:	61 e0       	ldi	r22, 0x01	; 1
     df0:	a6 07       	cpc	r26, r22
     df2:	60 e0       	ldi	r22, 0x00	; 0
     df4:	b6 07       	cpc	r27, r22
     df6:	51 f0       	breq	.+20     	; 0xe0c <ProcessRNDISControlMessage+0x49c>
     df8:	83 30       	cpi	r24, 0x03	; 3
     dfa:	e1 e0       	ldi	r30, 0x01	; 1
     dfc:	9e 07       	cpc	r25, r30
     dfe:	e1 e0       	ldi	r30, 0x01	; 1
     e00:	ae 07       	cpc	r26, r30
     e02:	e1 e0       	ldi	r30, 0x01	; 1
     e04:	be 07       	cpc	r27, r30
     e06:	09 f0       	breq	.+2      	; 0xe0a <ProcessRNDISControlMessage+0x49a>
     e08:	8f c0       	rjmp	.+286    	; 0xf28 <ProcessRNDISControlMessage+0x5b8>
     e0a:	52 c0       	rjmp	.+164    	; 0xeb0 <ProcessRNDISControlMessage+0x540>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
     e0c:	2f 5e       	subi	r18, 0xEF	; 239
     e0e:	32 4f       	sbci	r19, 0xF2	; 242
     e10:	f9 01       	movw	r30, r18
     e12:	80 81       	ld	r24, Z
     e14:	91 81       	ldd	r25, Z+1	; 0x01
     e16:	a2 81       	ldd	r26, Z+2	; 0x02
     e18:	b3 81       	ldd	r27, Z+3	; 0x03
     e1a:	80 93 48 01 	sts	0x0148, r24
     e1e:	90 93 49 01 	sts	0x0149, r25
     e22:	a0 93 4a 01 	sts	0x014A, r26
     e26:	b0 93 4b 01 	sts	0x014B, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
     e2a:	82 e0       	ldi	r24, 0x02	; 2
     e2c:	80 93 47 01 	sts	0x0147, r24
     e30:	3f c0       	rjmp	.+126    	; 0xeb0 <ProcessRNDISControlMessage+0x540>

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	80 93 46 01 	sts	0x0146, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
     e38:	86 e0       	ldi	r24, 0x06	; 6
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	a0 e0       	ldi	r26, 0x00	; 0
     e3e:	b0 e8       	ldi	r27, 0x80	; 128
     e40:	80 93 09 0d 	sts	0x0D09, r24
     e44:	90 93 0a 0d 	sts	0x0D0A, r25
     e48:	a0 93 0b 0d 	sts	0x0D0B, r26
     e4c:	b0 93 0c 0d 	sts	0x0D0C, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
     e50:	80 e1       	ldi	r24, 0x10	; 16
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	a0 e0       	ldi	r26, 0x00	; 0
     e56:	b0 e0       	ldi	r27, 0x00	; 0
     e58:	80 93 0d 0d 	sts	0x0D0D, r24
     e5c:	90 93 0e 0d 	sts	0x0D0E, r25
     e60:	a0 93 0f 0d 	sts	0x0D0F, r26
     e64:	b0 93 10 0d 	sts	0x0D10, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
     e68:	10 92 11 0d 	sts	0x0D11, r1
     e6c:	10 92 12 0d 	sts	0x0D12, r1
     e70:	10 92 13 0d 	sts	0x0D13, r1
     e74:	10 92 14 0d 	sts	0x0D14, r1
     e78:	1b c0       	rjmp	.+54     	; 0xeb0 <ProcessRNDISControlMessage+0x540>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
     e7a:	81 e0       	ldi	r24, 0x01	; 1
     e7c:	80 93 46 01 	sts	0x0146, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
     e80:	88 e0       	ldi	r24, 0x08	; 8
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	a0 e0       	ldi	r26, 0x00	; 0
     e86:	b0 e8       	ldi	r27, 0x80	; 128
     e88:	80 93 09 0d 	sts	0x0D09, r24
     e8c:	90 93 0a 0d 	sts	0x0D0A, r25
     e90:	a0 93 0b 0d 	sts	0x0D0B, r26
     e94:	b0 93 0c 0d 	sts	0x0D0C, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	90 e0       	ldi	r25, 0x00	; 0
     e9c:	a0 e0       	ldi	r26, 0x00	; 0
     e9e:	b0 e0       	ldi	r27, 0x00	; 0
     ea0:	80 93 0d 0d 	sts	0x0D0D, r24
     ea4:	90 93 0e 0d 	sts	0x0D0E, r25
     ea8:	a0 93 0f 0d 	sts	0x0D0F, r26
     eac:	b0 93 10 0d 	sts	0x0D10, r27
			KEEPALIVE_Response->RequestId       = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
     eb0:	10 92 15 0d 	sts	0x0D15, r1
     eb4:	10 92 16 0d 	sts	0x0D16, r1
     eb8:	10 92 17 0d 	sts	0x0D17, r1
     ebc:	10 92 18 0d 	sts	0x0D18, r1

			break;
     ec0:	08 95       	ret
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
     ec2:	10 92 15 0d 	sts	0x0D15, r1
     ec6:	10 92 16 0d 	sts	0x0D16, r1
     eca:	10 92 17 0d 	sts	0x0D17, r1
     ece:	10 92 18 0d 	sts	0x0D18, r1
				QUERY_Response->MessageLength          += ResponseSize;
     ed2:	40 e0       	ldi	r20, 0x00	; 0
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	80 91 0d 0d 	lds	r24, 0x0D0D
     eda:	90 91 0e 0d 	lds	r25, 0x0D0E
     ede:	a0 91 0f 0d 	lds	r26, 0x0D0F
     ee2:	b0 91 10 0d 	lds	r27, 0x0D10
     ee6:	82 0f       	add	r24, r18
     ee8:	93 1f       	adc	r25, r19
     eea:	a4 1f       	adc	r26, r20
     eec:	b5 1f       	adc	r27, r21
     eee:	80 93 0d 0d 	sts	0x0D0D, r24
     ef2:	90 93 0e 0d 	sts	0x0D0E, r25
     ef6:	a0 93 0f 0d 	sts	0x0D0F, r26
     efa:	b0 93 10 0d 	sts	0x0D10, r27

				QUERY_Response->InformationBufferLength = ResponseSize;
     efe:	20 93 19 0d 	sts	0x0D19, r18
     f02:	30 93 1a 0d 	sts	0x0D1A, r19
     f06:	40 93 1b 0d 	sts	0x0D1B, r20
     f0a:	50 93 1c 0d 	sts	0x0D1C, r21
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	a0 e0       	ldi	r26, 0x00	; 0
     f14:	b0 e0       	ldi	r27, 0x00	; 0
     f16:	80 93 1d 0d 	sts	0x0D1D, r24
     f1a:	90 93 1e 0d 	sts	0x0D1E, r25
     f1e:	a0 93 1f 0d 	sts	0x0D1F, r26
     f22:	b0 93 20 0d 	sts	0x0D20, r27
     f26:	08 95       	ret
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
     f28:	8b eb       	ldi	r24, 0xBB	; 187
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	a0 e0       	ldi	r26, 0x00	; 0
     f2e:	b0 ec       	ldi	r27, 0xC0	; 192
     f30:	80 93 15 0d 	sts	0x0D15, r24
     f34:	90 93 16 0d 	sts	0x0D16, r25
     f38:	a0 93 17 0d 	sts	0x0D17, r26
     f3c:	b0 93 18 0d 	sts	0x0D18, r27
     f40:	08 95       	ret

00000f42 <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     f42:	ef 92       	push	r14
     f44:	ff 92       	push	r15
     f46:	0f 93       	push	r16
     f48:	1f 93       	push	r17
     f4a:	cf 93       	push	r28
     f4c:	df 93       	push	r29
     f4e:	ec 01       	movw	r28, r24
     f50:	8b 01       	movw	r16, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     f52:	0a dd       	rcall	.-1516   	; 0x968 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     f54:	88 81       	ld	r24, Y
     f56:	88 30       	cpi	r24, 0x08	; 8
     f58:	41 f5       	brne	.+80     	; 0xfaa <ICMP_ProcessICMPPacket+0x68>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     f5a:	f8 01       	movw	r30, r16
     f5c:	10 82       	st	Z, r1
		ICMPHeaderOUT->Code     = 0;
     f5e:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     f60:	13 82       	std	Z+3, r1	; 0x03
     f62:	12 82       	std	Z+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     f64:	8c 81       	ldd	r24, Y+4	; 0x04
     f66:	9d 81       	ldd	r25, Y+5	; 0x05
     f68:	95 83       	std	Z+5, r25	; 0x05
     f6a:	84 83       	std	Z+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     f6c:	8e 81       	ldd	r24, Y+6	; 0x06
     f6e:	9f 81       	ldd	r25, Y+7	; 0x07
     f70:	97 83       	std	Z+7, r25	; 0x07
     f72:	86 83       	std	Z+6, r24	; 0x06

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     f74:	e0 90 29 07 	lds	r14, 0x0729
     f78:	f0 90 2a 07 	lds	r15, 0x072A
     f7c:	25 e4       	ldi	r18, 0x45	; 69
     f7e:	31 e0       	ldi	r19, 0x01	; 1
     f80:	e2 0e       	add	r14, r18
     f82:	f3 1e       	adc	r15, r19
     f84:	ec 1a       	sub	r14, r28
     f86:	fd 0a       	sbc	r15, r29

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     f88:	be 01       	movw	r22, r28
     f8a:	68 5f       	subi	r22, 0xF8	; 248
     f8c:	7f 4f       	sbci	r23, 0xFF	; 255
     f8e:	c8 01       	movw	r24, r16
     f90:	08 96       	adiw	r24, 0x08	; 8
     f92:	a7 01       	movw	r20, r14
     f94:	0e 94 d7 15 	call	0x2bae	; 0x2bae <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     f98:	e7 01       	movw	r28, r14
     f9a:	28 96       	adiw	r28, 0x08	; 8
     f9c:	c8 01       	movw	r24, r16
     f9e:	be 01       	movw	r22, r28
     fa0:	ab dc       	rcall	.-1706   	; 0x8f8 <Ethernet_Checksum16>
     fa2:	f8 01       	movw	r30, r16
     fa4:	93 83       	std	Z+3, r25	; 0x03
     fa6:	82 83       	std	Z+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     fa8:	02 c0       	rjmp	.+4      	; 0xfae <ICMP_ProcessICMPPacket+0x6c>
	}

	return NO_RESPONSE;
     faa:	c0 e0       	ldi	r28, 0x00	; 0
     fac:	d0 e0       	ldi	r29, 0x00	; 0
}
     fae:	ce 01       	movw	r24, r28
     fb0:	df 91       	pop	r29
     fb2:	cf 91       	pop	r28
     fb4:	1f 91       	pop	r17
     fb6:	0f 91       	pop	r16
     fb8:	ff 90       	pop	r15
     fba:	ef 90       	pop	r14
     fbc:	08 95       	ret

00000fbe <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     fbe:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     fc0:	69 2f       	mov	r22, r25
     fc2:	78 2f       	mov	r23, r24
     fc4:	83 2f       	mov	r24, r19
     fc6:	92 2f       	mov	r25, r18
     fc8:	08 95       	ret

00000fca <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     fca:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     fcc:	89 2f       	mov	r24, r25
     fce:	92 2f       	mov	r25, r18
     fd0:	08 95       	ret

00000fd2 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     fd2:	af 92       	push	r10
     fd4:	bf 92       	push	r11
     fd6:	cf 92       	push	r12
     fd8:	df 92       	push	r13
     fda:	ef 92       	push	r14
     fdc:	ff 92       	push	r15
     fde:	0f 93       	push	r16
     fe0:	1f 93       	push	r17
     fe2:	cf 93       	push	r28
     fe4:	df 93       	push	r29
     fe6:	5c 01       	movw	r10, r24
     fe8:	69 01       	movw	r12, r18
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     fea:	e6 2e       	mov	r14, r22
     fec:	e7 01       	movw	r28, r14
     fee:	7e 01       	movw	r14, r28
     ff0:	f7 2e       	mov	r15, r23
     ff2:	e7 01       	movw	r28, r14
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
     ff4:	fa 01       	movw	r30, r20

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     ff6:	ea 80       	ldd	r14, Y+2	; 0x02
     ff8:	fb 80       	ldd	r15, Y+3	; 0x03
     ffa:	00 e0       	ldi	r16, 0x00	; 0
     ffc:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)DestinationAddress)[0];
     ffe:	80 81       	ld	r24, Z
    1000:	91 81       	ldd	r25, Z+1	; 0x01
    1002:	a0 e0       	ldi	r26, 0x00	; 0
    1004:	b0 e0       	ldi	r27, 0x00	; 0

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
    1006:	e8 0e       	add	r14, r24
    1008:	f9 1e       	adc	r15, r25
    100a:	0a 1f       	adc	r16, r26
    100c:	1b 1f       	adc	r17, r27
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
    100e:	88 81       	ld	r24, Y
    1010:	99 81       	ldd	r25, Y+1	; 0x01
    1012:	a0 e0       	ldi	r26, 0x00	; 0
    1014:	b0 e0       	ldi	r27, 0x00	; 0
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
    1016:	e8 0e       	add	r14, r24
    1018:	f9 1e       	adc	r15, r25
    101a:	0a 1f       	adc	r16, r26
    101c:	1b 1f       	adc	r17, r27
	Checksum += ((uint16_t*)DestinationAddress)[1];
    101e:	82 81       	ldd	r24, Z+2	; 0x02
    1020:	93 81       	ldd	r25, Z+3	; 0x03
    1022:	a0 e0       	ldi	r26, 0x00	; 0
    1024:	b0 e0       	ldi	r27, 0x00	; 0
    1026:	e8 0e       	add	r14, r24
    1028:	f9 1e       	adc	r15, r25
    102a:	0a 1f       	adc	r16, r26
    102c:	1b 1f       	adc	r17, r27
	Checksum += SwapEndian_16(PROTOCOL_TCP);
    102e:	86 e0       	ldi	r24, 0x06	; 6
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	cb df       	rcall	.-106    	; 0xfca <SwapEndian_16>
    1034:	a0 e0       	ldi	r26, 0x00	; 0
    1036:	b0 e0       	ldi	r27, 0x00	; 0
    1038:	e8 0e       	add	r14, r24
    103a:	f9 1e       	adc	r15, r25
    103c:	0a 1f       	adc	r16, r26
    103e:	1b 1f       	adc	r17, r27
	Checksum += SwapEndian_16(TCPOutSize);
    1040:	c6 01       	movw	r24, r12
    1042:	c3 df       	rcall	.-122    	; 0xfca <SwapEndian_16>
    1044:	a0 e0       	ldi	r26, 0x00	; 0
    1046:	b0 e0       	ldi	r27, 0x00	; 0
    1048:	8e 0d       	add	r24, r14
    104a:	9f 1d       	adc	r25, r15
    104c:	a0 1f       	adc	r26, r16
    104e:	b1 1f       	adc	r27, r17

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
    1050:	f6 01       	movw	r30, r12
    1052:	f6 95       	lsr	r31
    1054:	e7 95       	ror	r30
    1056:	e5 01       	movw	r28, r10
    1058:	60 e0       	ldi	r22, 0x00	; 0
    105a:	70 e0       	ldi	r23, 0x00	; 0
    105c:	0a c0       	rjmp	.+20     	; 0x1072 <TCP_Checksum16+0xa0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
    105e:	29 91       	ld	r18, Y+
    1060:	39 91       	ld	r19, Y+
    1062:	40 e0       	ldi	r20, 0x00	; 0
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	82 0f       	add	r24, r18
    1068:	93 1f       	adc	r25, r19
    106a:	a4 1f       	adc	r26, r20
    106c:	b5 1f       	adc	r27, r21
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
    106e:	6f 5f       	subi	r22, 0xFF	; 255
    1070:	7f 4f       	sbci	r23, 0xFF	; 255
    1072:	6e 17       	cp	r22, r30
    1074:	7f 07       	cpc	r23, r31
    1076:	98 f3       	brcs	.-26     	; 0x105e <TCP_Checksum16+0x8c>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
    1078:	c0 fe       	sbrs	r12, 0
    107a:	15 c0       	rjmp	.+42     	; 0x10a6 <TCP_Checksum16+0xd4>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
    107c:	ee 0f       	add	r30, r30
    107e:	ff 1f       	adc	r31, r31
    1080:	ea 0d       	add	r30, r10
    1082:	fb 1d       	adc	r31, r11
    1084:	20 81       	ld	r18, Z
    1086:	82 0f       	add	r24, r18
    1088:	91 1d       	adc	r25, r1
    108a:	a1 1d       	adc	r26, r1
    108c:	b1 1d       	adc	r27, r1
    108e:	0b c0       	rjmp	.+22     	; 0x10a6 <TCP_Checksum16+0xd4>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
    1090:	9c 01       	movw	r18, r24
    1092:	ad 01       	movw	r20, r26
    1094:	40 70       	andi	r20, 0x00	; 0
    1096:	50 70       	andi	r21, 0x00	; 0
    1098:	cd 01       	movw	r24, r26
    109a:	aa 27       	eor	r26, r26
    109c:	bb 27       	eor	r27, r27
    109e:	82 0f       	add	r24, r18
    10a0:	93 1f       	adc	r25, r19
    10a2:	a4 1f       	adc	r26, r20
    10a4:	b5 1f       	adc	r27, r21
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
    10a6:	9c 01       	movw	r18, r24
    10a8:	ad 01       	movw	r20, r26
    10aa:	20 70       	andi	r18, 0x00	; 0
    10ac:	30 70       	andi	r19, 0x00	; 0
    10ae:	21 15       	cp	r18, r1
    10b0:	31 05       	cpc	r19, r1
    10b2:	41 05       	cpc	r20, r1
    10b4:	51 05       	cpc	r21, r1
    10b6:	61 f7       	brne	.-40     	; 0x1090 <TCP_Checksum16+0xbe>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
    10b8:	9c 01       	movw	r18, r24
    10ba:	20 95       	com	r18
    10bc:	30 95       	com	r19
}
    10be:	c9 01       	movw	r24, r18
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	bf 90       	pop	r11
    10d2:	af 90       	pop	r10
    10d4:	08 95       	ret

000010d6 <TCP_Task>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    10d6:	2f 92       	push	r2
    10d8:	3f 92       	push	r3
    10da:	4f 92       	push	r4
    10dc:	5f 92       	push	r5
    10de:	6f 92       	push	r6
    10e0:	7f 92       	push	r7
    10e2:	8f 92       	push	r8
    10e4:	9f 92       	push	r9
    10e6:	af 92       	push	r10
    10e8:	bf 92       	push	r11
    10ea:	cf 92       	push	r12
    10ec:	df 92       	push	r13
    10ee:	ef 92       	push	r14
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	df 93       	push	r29
    10f8:	cf 93       	push	r28
    10fa:	0f 92       	push	r0
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    1100:	0d e8       	ldi	r16, 0x8D	; 141
    1102:	1d e0       	ldi	r17, 0x0D	; 13
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    1104:	cc 24       	eor	r12, r12
    1106:	dd 24       	eor	r13, r13
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1108:	26 e1       	ldi	r18, 0x16	; 22
    110a:	e2 2e       	mov	r14, r18
    110c:	22 e0       	ldi	r18, 0x02	; 2
    110e:	f2 2e       	mov	r15, r18
    1110:	1e c0       	rjmp	.+60     	; 0x114e <TCP_Task+0x78>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1112:	80 91 d1 13 	lds	r24, 0x13D1
    1116:	81 30       	cpi	r24, 0x01	; 1
    1118:	89 f4       	brne	.+34     	; 0x113c <TCP_Task+0x66>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    111a:	ce 9c       	mul	r12, r14
    111c:	c0 01       	movw	r24, r0
    111e:	cf 9c       	mul	r12, r15
    1120:	90 0d       	add	r25, r0
    1122:	de 9c       	mul	r13, r14
    1124:	90 0d       	add	r25, r0
    1126:	11 24       	eor	r1, r1
    1128:	bc 01       	movw	r22, r24
    112a:	63 56       	subi	r22, 0x63	; 99
    112c:	72 4f       	sbci	r23, 0xF2	; 242
    112e:	e0 91 d2 13 	lds	r30, 0x13D2
    1132:	f0 91 d3 13 	lds	r31, 0x13D3
    1136:	83 57       	subi	r24, 0x73	; 115
    1138:	92 4f       	sbci	r25, 0xF2	; 242
    113a:	09 95       	icall
    113c:	08 94       	sec
    113e:	c1 1c       	adc	r12, r1
    1140:	d1 1c       	adc	r13, r1
    1142:	0a 5e       	subi	r16, 0xEA	; 234
    1144:	1d 4f       	sbci	r17, 0xFD	; 253
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1146:	83 e0       	ldi	r24, 0x03	; 3
    1148:	c8 16       	cp	r12, r24
    114a:	d1 04       	cpc	r13, r1
    114c:	59 f0       	breq	.+22     	; 0x1164 <TCP_Task+0x8e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    114e:	20 91 cf 13 	lds	r18, 0x13CF
    1152:	30 91 d0 13 	lds	r19, 0x13D0
    1156:	f8 01       	movw	r30, r16
    1158:	80 81       	ld	r24, Z
    115a:	91 81       	ldd	r25, Z+1	; 0x01
    115c:	28 17       	cp	r18, r24
    115e:	39 07       	cpc	r19, r25
    1160:	69 f7       	brne	.-38     	; 0x113c <TCP_Task+0x66>
    1162:	d7 cf       	rjmp	.-82     	; 0x1112 <TCP_Task+0x3c>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    1164:	80 91 07 0d 	lds	r24, 0x0D07
    1168:	90 91 08 0d 	lds	r25, 0x0D08
    116c:	00 97       	sbiw	r24, 0x00	; 0
    116e:	09 f0       	breq	.+2      	; 0x1172 <TCP_Task+0x9c>
    1170:	e9 c0       	rjmp	.+466    	; 0x1344 <TCP_Task+0x26e>
    1172:	ef e9       	ldi	r30, 0x9F	; 159
    1174:	ff e0       	ldi	r31, 0x0F	; 15
    1176:	cc 24       	eor	r12, r12
    1178:	dd 24       	eor	r13, r13

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    117a:	80 81       	ld	r24, Z
    117c:	88 23       	and	r24, r24
    117e:	09 f4       	brne	.+2      	; 0x1182 <TCP_Task+0xac>
    1180:	d7 c0       	rjmp	.+430    	; 0x1330 <TCP_Task+0x25a>
    1182:	81 81       	ldd	r24, Z+1	; 0x01
    1184:	88 23       	and	r24, r24
    1186:	09 f4       	brne	.+2      	; 0x118a <TCP_Task+0xb4>
    1188:	d3 c0       	rjmp	.+422    	; 0x1330 <TCP_Task+0x25a>
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
    118a:	99 e3       	ldi	r25, 0x39	; 57
    118c:	29 2e       	mov	r2, r25
    118e:	97 e0       	ldi	r25, 0x07	; 7
    1190:	39 2e       	mov	r3, r25
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
    1192:	81 01       	movw	r16, r2
    1194:	0c 5e       	subi	r16, 0xEC	; 236
    1196:	1f 4f       	sbci	r17, 0xFF	; 255
			                                                                             sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    1198:	86 e1       	ldi	r24, 0x16	; 22
    119a:	92 e0       	ldi	r25, 0x02	; 2
    119c:	c8 9e       	mul	r12, r24
    119e:	40 01       	movw	r8, r0
    11a0:	c9 9e       	mul	r12, r25
    11a2:	90 0c       	add	r9, r0
    11a4:	d8 9e       	mul	r13, r24
    11a6:	90 0c       	add	r9, r0
    11a8:	11 24       	eor	r1, r1
    11aa:	8d e8       	ldi	r24, 0x8D	; 141
    11ac:	e8 2e       	mov	r14, r24
    11ae:	8d e0       	ldi	r24, 0x0D	; 13
    11b0:	f8 2e       	mov	r15, r24
    11b2:	e8 0c       	add	r14, r8
    11b4:	f9 1c       	adc	r15, r9
    11b6:	f7 01       	movw	r30, r14
    11b8:	a0 88       	ldd	r10, Z+16	; 0x10
    11ba:	b1 88       	ldd	r11, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    11bc:	80 81       	ld	r24, Z
    11be:	91 81       	ldd	r25, Z+1	; 0x01
    11c0:	90 93 4e 07 	sts	0x074E, r25
    11c4:	80 93 4d 07 	sts	0x074D, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    11c8:	82 81       	ldd	r24, Z+2	; 0x02
    11ca:	93 81       	ldd	r25, Z+3	; 0x03
    11cc:	f8 01       	movw	r30, r16
    11ce:	93 83       	std	Z+3, r25	; 0x03
    11d0:	82 83       	std	Z+2, r24	; 0x02
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    11d2:	f7 01       	movw	r30, r14
    11d4:	44 84       	ldd	r4, Z+12	; 0x0c
    11d6:	55 84       	ldd	r5, Z+13	; 0x0d
    11d8:	66 84       	ldd	r6, Z+14	; 0x0e
    11da:	77 84       	ldd	r7, Z+15	; 0x0f
    11dc:	c3 01       	movw	r24, r6
    11de:	b2 01       	movw	r22, r4
    11e0:	ee de       	rcall	.-548    	; 0xfbe <SwapEndian_32>
    11e2:	f8 01       	movw	r30, r16
    11e4:	64 83       	std	Z+4, r22	; 0x04
    11e6:	75 83       	std	Z+5, r23	; 0x05
    11e8:	86 83       	std	Z+6, r24	; 0x06
    11ea:	97 83       	std	Z+7, r25	; 0x07
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    11ec:	f7 01       	movw	r30, r14
    11ee:	60 85       	ldd	r22, Z+8	; 0x08
    11f0:	71 85       	ldd	r23, Z+9	; 0x09
    11f2:	82 85       	ldd	r24, Z+10	; 0x0a
    11f4:	93 85       	ldd	r25, Z+11	; 0x0b
    11f6:	e3 de       	rcall	.-570    	; 0xfbe <SwapEndian_32>
    11f8:	f8 01       	movw	r30, r16
    11fa:	60 87       	std	Z+8, r22	; 0x08
    11fc:	71 87       	std	Z+9, r23	; 0x09
    11fe:	82 87       	std	Z+10, r24	; 0x0a
    1200:	93 87       	std	Z+11, r25	; 0x0b
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1202:	20 91 59 07 	lds	r18, 0x0759
    1206:	2f 70       	andi	r18, 0x0F	; 15
    1208:	20 65       	ori	r18, 0x50	; 80
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	92 e0       	ldi	r25, 0x02	; 2
    120e:	29 83       	std	Y+1, r18	; 0x01
    1210:	dc de       	rcall	.-584    	; 0xfca <SwapEndian_16>
    1212:	f8 01       	movw	r30, r16
    1214:	97 87       	std	Z+15, r25	; 0x0f
    1216:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    1218:	80 e1       	ldi	r24, 0x10	; 16
    121a:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    121c:	13 8a       	std	Z+19, r1	; 0x13
    121e:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    1220:	11 8a       	std	Z+17, r1	; 0x11
    1222:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    1224:	29 81       	ldd	r18, Y+1	; 0x01
    1226:	20 7f       	andi	r18, 0xF0	; 240
    1228:	24 87       	std	Z+12, r18	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    122a:	a1 01       	movw	r20, r2
    122c:	48 5d       	subi	r20, 0xD8	; 216
    122e:	5f 4f       	sbci	r21, 0xFF	; 255
    1230:	94 01       	movw	r18, r8
    1232:	21 56       	subi	r18, 0x61	; 97
    1234:	32 4f       	sbci	r19, 0xF2	; 242
    1236:	ca 01       	movw	r24, r20
    1238:	b9 01       	movw	r22, r18
    123a:	a5 01       	movw	r20, r10
    123c:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    1240:	c5 01       	movw	r24, r10
    1242:	a0 e0       	ldi	r26, 0x00	; 0
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	84 0d       	add	r24, r4
    1248:	95 1d       	adc	r25, r5
    124a:	a6 1d       	adc	r26, r6
    124c:	b7 1d       	adc	r27, r7
    124e:	f7 01       	movw	r30, r14
    1250:	84 87       	std	Z+12, r24	; 0x0c
    1252:	95 87       	std	Z+13, r25	; 0x0d
    1254:	a6 87       	std	Z+14, r26	; 0x0e
    1256:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
    1258:	95 01       	movw	r18, r10
    125a:	2c 5e       	subi	r18, 0xEC	; 236
    125c:	3f 4f       	sbci	r19, 0xFF	; 255
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
    125e:	a4 01       	movw	r20, r8
    1260:	4f 56       	subi	r20, 0x6F	; 111
    1262:	52 4f       	sbci	r21, 0xF2	; 242

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
    1264:	c8 01       	movw	r24, r16
    1266:	6e e0       	ldi	r22, 0x0E	; 14
    1268:	71 e0       	ldi	r23, 0x01	; 1
    126a:	b3 de       	rcall	.-666    	; 0xfd2 <TCP_Checksum16>
    126c:	f8 01       	movw	r30, r16
    126e:	91 8b       	std	Z+17, r25	; 0x11
    1270:	80 8b       	std	Z+16, r24	; 0x10
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    1272:	85 01       	movw	r16, r10
    1274:	08 5d       	subi	r16, 0xD8	; 216
    1276:	1f 4f       	sbci	r17, 0xFF	; 255
    1278:	c8 01       	movw	r24, r16
    127a:	a7 de       	rcall	.-690    	; 0xfca <SwapEndian_16>
    127c:	f1 01       	movw	r30, r2
    127e:	93 83       	std	Z+3, r25	; 0x03
    1280:	82 83       	std	Z+2, r24	; 0x02
			IPHeaderOUT->TypeOfService      = 0;
    1282:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1284:	85 e4       	ldi	r24, 0x45	; 69
    1286:	80 93 39 07 	sts	0x0739, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    128a:	16 82       	std	Z+6, r1	; 0x06
    128c:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    128e:	15 82       	std	Z+5, r1	; 0x05
    1290:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    1292:	13 86       	std	Z+11, r1	; 0x0b
    1294:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1296:	86 e0       	ldi	r24, 0x06	; 6
    1298:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    129a:	80 e8       	ldi	r24, 0x80	; 128
    129c:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    129e:	80 91 0e 01 	lds	r24, 0x010E
    12a2:	90 91 0f 01 	lds	r25, 0x010F
    12a6:	a0 91 10 01 	lds	r26, 0x0110
    12aa:	b0 91 11 01 	lds	r27, 0x0111
    12ae:	84 87       	std	Z+12, r24	; 0x0c
    12b0:	95 87       	std	Z+13, r25	; 0x0d
    12b2:	a6 87       	std	Z+14, r26	; 0x0e
    12b4:	b7 87       	std	Z+15, r27	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    12b6:	f7 01       	movw	r30, r14
    12b8:	84 81       	ldd	r24, Z+4	; 0x04
    12ba:	95 81       	ldd	r25, Z+5	; 0x05
    12bc:	a6 81       	ldd	r26, Z+6	; 0x06
    12be:	b7 81       	ldd	r27, Z+7	; 0x07
    12c0:	f1 01       	movw	r30, r2
    12c2:	80 8b       	std	Z+16, r24	; 0x10
    12c4:	91 8b       	std	Z+17, r25	; 0x11
    12c6:	a2 8b       	std	Z+18, r26	; 0x12
    12c8:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    12ca:	c1 01       	movw	r24, r2
    12cc:	64 e1       	ldi	r22, 0x14	; 20
    12ce:	70 e0       	ldi	r23, 0x00	; 0
    12d0:	13 db       	rcall	.-2522   	; 0x8f8 <Ethernet_Checksum16>
    12d2:	f1 01       	movw	r30, r2
    12d4:	93 87       	std	Z+11, r25	; 0x0b
    12d6:	82 87       	std	Z+10, r24	; 0x0a

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    12d8:	d1 01       	movw	r26, r2
    12da:	18 97       	sbiw	r26, 0x08	; 8
    12dc:	e8 e0       	ldi	r30, 0x08	; 8
    12de:	f1 e0       	ldi	r31, 0x01	; 1
    12e0:	86 e0       	ldi	r24, 0x06	; 6
    12e2:	01 90       	ld	r0, Z+
    12e4:	0d 92       	st	X+, r0
    12e6:	81 50       	subi	r24, 0x01	; 1
    12e8:	e1 f7       	brne	.-8      	; 0x12e2 <TCP_Task+0x20c>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    12ea:	ab e2       	ldi	r26, 0x2B	; 43
    12ec:	b7 e0       	ldi	r27, 0x07	; 7
    12ee:	e2 e2       	ldi	r30, 0x22	; 34
    12f0:	f1 e0       	ldi	r31, 0x01	; 1
    12f2:	86 e0       	ldi	r24, 0x06	; 6
    12f4:	01 90       	ld	r0, Z+
    12f6:	0d 92       	st	X+, r0
    12f8:	81 50       	subi	r24, 0x01	; 1
    12fa:	e1 f7       	brne	.-8      	; 0x12f4 <TCP_Task+0x21e>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	98 e0       	ldi	r25, 0x08	; 8
    1300:	64 de       	rcall	.-824    	; 0xfca <SwapEndian_16>
    1302:	90 93 38 07 	sts	0x0738, r25
    1306:	80 93 37 07 	sts	0x0737, r24

			PacketSize += sizeof(Ethernet_Frame_Header_t);
    130a:	02 5f       	subi	r16, 0xF2	; 242
    130c:	1f 4f       	sbci	r17, 0xFF	; 255

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    130e:	10 93 08 0d 	sts	0x0D08, r17
    1312:	00 93 07 0d 	sts	0x0D07, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    1316:	86 e1       	ldi	r24, 0x16	; 22
    1318:	92 e0       	ldi	r25, 0x02	; 2
    131a:	c8 9e       	mul	r12, r24
    131c:	f0 01       	movw	r30, r0
    131e:	c9 9e       	mul	r12, r25
    1320:	f0 0d       	add	r31, r0
    1322:	d8 9e       	mul	r13, r24
    1324:	f0 0d       	add	r31, r0
    1326:	11 24       	eor	r1, r1
    1328:	e0 56       	subi	r30, 0x60	; 96
    132a:	f0 4f       	sbci	r31, 0xF0	; 240
    132c:	10 82       	st	Z, r1

			break;
    132e:	0a c0       	rjmp	.+20     	; 0x1344 <TCP_Task+0x26e>
    1330:	08 94       	sec
    1332:	c1 1c       	adc	r12, r1
    1334:	d1 1c       	adc	r13, r1
    1336:	ea 5e       	subi	r30, 0xEA	; 234
    1338:	fd 4f       	sbci	r31, 0xFD	; 253
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    133a:	83 e0       	ldi	r24, 0x03	; 3
    133c:	c8 16       	cp	r12, r24
    133e:	d1 04       	cpc	r13, r1
    1340:	09 f0       	breq	.+2      	; 0x1344 <TCP_Task+0x26e>
    1342:	1b cf       	rjmp	.-458    	; 0x117a <TCP_Task+0xa4>
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
    1344:	0f 90       	pop	r0
    1346:	cf 91       	pop	r28
    1348:	df 91       	pop	r29
    134a:	1f 91       	pop	r17
    134c:	0f 91       	pop	r16
    134e:	ff 90       	pop	r15
    1350:	ef 90       	pop	r14
    1352:	df 90       	pop	r13
    1354:	cf 90       	pop	r12
    1356:	bf 90       	pop	r11
    1358:	af 90       	pop	r10
    135a:	9f 90       	pop	r9
    135c:	8f 90       	pop	r8
    135e:	7f 90       	pop	r7
    1360:	6f 90       	pop	r6
    1362:	5f 90       	pop	r5
    1364:	4f 90       	pop	r4
    1366:	3f 90       	pop	r3
    1368:	2f 90       	pop	r2
    136a:	08 95       	ret

0000136c <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
    136c:	10 92 d1 13 	sts	0x13D1, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
    1370:	8a e0       	ldi	r24, 0x0A	; 10
    1372:	80 93 a2 0f 	sts	0x0FA2, r24
    1376:	80 93 b8 11 	sts	0x11B8, r24
    137a:	80 93 ce 13 	sts	0x13CE, r24
}
    137e:	08 95       	ret

00001380 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
    1380:	20 91 cf 13 	lds	r18, 0x13CF
    1384:	30 91 d0 13 	lds	r19, 0x13D0
    1388:	28 17       	cp	r18, r24
    138a:	39 07       	cpc	r19, r25
    138c:	51 f0       	breq	.+20     	; 0x13a2 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
    138e:	61 30       	cpi	r22, 0x01	; 1
    1390:	71 f4       	brne	.+28     	; 0x13ae <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
    1392:	20 91 d1 13 	lds	r18, 0x13D1
    1396:	22 23       	and	r18, r18
    1398:	61 f4       	brne	.+24     	; 0x13b2 <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
    139a:	90 93 d0 13 	sts	0x13D0, r25
    139e:	80 93 cf 13 	sts	0x13CF, r24
				PortStateTable[PTableEntry].State = State;
    13a2:	60 93 d1 13 	sts	0x13D1, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
    13a6:	50 93 d3 13 	sts	0x13D3, r21
    13aa:	40 93 d2 13 	sts	0x13D2, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
    13b2:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
    13b4:	08 95       	ret

000013b6 <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
    13b6:	20 91 cf 13 	lds	r18, 0x13CF
    13ba:	30 91 d0 13 	lds	r19, 0x13D0
    13be:	28 17       	cp	r18, r24
    13c0:	39 07       	cpc	r19, r25
    13c2:	19 f4       	brne	.+6      	; 0x13ca <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
    13c4:	80 91 d1 13 	lds	r24, 0x13D1
    13c8:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
    13ca:	80 e0       	ldi	r24, 0x00	; 0
}
    13cc:	08 95       	ret

000013ce <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
    13ce:	4f 92       	push	r4
    13d0:	5f 92       	push	r5
    13d2:	7f 92       	push	r7
    13d4:	8f 92       	push	r8
    13d6:	9f 92       	push	r9
    13d8:	af 92       	push	r10
    13da:	bf 92       	push	r11
    13dc:	cf 92       	push	r12
    13de:	df 92       	push	r13
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	6c 01       	movw	r12, r24
    13ee:	5b 01       	movw	r10, r22
    13f0:	4a 01       	movw	r8, r20
    13f2:	72 2e       	mov	r7, r18
			ConnectionStateTable[CSTableEntry].State         = State;
			return true;
		}
	}

	return false;
    13f4:	cd e8       	ldi	r28, 0x8D	; 141
    13f6:	dd e0       	ldi	r29, 0x0D	; 13
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
    13f8:	00 e0       	ldi	r16, 0x00	; 0
    13fa:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    13fc:	36 e1       	ldi	r19, 0x16	; 22
    13fe:	43 2e       	mov	r4, r19
    1400:	32 e0       	ldi	r19, 0x02	; 2
    1402:	53 2e       	mov	r5, r19
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1404:	88 81       	ld	r24, Y
    1406:	99 81       	ldd	r25, Y+1	; 0x01
    1408:	8c 15       	cp	r24, r12
    140a:	9d 05       	cpc	r25, r13
    140c:	d1 f4       	brne	.+52     	; 0x1442 <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    140e:	04 9d       	mul	r16, r4
    1410:	70 01       	movw	r14, r0
    1412:	05 9d       	mul	r16, r5
    1414:	f0 0c       	add	r15, r0
    1416:	14 9d       	mul	r17, r4
    1418:	f0 0c       	add	r15, r0
    141a:	11 24       	eor	r1, r1
    141c:	c7 01       	movw	r24, r14
    141e:	8f 56       	subi	r24, 0x6F	; 111
    1420:	92 4f       	sbci	r25, 0xF2	; 242
    1422:	b5 01       	movw	r22, r10
    1424:	44 e0       	ldi	r20, 0x04	; 4
    1426:	50 e0       	ldi	r21, 0x00	; 0
    1428:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    142c:	00 97       	sbiw	r24, 0x00	; 0
    142e:	49 f4       	brne	.+18     	; 0x1442 <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1430:	8a 81       	ldd	r24, Y+2	; 0x02
    1432:	9b 81       	ldd	r25, Y+3	; 0x03
    1434:	88 15       	cp	r24, r8
    1436:	99 05       	cpc	r25, r9
    1438:	21 f4       	brne	.+8      	; 0x1442 <TCP_SetConnectionState+0x74>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
    143a:	f7 01       	movw	r30, r14
    143c:	ee 55       	subi	r30, 0x5E	; 94
    143e:	f0 4f       	sbci	r31, 0xF0	; 240
    1440:	33 c0       	rjmp	.+102    	; 0x14a8 <TCP_SetConnectionState+0xda>
			return true;
    1442:	0f 5f       	subi	r16, 0xFF	; 255
    1444:	1f 4f       	sbci	r17, 0xFF	; 255
    1446:	ca 5e       	subi	r28, 0xEA	; 234
    1448:	dd 4f       	sbci	r29, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    144a:	03 30       	cpi	r16, 0x03	; 3
    144c:	11 05       	cpc	r17, r1
    144e:	d1 f6       	brne	.-76     	; 0x1404 <TCP_SetConnectionState+0x36>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
    1450:	80 91 a2 0f 	lds	r24, 0x0FA2
    1454:	8a 30       	cpi	r24, 0x0A	; 10
    1456:	51 f0       	breq	.+20     	; 0x146c <TCP_SetConnectionState+0x9e>
    1458:	80 91 b8 11 	lds	r24, 0x11B8
    145c:	8a 30       	cpi	r24, 0x0A	; 10
    145e:	41 f0       	breq	.+16     	; 0x1470 <TCP_SetConnectionState+0xa2>
    1460:	80 91 ce 13 	lds	r24, 0x13CE
    1464:	8a 30       	cpi	r24, 0x0A	; 10
    1466:	19 f5       	brne	.+70     	; 0x14ae <TCP_SetConnectionState+0xe0>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1468:	22 e0       	ldi	r18, 0x02	; 2
    146a:	03 c0       	rjmp	.+6      	; 0x1472 <TCP_SetConnectionState+0xa4>
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
    146c:	20 e0       	ldi	r18, 0x00	; 0
    146e:	01 c0       	rjmp	.+2      	; 0x1472 <TCP_SetConnectionState+0xa4>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1470:	21 e0       	ldi	r18, 0x01	; 1
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	86 e1       	ldi	r24, 0x16	; 22
    1476:	92 e0       	ldi	r25, 0x02	; 2
    1478:	28 9f       	mul	r18, r24
    147a:	f0 01       	movw	r30, r0
    147c:	29 9f       	mul	r18, r25
    147e:	f0 0d       	add	r31, r0
    1480:	38 9f       	mul	r19, r24
    1482:	f0 0d       	add	r31, r0
    1484:	11 24       	eor	r1, r1
    1486:	e3 57       	subi	r30, 0x73	; 115
    1488:	f2 4f       	sbci	r31, 0xF2	; 242
    148a:	d1 82       	std	Z+1, r13	; 0x01
    148c:	c0 82       	st	Z, r12
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
    148e:	e5 01       	movw	r28, r10
    1490:	88 81       	ld	r24, Y
    1492:	99 81       	ldd	r25, Y+1	; 0x01
    1494:	aa 81       	ldd	r26, Y+2	; 0x02
    1496:	bb 81       	ldd	r27, Y+3	; 0x03
    1498:	84 83       	std	Z+4, r24	; 0x04
    149a:	95 83       	std	Z+5, r25	; 0x05
    149c:	a6 83       	std	Z+6, r26	; 0x06
    149e:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
    14a0:	93 82       	std	Z+3, r9	; 0x03
    14a2:	82 82       	std	Z+2, r8	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
    14a4:	eb 5e       	subi	r30, 0xEB	; 235
    14a6:	fd 4f       	sbci	r31, 0xFD	; 253
    14a8:	70 82       	st	Z, r7
			return true;
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	01 c0       	rjmp	.+2      	; 0x14b0 <TCP_SetConnectionState+0xe2>
		}
	}

	return false;
    14ae:	80 e0       	ldi	r24, 0x00	; 0
}
    14b0:	df 91       	pop	r29
    14b2:	cf 91       	pop	r28
    14b4:	1f 91       	pop	r17
    14b6:	0f 91       	pop	r16
    14b8:	ff 90       	pop	r15
    14ba:	ef 90       	pop	r14
    14bc:	df 90       	pop	r13
    14be:	cf 90       	pop	r12
    14c0:	bf 90       	pop	r11
    14c2:	af 90       	pop	r10
    14c4:	9f 90       	pop	r9
    14c6:	8f 90       	pop	r8
    14c8:	7f 90       	pop	r7
    14ca:	5f 90       	pop	r5
    14cc:	4f 90       	pop	r4
    14ce:	08 95       	ret

000014d0 <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    14d0:	6f 92       	push	r6
    14d2:	7f 92       	push	r7
    14d4:	8f 92       	push	r8
    14d6:	9f 92       	push	r9
    14d8:	af 92       	push	r10
    14da:	bf 92       	push	r11
    14dc:	cf 92       	push	r12
    14de:	df 92       	push	r13
    14e0:	ef 92       	push	r14
    14e2:	ff 92       	push	r15
    14e4:	0f 93       	push	r16
    14e6:	1f 93       	push	r17
    14e8:	cf 93       	push	r28
    14ea:	df 93       	push	r29
    14ec:	6c 01       	movw	r12, r24
    14ee:	5b 01       	movw	r10, r22
    14f0:	4a 01       	movw	r8, r20
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    14f2:	cd e8       	ldi	r28, 0x8D	; 141
    14f4:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    14f6:	00 e0       	ldi	r16, 0x00	; 0
    14f8:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    14fa:	46 e1       	ldi	r20, 0x16	; 22
    14fc:	64 2e       	mov	r6, r20
    14fe:	42 e0       	ldi	r20, 0x02	; 2
    1500:	74 2e       	mov	r7, r20
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    1502:	88 81       	ld	r24, Y
    1504:	99 81       	ldd	r25, Y+1	; 0x01
    1506:	8c 15       	cp	r24, r12
    1508:	9d 05       	cpc	r25, r13
    150a:	d9 f4       	brne	.+54     	; 0x1542 <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    150c:	06 9d       	mul	r16, r6
    150e:	70 01       	movw	r14, r0
    1510:	07 9d       	mul	r16, r7
    1512:	f0 0c       	add	r15, r0
    1514:	16 9d       	mul	r17, r6
    1516:	f0 0c       	add	r15, r0
    1518:	11 24       	eor	r1, r1
    151a:	c7 01       	movw	r24, r14
    151c:	8f 56       	subi	r24, 0x6F	; 111
    151e:	92 4f       	sbci	r25, 0xF2	; 242
    1520:	b5 01       	movw	r22, r10
    1522:	44 e0       	ldi	r20, 0x04	; 4
    1524:	50 e0       	ldi	r21, 0x00	; 0
    1526:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    152a:	00 97       	sbiw	r24, 0x00	; 0
    152c:	51 f4       	brne	.+20     	; 0x1542 <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    152e:	8a 81       	ldd	r24, Y+2	; 0x02
    1530:	9b 81       	ldd	r25, Y+3	; 0x03
    1532:	88 15       	cp	r24, r8
    1534:	99 05       	cpc	r25, r9
    1536:	29 f4       	brne	.+10     	; 0x1542 <TCP_GetConnectionState+0x72>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
    1538:	f7 01       	movw	r30, r14
    153a:	ee 55       	subi	r30, 0x5E	; 94
    153c:	f0 4f       	sbci	r31, 0xF0	; 240
    153e:	80 81       	ld	r24, Z
    1540:	08 c0       	rjmp	.+16     	; 0x1552 <TCP_GetConnectionState+0x82>
    1542:	0f 5f       	subi	r16, 0xFF	; 255
    1544:	1f 4f       	sbci	r17, 0xFF	; 255
    1546:	ca 5e       	subi	r28, 0xEA	; 234
    1548:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    154a:	03 30       	cpi	r16, 0x03	; 3
    154c:	11 05       	cpc	r17, r1
    154e:	c9 f6       	brne	.-78     	; 0x1502 <TCP_GetConnectionState+0x32>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    1550:	8a e0       	ldi	r24, 0x0A	; 10
}
    1552:	df 91       	pop	r29
    1554:	cf 91       	pop	r28
    1556:	1f 91       	pop	r17
    1558:	0f 91       	pop	r16
    155a:	ff 90       	pop	r15
    155c:	ef 90       	pop	r14
    155e:	df 90       	pop	r13
    1560:	cf 90       	pop	r12
    1562:	bf 90       	pop	r11
    1564:	af 90       	pop	r10
    1566:	9f 90       	pop	r9
    1568:	8f 90       	pop	r8
    156a:	7f 90       	pop	r7
    156c:	6f 90       	pop	r6
    156e:	08 95       	ret

00001570 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    1570:	6f 92       	push	r6
    1572:	7f 92       	push	r7
    1574:	8f 92       	push	r8
    1576:	9f 92       	push	r9
    1578:	af 92       	push	r10
    157a:	bf 92       	push	r11
    157c:	cf 92       	push	r12
    157e:	df 92       	push	r13
    1580:	ef 92       	push	r14
    1582:	ff 92       	push	r15
    1584:	0f 93       	push	r16
    1586:	1f 93       	push	r17
    1588:	cf 93       	push	r28
    158a:	df 93       	push	r29
    158c:	6c 01       	movw	r12, r24
    158e:	5b 01       	movw	r10, r22
    1590:	4a 01       	movw	r8, r20
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    1592:	cd e8       	ldi	r28, 0x8D	; 141
    1594:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    1596:	00 e0       	ldi	r16, 0x00	; 0
    1598:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    159a:	56 e1       	ldi	r21, 0x16	; 22
    159c:	65 2e       	mov	r6, r21
    159e:	52 e0       	ldi	r21, 0x02	; 2
    15a0:	75 2e       	mov	r7, r21
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    15a2:	88 81       	ld	r24, Y
    15a4:	99 81       	ldd	r25, Y+1	; 0x01
    15a6:	8c 15       	cp	r24, r12
    15a8:	9d 05       	cpc	r25, r13
    15aa:	d1 f4       	brne	.+52     	; 0x15e0 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    15ac:	06 9d       	mul	r16, r6
    15ae:	70 01       	movw	r14, r0
    15b0:	07 9d       	mul	r16, r7
    15b2:	f0 0c       	add	r15, r0
    15b4:	16 9d       	mul	r17, r6
    15b6:	f0 0c       	add	r15, r0
    15b8:	11 24       	eor	r1, r1
    15ba:	c7 01       	movw	r24, r14
    15bc:	8f 56       	subi	r24, 0x6F	; 111
    15be:	92 4f       	sbci	r25, 0xF2	; 242
    15c0:	b5 01       	movw	r22, r10
    15c2:	44 e0       	ldi	r20, 0x04	; 4
    15c4:	50 e0       	ldi	r21, 0x00	; 0
    15c6:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    15ca:	00 97       	sbiw	r24, 0x00	; 0
    15cc:	49 f4       	brne	.+18     	; 0x15e0 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    15ce:	8a 81       	ldd	r24, Y+2	; 0x02
    15d0:	9b 81       	ldd	r25, Y+3	; 0x03
    15d2:	88 15       	cp	r24, r8
    15d4:	99 05       	cpc	r25, r9
    15d6:	21 f4       	brne	.+8      	; 0x15e0 <TCP_GetConnectionInfo+0x70>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
    15d8:	97 01       	movw	r18, r14
    15da:	2b 56       	subi	r18, 0x6B	; 107
    15dc:	32 4f       	sbci	r19, 0xF2	; 242
    15de:	09 c0       	rjmp	.+18     	; 0x15f2 <TCP_GetConnectionInfo+0x82>
    15e0:	0f 5f       	subi	r16, 0xFF	; 255
    15e2:	1f 4f       	sbci	r17, 0xFF	; 255
    15e4:	ca 5e       	subi	r28, 0xEA	; 234
    15e6:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    15e8:	03 30       	cpi	r16, 0x03	; 3
    15ea:	11 05       	cpc	r17, r1
    15ec:	d1 f6       	brne	.-76     	; 0x15a2 <TCP_GetConnectionInfo+0x32>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    15ee:	20 e0       	ldi	r18, 0x00	; 0
    15f0:	30 e0       	ldi	r19, 0x00	; 0
}
    15f2:	c9 01       	movw	r24, r18
    15f4:	df 91       	pop	r29
    15f6:	cf 91       	pop	r28
    15f8:	1f 91       	pop	r17
    15fa:	0f 91       	pop	r16
    15fc:	ff 90       	pop	r15
    15fe:	ef 90       	pop	r14
    1600:	df 90       	pop	r13
    1602:	cf 90       	pop	r12
    1604:	bf 90       	pop	r11
    1606:	af 90       	pop	r10
    1608:	9f 90       	pop	r9
    160a:	8f 90       	pop	r8
    160c:	7f 90       	pop	r7
    160e:	6f 90       	pop	r6
    1610:	08 95       	ret

00001612 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
    1612:	4f 92       	push	r4
    1614:	5f 92       	push	r5
    1616:	6f 92       	push	r6
    1618:	7f 92       	push	r7
    161a:	8f 92       	push	r8
    161c:	9f 92       	push	r9
    161e:	af 92       	push	r10
    1620:	bf 92       	push	r11
    1622:	cf 92       	push	r12
    1624:	df 92       	push	r13
    1626:	ef 92       	push	r14
    1628:	ff 92       	push	r15
    162a:	0f 93       	push	r16
    162c:	1f 93       	push	r17
    162e:	df 93       	push	r29
    1630:	cf 93       	push	r28
    1632:	0f 92       	push	r0
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	2b 01       	movw	r4, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
    163a:	3c 01       	movw	r6, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
    163c:	8a 01       	movw	r16, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
    163e:	cb 01       	movw	r24, r22
    1640:	94 d9       	rcall	.-3288   	; 0x96a <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
    1642:	d2 01       	movw	r26, r4
    1644:	12 96       	adiw	r26, 0x02	; 2
    1646:	ed 90       	ld	r14, X+
    1648:	fc 90       	ld	r15, X
    164a:	13 97       	sbiw	r26, 0x03	; 3
    164c:	c7 01       	movw	r24, r14
    164e:	b3 de       	rcall	.-666    	; 0x13b6 <TCP_GetPortState>
    1650:	81 30       	cpi	r24, 0x01	; 1
    1652:	09 f0       	breq	.+2      	; 0x1656 <TCP_ProcessTCPPacket+0x44>
    1654:	a2 c1       	rjmp	.+836    	; 0x199a <TCP_ProcessTCPPacket+0x388>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
    1656:	f2 01       	movw	r30, r4
    1658:	85 85       	ldd	r24, Z+13	; 0x0d
    165a:	81 ff       	sbrs	r24, 1
    165c:	08 c0       	rjmp	.+16     	; 0x166e <TCP_ProcessTCPPacket+0x5c>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
    165e:	b3 01       	movw	r22, r6
    1660:	64 5f       	subi	r22, 0xF4	; 244
    1662:	7f 4f       	sbci	r23, 0xFF	; 255
    1664:	40 81       	ld	r20, Z
    1666:	51 81       	ldd	r21, Z+1	; 0x01
    1668:	c7 01       	movw	r24, r14
    166a:	20 e0       	ldi	r18, 0x00	; 0
    166c:	b0 de       	rcall	.-672    	; 0x13ce <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    166e:	d2 01       	movw	r26, r4
    1670:	1d 96       	adiw	r26, 0x0d	; 13
    1672:	2c 91       	ld	r18, X
    1674:	1d 97       	sbiw	r26, 0x0d	; 13
    1676:	12 96       	adiw	r26, 0x02	; 2
    1678:	ed 90       	ld	r14, X+
    167a:	fc 90       	ld	r15, X
    167c:	13 97       	sbiw	r26, 0x03	; 3
    167e:	8c e0       	ldi	r24, 0x0C	; 12
    1680:	a8 2e       	mov	r10, r24
    1682:	b1 2c       	mov	r11, r1
    1684:	a6 0c       	add	r10, r6
    1686:	b7 1c       	adc	r11, r7
    1688:	cd 90       	ld	r12, X+
    168a:	dc 90       	ld	r13, X
    168c:	11 97       	sbiw	r26, 0x01	; 1
    168e:	22 ff       	sbrs	r18, 2
    1690:	0a c0       	rjmp	.+20     	; 0x16a6 <TCP_ProcessTCPPacket+0x94>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1692:	c7 01       	movw	r24, r14
    1694:	b5 01       	movw	r22, r10
    1696:	a6 01       	movw	r20, r12
    1698:	2a e0       	ldi	r18, 0x0A	; 10
    169a:	99 de       	rcall	.-718    	; 0x13ce <TCP_SetConnectionState>
    169c:	88 23       	and	r24, r24
    169e:	09 f4       	brne	.+2      	; 0x16a2 <TCP_ProcessTCPPacket+0x90>
    16a0:	b2 c1       	rjmp	.+868    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    16a2:	84 e1       	ldi	r24, 0x14	; 20
    16a4:	23 c1       	rjmp	.+582    	; 0x18ec <TCP_ProcessTCPPacket+0x2da>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    16a6:	c7 01       	movw	r24, r14
    16a8:	b5 01       	movw	r22, r10
    16aa:	a6 01       	movw	r20, r12
    16ac:	29 83       	std	Y+1, r18	; 0x01
    16ae:	10 df       	rcall	.-480    	; 0x14d0 <TCP_GetConnectionState>
    16b0:	29 81       	ldd	r18, Y+1	; 0x01
    16b2:	84 30       	cpi	r24, 0x04	; 4
    16b4:	09 f4       	brne	.+2      	; 0x16b8 <TCP_ProcessTCPPacket+0xa6>
    16b6:	32 c1       	rjmp	.+612    	; 0x191c <TCP_ProcessTCPPacket+0x30a>
    16b8:	85 30       	cpi	r24, 0x05	; 5
    16ba:	48 f4       	brcc	.+18     	; 0x16ce <TCP_ProcessTCPPacket+0xbc>
    16bc:	82 30       	cpi	r24, 0x02	; 2
    16be:	09 f4       	brne	.+2      	; 0x16c2 <TCP_ProcessTCPPacket+0xb0>
    16c0:	43 c0       	rjmp	.+134    	; 0x1748 <TCP_ProcessTCPPacket+0x136>
    16c2:	83 30       	cpi	r24, 0x03	; 3
    16c4:	08 f0       	brcs	.+2      	; 0x16c8 <TCP_ProcessTCPPacket+0xb6>
    16c6:	60 c0       	rjmp	.+192    	; 0x1788 <TCP_ProcessTCPPacket+0x176>
    16c8:	88 23       	and	r24, r24
    16ca:	59 f0       	breq	.+22     	; 0x16e2 <TCP_ProcessTCPPacket+0xd0>
    16cc:	9c c1       	rjmp	.+824    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
    16ce:	86 30       	cpi	r24, 0x06	; 6
    16d0:	09 f4       	brne	.+2      	; 0x16d4 <TCP_ProcessTCPPacket+0xc2>
    16d2:	5a c1       	rjmp	.+692    	; 0x1988 <TCP_ProcessTCPPacket+0x376>
    16d4:	86 30       	cpi	r24, 0x06	; 6
    16d6:	08 f4       	brcc	.+2      	; 0x16da <TCP_ProcessTCPPacket+0xc8>
    16d8:	2b c1       	rjmp	.+598    	; 0x1930 <TCP_ProcessTCPPacket+0x31e>
    16da:	87 30       	cpi	r24, 0x07	; 7
    16dc:	09 f0       	breq	.+2      	; 0x16e0 <TCP_ProcessTCPPacket+0xce>
    16de:	93 c1       	rjmp	.+806    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
    16e0:	08 c1       	rjmp	.+528    	; 0x18f2 <TCP_ProcessTCPPacket+0x2e0>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    16e2:	22 30       	cpi	r18, 0x02	; 2
    16e4:	09 f0       	breq	.+2      	; 0x16e8 <TCP_ProcessTCPPacket+0xd6>
    16e6:	8f c1       	rjmp	.+798    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    16e8:	c7 01       	movw	r24, r14
    16ea:	b5 01       	movw	r22, r10
    16ec:	a6 01       	movw	r20, r12
    16ee:	6f de       	rcall	.-802    	; 0x13ce <TCP_SetConnectionState>
    16f0:	88 23       	and	r24, r24
    16f2:	41 f1       	breq	.+80     	; 0x1744 <TCP_ProcessTCPPacket+0x132>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    16f4:	82 e1       	ldi	r24, 0x12	; 18
    16f6:	d8 01       	movw	r26, r16
    16f8:	1d 96       	adiw	r26, 0x0d	; 13
    16fa:	8c 93       	st	X, r24

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    16fc:	f2 01       	movw	r30, r4
    16fe:	40 81       	ld	r20, Z
    1700:	51 81       	ldd	r21, Z+1	; 0x01
    1702:	82 81       	ldd	r24, Z+2	; 0x02
    1704:	93 81       	ldd	r25, Z+3	; 0x03
    1706:	b5 01       	movw	r22, r10
    1708:	33 df       	rcall	.-410    	; 0x1570 <TCP_GetConnectionInfo>
    170a:	7c 01       	movw	r14, r24

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    170c:	d2 01       	movw	r26, r4
    170e:	14 96       	adiw	r26, 0x04	; 4
    1710:	6d 91       	ld	r22, X+
    1712:	7d 91       	ld	r23, X+
    1714:	8d 91       	ld	r24, X+
    1716:	9c 91       	ld	r25, X
    1718:	17 97       	sbiw	r26, 0x07	; 7
    171a:	51 dc       	rcall	.-1886   	; 0xfbe <SwapEndian_32>
    171c:	6f 5f       	subi	r22, 0xFF	; 255
    171e:	7f 4f       	sbci	r23, 0xFF	; 255
    1720:	8f 4f       	sbci	r24, 0xFF	; 255
    1722:	9f 4f       	sbci	r25, 0xFF	; 255
    1724:	f7 01       	movw	r30, r14
    1726:	60 83       	st	Z, r22
    1728:	71 83       	std	Z+1, r23	; 0x01
    172a:	82 83       	std	Z+2, r24	; 0x02
    172c:	93 83       	std	Z+3, r25	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
    172e:	d7 01       	movw	r26, r14
    1730:	14 96       	adiw	r26, 0x04	; 4
    1732:	1d 92       	st	X+, r1
    1734:	1d 92       	st	X+, r1
    1736:	1d 92       	st	X+, r1
    1738:	1c 92       	st	X, r1
    173a:	17 97       	sbiw	r26, 0x07	; 7
							ConnectionInfo->Buffer.InUse      = false;
    173c:	e4 5f       	subi	r30, 0xF4	; 244
    173e:	fd 4f       	sbci	r31, 0xFD	; 253
    1740:	10 82       	st	Z, r1
    1742:	76 c1       	rjmp	.+748    	; 0x1a30 <TCP_ProcessTCPPacket+0x41e>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    1744:	84 e0       	ldi	r24, 0x04	; 4
    1746:	d2 c0       	rjmp	.+420    	; 0x18ec <TCP_ProcessTCPPacket+0x2da>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1748:	20 31       	cpi	r18, 0x10	; 16
    174a:	09 f0       	breq	.+2      	; 0x174e <TCP_ProcessTCPPacket+0x13c>
    174c:	5c c1       	rjmp	.+696    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    174e:	c7 01       	movw	r24, r14
    1750:	b5 01       	movw	r22, r10
    1752:	a6 01       	movw	r20, r12
    1754:	23 e0       	ldi	r18, 0x03	; 3
    1756:	3b de       	rcall	.-906    	; 0x13ce <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1758:	d2 01       	movw	r26, r4
    175a:	4d 91       	ld	r20, X+
    175c:	5c 91       	ld	r21, X
    175e:	11 97       	sbiw	r26, 0x01	; 1
    1760:	12 96       	adiw	r26, 0x02	; 2
    1762:	8d 91       	ld	r24, X+
    1764:	9c 91       	ld	r25, X
    1766:	13 97       	sbiw	r26, 0x03	; 3
    1768:	b5 01       	movw	r22, r10
    176a:	02 df       	rcall	.-508    	; 0x1570 <TCP_GetConnectionInfo>
    176c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    176e:	24 81       	ldd	r18, Z+4	; 0x04
    1770:	35 81       	ldd	r19, Z+5	; 0x05
    1772:	46 81       	ldd	r20, Z+6	; 0x06
    1774:	57 81       	ldd	r21, Z+7	; 0x07
    1776:	2f 5f       	subi	r18, 0xFF	; 255
    1778:	3f 4f       	sbci	r19, 0xFF	; 255
    177a:	4f 4f       	sbci	r20, 0xFF	; 255
    177c:	5f 4f       	sbci	r21, 0xFF	; 255
    177e:	24 83       	std	Z+4, r18	; 0x04
    1780:	35 83       	std	Z+5, r19	; 0x05
    1782:	46 83       	std	Z+6, r20	; 0x06
    1784:	57 83       	std	Z+7, r21	; 0x07
    1786:	3f c1       	rjmp	.+638    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1788:	21 31       	cpi	r18, 0x11	; 17
    178a:	69 f5       	brne	.+90     	; 0x17e6 <TCP_ProcessTCPPacket+0x1d4>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    178c:	f8 01       	movw	r30, r16
    178e:	25 87       	std	Z+13, r18	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1790:	d2 01       	movw	r26, r4
    1792:	4d 91       	ld	r20, X+
    1794:	5c 91       	ld	r21, X
    1796:	11 97       	sbiw	r26, 0x01	; 1
    1798:	12 96       	adiw	r26, 0x02	; 2
    179a:	8d 91       	ld	r24, X+
    179c:	9c 91       	ld	r25, X
    179e:	13 97       	sbiw	r26, 0x03	; 3
    17a0:	b5 01       	movw	r22, r10
    17a2:	26 e0       	ldi	r18, 0x06	; 6
    17a4:	14 de       	rcall	.-984    	; 0x13ce <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17a6:	f2 01       	movw	r30, r4
    17a8:	40 81       	ld	r20, Z
    17aa:	51 81       	ldd	r21, Z+1	; 0x01
    17ac:	82 81       	ldd	r24, Z+2	; 0x02
    17ae:	93 81       	ldd	r25, Z+3	; 0x03
    17b0:	b5 01       	movw	r22, r10
    17b2:	de de       	rcall	.-580    	; 0x1570 <TCP_GetConnectionInfo>
    17b4:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    17b6:	80 81       	ld	r24, Z
    17b8:	91 81       	ldd	r25, Z+1	; 0x01
    17ba:	a2 81       	ldd	r26, Z+2	; 0x02
    17bc:	b3 81       	ldd	r27, Z+3	; 0x03
    17be:	01 96       	adiw	r24, 0x01	; 1
    17c0:	a1 1d       	adc	r26, r1
    17c2:	b1 1d       	adc	r27, r1
    17c4:	80 83       	st	Z, r24
    17c6:	91 83       	std	Z+1, r25	; 0x01
    17c8:	a2 83       	std	Z+2, r26	; 0x02
    17ca:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    17cc:	24 81       	ldd	r18, Z+4	; 0x04
    17ce:	35 81       	ldd	r19, Z+5	; 0x05
    17d0:	46 81       	ldd	r20, Z+6	; 0x06
    17d2:	57 81       	ldd	r21, Z+7	; 0x07
    17d4:	2f 5f       	subi	r18, 0xFF	; 255
    17d6:	3f 4f       	sbci	r19, 0xFF	; 255
    17d8:	4f 4f       	sbci	r20, 0xFF	; 255
    17da:	5f 4f       	sbci	r21, 0xFF	; 255
    17dc:	24 83       	std	Z+4, r18	; 0x04
    17de:	35 83       	std	Z+5, r19	; 0x05
    17e0:	46 83       	std	Z+6, r20	; 0x06
    17e2:	57 83       	std	Z+7, r21	; 0x07
    17e4:	25 c1       	rjmp	.+586    	; 0x1a30 <TCP_ProcessTCPPacket+0x41e>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    17e6:	20 31       	cpi	r18, 0x10	; 16
    17e8:	19 f0       	breq	.+6      	; 0x17f0 <TCP_ProcessTCPPacket+0x1de>
    17ea:	28 31       	cpi	r18, 0x18	; 24
    17ec:	09 f0       	breq	.+2      	; 0x17f0 <TCP_ProcessTCPPacket+0x1de>
    17ee:	0b c1       	rjmp	.+534    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    17f0:	c7 01       	movw	r24, r14
    17f2:	b5 01       	movw	r22, r10
    17f4:	a6 01       	movw	r20, r12
    17f6:	bc de       	rcall	.-648    	; 0x1570 <TCP_GetConnectionInfo>
    17f8:	7c 01       	movw	r14, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    17fa:	fc 01       	movw	r30, r24
    17fc:	e4 5f       	subi	r30, 0xF4	; 244
    17fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1800:	80 81       	ld	r24, Z
    1802:	88 23       	and	r24, r24
    1804:	89 f4       	brne	.+34     	; 0x1828 <TCP_ProcessTCPPacket+0x216>
    1806:	d7 01       	movw	r26, r14
    1808:	a5 5f       	subi	r26, 0xF5	; 245
    180a:	bd 4f       	sbci	r27, 0xFD	; 253
    180c:	8c 91       	ld	r24, X
    180e:	88 23       	and	r24, r24
    1810:	59 f4       	brne	.+22     	; 0x1828 <TCP_ProcessTCPPacket+0x216>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    1812:	d7 01       	movw	r26, r14
    1814:	a6 5f       	subi	r26, 0xF6	; 246
    1816:	bd 4f       	sbci	r27, 0xFD	; 253
    1818:	1c 92       	st	X, r1
							ConnectionInfo->Buffer.InUse     = true;
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    181e:	d7 01       	movw	r26, r14
    1820:	19 96       	adiw	r26, 0x09	; 9
    1822:	1c 92       	st	X, r1
    1824:	1e 92       	st	-X, r1
    1826:	18 97       	sbiw	r26, 0x08	; 8
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    1828:	f7 01       	movw	r30, r14
    182a:	e6 5f       	subi	r30, 0xF6	; 246
    182c:	fd 4f       	sbci	r31, 0xFD	; 253
    182e:	80 81       	ld	r24, Z
    1830:	88 23       	and	r24, r24
    1832:	09 f0       	breq	.+2      	; 0x1836 <TCP_ProcessTCPPacket+0x224>
    1834:	e5 c0       	rjmp	.+458    	; 0x1a00 <TCP_ProcessTCPPacket+0x3ee>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    1836:	f7 01       	movw	r30, r14
    1838:	80 84       	ldd	r8, Z+8	; 0x08
    183a:	91 84       	ldd	r9, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	8f 16       	cp	r8, r31
    1840:	f2 e0       	ldi	r31, 0x02	; 2
    1842:	9f 06       	cpc	r9, r31
    1844:	09 f4       	brne	.+2      	; 0x1848 <TCP_ProcessTCPPacket+0x236>
    1846:	dc c0       	rjmp	.+440    	; 0x1a00 <TCP_ProcessTCPPacket+0x3ee>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    1848:	d2 01       	movw	r26, r4
    184a:	1c 96       	adiw	r26, 0x0c	; 12
    184c:	cc 90       	ld	r12, X
    184e:	c2 94       	swap	r12
    1850:	ff e0       	ldi	r31, 0x0F	; 15
    1852:	cf 22       	and	r12, r31
    1854:	dd 24       	eor	r13, r13
    1856:	cc 0c       	add	r12, r12
    1858:	dd 1c       	adc	r13, r13
    185a:	cc 0c       	add	r12, r12
    185c:	dd 1c       	adc	r13, r13
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    185e:	f3 01       	movw	r30, r6
    1860:	82 81       	ldd	r24, Z+2	; 0x02
    1862:	93 81       	ldd	r25, Z+3	; 0x03
    1864:	b2 db       	rcall	.-2204   	; 0xfca <SwapEndian_16>

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1866:	d3 01       	movw	r26, r6
    1868:	2c 91       	ld	r18, X
    186a:	2f 70       	andi	r18, 0x0F	; 15
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	22 0f       	add	r18, r18
    1870:	33 1f       	adc	r19, r19
    1872:	22 0f       	add	r18, r18
    1874:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1876:	5c 01       	movw	r10, r24
    1878:	a2 1a       	sub	r10, r18
    187a:	b3 0a       	sbc	r11, r19
    187c:	ac 18       	sub	r10, r12
    187e:	bd 08       	sbc	r11, r13

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    1880:	97 01       	movw	r18, r14
    1882:	26 5f       	subi	r18, 0xF6	; 246
    1884:	3f 4f       	sbci	r19, 0xFF	; 255
    1886:	28 0d       	add	r18, r8
    1888:	39 1d       	adc	r19, r9
    188a:	c4 0c       	add	r12, r4
    188c:	d5 1c       	adc	r13, r5
    188e:	c9 01       	movw	r24, r18
    1890:	b6 01       	movw	r22, r12
    1892:	a5 01       	movw	r20, r10
    1894:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1898:	95 01       	movw	r18, r10
    189a:	40 e0       	ldi	r20, 0x00	; 0
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	f7 01       	movw	r30, r14
    18a0:	80 81       	ld	r24, Z
    18a2:	91 81       	ldd	r25, Z+1	; 0x01
    18a4:	a2 81       	ldd	r26, Z+2	; 0x02
    18a6:	b3 81       	ldd	r27, Z+3	; 0x03
    18a8:	82 0f       	add	r24, r18
    18aa:	93 1f       	adc	r25, r19
    18ac:	a4 1f       	adc	r26, r20
    18ae:	b5 1f       	adc	r27, r21
    18b0:	80 83       	st	Z, r24
    18b2:	91 83       	std	Z+1, r25	; 0x01
    18b4:	a2 83       	std	Z+2, r26	; 0x02
    18b6:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    18b8:	80 85       	ldd	r24, Z+8	; 0x08
    18ba:	91 85       	ldd	r25, Z+9	; 0x09
    18bc:	8a 0d       	add	r24, r10
    18be:	9b 1d       	adc	r25, r11
    18c0:	91 87       	std	Z+9, r25	; 0x09
    18c2:	80 87       	std	Z+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    18c4:	f2 e0       	ldi	r31, 0x02	; 2
    18c6:	80 30       	cpi	r24, 0x00	; 0
    18c8:	9f 07       	cpc	r25, r31
    18ca:	31 f0       	breq	.+12     	; 0x18d8 <TCP_ProcessTCPPacket+0x2c6>
    18cc:	d2 01       	movw	r26, r4
    18ce:	1d 96       	adiw	r26, 0x0d	; 13
    18d0:	8c 91       	ld	r24, X
    18d2:	1d 97       	sbiw	r26, 0x0d	; 13
    18d4:	83 ff       	sbrs	r24, 3
    18d6:	97 c0       	rjmp	.+302    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
							{
								ConnectionInfo->Buffer.InUse = false;
    18d8:	f7 01       	movw	r30, r14
    18da:	e4 5f       	subi	r30, 0xF4	; 244
    18dc:	fd 4f       	sbci	r31, 0xFD	; 253
    18de:	10 82       	st	Z, r1
								ConnectionInfo->Buffer.Ready = true;
    18e0:	f7 01       	movw	r30, r14
    18e2:	e5 5f       	subi	r30, 0xF5	; 245
    18e4:	fd 4f       	sbci	r31, 0xFD	; 253
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	80 83       	st	Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    18ea:	80 e1       	ldi	r24, 0x10	; 16
    18ec:	f8 01       	movw	r30, r16
    18ee:	85 87       	std	Z+13, r24	; 0x0d
    18f0:	9f c0       	rjmp	.+318    	; 0x1a30 <TCP_ProcessTCPPacket+0x41e>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    18f2:	c7 01       	movw	r24, r14
    18f4:	b5 01       	movw	r22, r10
    18f6:	a6 01       	movw	r20, r12
    18f8:	3b de       	rcall	.-906    	; 0x1570 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    18fa:	21 e1       	ldi	r18, 0x11	; 17
    18fc:	d8 01       	movw	r26, r16
    18fe:	1d 96       	adiw	r26, 0x0d	; 13
    1900:	2c 93       	st	X, r18
    1902:	1d 97       	sbiw	r26, 0x0d	; 13
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1904:	fc 01       	movw	r30, r24
    1906:	e4 5f       	subi	r30, 0xF4	; 244
    1908:	fd 4f       	sbci	r31, 0xFD	; 253
    190a:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    190c:	f2 01       	movw	r30, r4
    190e:	40 81       	ld	r20, Z
    1910:	51 81       	ldd	r21, Z+1	; 0x01
    1912:	82 81       	ldd	r24, Z+2	; 0x02
    1914:	93 81       	ldd	r25, Z+3	; 0x03
    1916:	b5 01       	movw	r22, r10
    1918:	24 e0       	ldi	r18, 0x04	; 4
    191a:	34 c0       	rjmp	.+104    	; 0x1984 <TCP_ProcessTCPPacket+0x372>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    191c:	21 31       	cpi	r18, 0x11	; 17
    191e:	59 f0       	breq	.+22     	; 0x1936 <TCP_ProcessTCPPacket+0x324>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1920:	20 31       	cpi	r18, 0x10	; 16
    1922:	09 f0       	breq	.+2      	; 0x1926 <TCP_ProcessTCPPacket+0x314>
    1924:	70 c0       	rjmp	.+224    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1926:	c7 01       	movw	r24, r14
    1928:	b5 01       	movw	r22, r10
    192a:	a6 01       	movw	r20, r12
    192c:	25 e0       	ldi	r18, 0x05	; 5
    192e:	33 c0       	rjmp	.+102    	; 0x1996 <TCP_ProcessTCPPacket+0x384>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1930:	21 31       	cpi	r18, 0x11	; 17
    1932:	09 f0       	breq	.+2      	; 0x1936 <TCP_ProcessTCPPacket+0x324>
    1934:	68 c0       	rjmp	.+208    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1936:	c7 01       	movw	r24, r14
    1938:	b5 01       	movw	r22, r10
    193a:	a6 01       	movw	r20, r12
    193c:	19 de       	rcall	.-974    	; 0x1570 <TCP_GetConnectionInfo>
    193e:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1940:	80 e1       	ldi	r24, 0x10	; 16
    1942:	d8 01       	movw	r26, r16
    1944:	1d 96       	adiw	r26, 0x0d	; 13
    1946:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1948:	80 81       	ld	r24, Z
    194a:	91 81       	ldd	r25, Z+1	; 0x01
    194c:	a2 81       	ldd	r26, Z+2	; 0x02
    194e:	b3 81       	ldd	r27, Z+3	; 0x03
    1950:	01 96       	adiw	r24, 0x01	; 1
    1952:	a1 1d       	adc	r26, r1
    1954:	b1 1d       	adc	r27, r1
    1956:	80 83       	st	Z, r24
    1958:	91 83       	std	Z+1, r25	; 0x01
    195a:	a2 83       	std	Z+2, r26	; 0x02
    195c:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    195e:	24 81       	ldd	r18, Z+4	; 0x04
    1960:	35 81       	ldd	r19, Z+5	; 0x05
    1962:	46 81       	ldd	r20, Z+6	; 0x06
    1964:	57 81       	ldd	r21, Z+7	; 0x07
    1966:	2f 5f       	subi	r18, 0xFF	; 255
    1968:	3f 4f       	sbci	r19, 0xFF	; 255
    196a:	4f 4f       	sbci	r20, 0xFF	; 255
    196c:	5f 4f       	sbci	r21, 0xFF	; 255
    196e:	24 83       	std	Z+4, r18	; 0x04
    1970:	35 83       	std	Z+5, r19	; 0x05
    1972:	46 83       	std	Z+6, r20	; 0x06
    1974:	57 83       	std	Z+7, r21	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1976:	f2 01       	movw	r30, r4
    1978:	40 81       	ld	r20, Z
    197a:	51 81       	ldd	r21, Z+1	; 0x01
    197c:	82 81       	ldd	r24, Z+2	; 0x02
    197e:	93 81       	ldd	r25, Z+3	; 0x03
    1980:	b5 01       	movw	r22, r10
    1982:	2a e0       	ldi	r18, 0x0A	; 10
    1984:	24 dd       	rcall	.-1464   	; 0x13ce <TCP_SetConnectionState>
    1986:	54 c0       	rjmp	.+168    	; 0x1a30 <TCP_ProcessTCPPacket+0x41e>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1988:	20 31       	cpi	r18, 0x10	; 16
    198a:	09 f0       	breq	.+2      	; 0x198e <TCP_ProcessTCPPacket+0x37c>
    198c:	3c c0       	rjmp	.+120    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    198e:	c7 01       	movw	r24, r14
    1990:	b5 01       	movw	r22, r10
    1992:	a6 01       	movw	r20, r12
    1994:	2a e0       	ldi	r18, 0x0A	; 10
    1996:	1b dd       	rcall	.-1482   	; 0x13ce <TCP_SetConnectionState>
    1998:	36 c0       	rjmp	.+108    	; 0x1a06 <TCP_ProcessTCPPacket+0x3f4>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    199a:	84 e1       	ldi	r24, 0x14	; 20
    199c:	d8 01       	movw	r26, r16
    199e:	1d 96       	adiw	r26, 0x0d	; 13
    19a0:	8c 93       	st	X, r24
    19a2:	1d 97       	sbiw	r26, 0x0d	; 13
    19a4:	45 c0       	rjmp	.+138    	; 0x1a30 <TCP_ProcessTCPPacket+0x41e>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	92 e0       	ldi	r25, 0x02	; 2
    19aa:	09 c0       	rjmp	.+18     	; 0x19be <TCP_ProcessTCPPacket+0x3ac>
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    19ac:	d7 01       	movw	r26, r14
    19ae:	18 96       	adiw	r26, 0x08	; 8
    19b0:	2d 91       	ld	r18, X+
    19b2:	3c 91       	ld	r19, X
    19b4:	19 97       	sbiw	r26, 0x09	; 9
    19b6:	80 e0       	ldi	r24, 0x00	; 0
    19b8:	92 e0       	ldi	r25, 0x02	; 2
    19ba:	82 1b       	sub	r24, r18
    19bc:	93 0b       	sbc	r25, r19
    19be:	05 db       	rcall	.-2550   	; 0xfca <SwapEndian_16>
    19c0:	f8 01       	movw	r30, r16
    19c2:	97 87       	std	Z+15, r25	; 0x0f
    19c4:	86 87       	std	Z+14, r24	; 0x0e

		TCPHeaderOUT->UrgentPointer        = 0;
    19c6:	d8 01       	movw	r26, r16
    19c8:	53 96       	adiw	r26, 0x13	; 19
    19ca:	1c 92       	st	X, r1
    19cc:	1e 92       	st	-X, r1
    19ce:	52 97       	sbiw	r26, 0x12	; 18
		TCPHeaderOUT->Checksum             = 0;
    19d0:	51 96       	adiw	r26, 0x11	; 17
    19d2:	1c 92       	st	X, r1
    19d4:	1e 92       	st	-X, r1
    19d6:	50 97       	sbiw	r26, 0x10	; 16
		TCPHeaderOUT->Reserved             = 0;
    19d8:	1c 96       	adiw	r26, 0x0c	; 12
    19da:	8c 91       	ld	r24, X
    19dc:	1c 97       	sbiw	r26, 0x0c	; 12
    19de:	80 7f       	andi	r24, 0xF0	; 240
    19e0:	1c 96       	adiw	r26, 0x0c	; 12
    19e2:	8c 93       	st	X, r24

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    19e4:	b3 01       	movw	r22, r6
    19e6:	60 5f       	subi	r22, 0xF0	; 240
    19e8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ea:	c8 01       	movw	r24, r16
    19ec:	a5 01       	movw	r20, r10
    19ee:	24 e1       	ldi	r18, 0x14	; 20
    19f0:	30 e0       	ldi	r19, 0x00	; 0
    19f2:	ef da       	rcall	.-2594   	; 0xfd2 <TCP_Checksum16>
    19f4:	f8 01       	movw	r30, r16
    19f6:	91 8b       	std	Z+17, r25	; 0x11
    19f8:	80 8b       	std	Z+16, r24	; 0x10
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    19fa:	24 e1       	ldi	r18, 0x14	; 20
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	05 c0       	rjmp	.+10     	; 0x1a0a <TCP_ProcessTCPPacket+0x3f8>
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    1a00:	2f ef       	ldi	r18, 0xFF	; 255
    1a02:	3f ef       	ldi	r19, 0xFF	; 255
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <TCP_ProcessTCPPacket+0x3f8>
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    1a06:	20 e0       	ldi	r18, 0x00	; 0
    1a08:	30 e0       	ldi	r19, 0x00	; 0
}
    1a0a:	c9 01       	movw	r24, r18
    1a0c:	0f 90       	pop	r0
    1a0e:	cf 91       	pop	r28
    1a10:	df 91       	pop	r29
    1a12:	1f 91       	pop	r17
    1a14:	0f 91       	pop	r16
    1a16:	ff 90       	pop	r15
    1a18:	ef 90       	pop	r14
    1a1a:	df 90       	pop	r13
    1a1c:	cf 90       	pop	r12
    1a1e:	bf 90       	pop	r11
    1a20:	af 90       	pop	r10
    1a22:	9f 90       	pop	r9
    1a24:	8f 90       	pop	r8
    1a26:	7f 90       	pop	r7
    1a28:	6f 90       	pop	r6
    1a2a:	5f 90       	pop	r5
    1a2c:	4f 90       	pop	r4
    1a2e:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1a30:	d2 01       	movw	r26, r4
    1a32:	12 96       	adiw	r26, 0x02	; 2
    1a34:	cd 90       	ld	r12, X+
    1a36:	dc 90       	ld	r13, X
    1a38:	13 97       	sbiw	r26, 0x03	; 3
    1a3a:	6c e0       	ldi	r22, 0x0C	; 12
    1a3c:	a6 2e       	mov	r10, r22
    1a3e:	b1 2c       	mov	r11, r1
    1a40:	a6 0c       	add	r10, r6
    1a42:	b7 1c       	adc	r11, r7
    1a44:	4d 91       	ld	r20, X+
    1a46:	5c 91       	ld	r21, X
    1a48:	c6 01       	movw	r24, r12
    1a4a:	b5 01       	movw	r22, r10
    1a4c:	91 dd       	rcall	.-1246   	; 0x1570 <TCP_GetConnectionInfo>
    1a4e:	7c 01       	movw	r14, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1a50:	f8 01       	movw	r30, r16
    1a52:	d1 82       	std	Z+1, r13	; 0x01
    1a54:	c0 82       	st	Z, r12
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1a56:	d2 01       	movw	r26, r4
    1a58:	8d 91       	ld	r24, X+
    1a5a:	9c 91       	ld	r25, X
    1a5c:	93 83       	std	Z+3, r25	; 0x03
    1a5e:	82 83       	std	Z+2, r24	; 0x02
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1a60:	f7 01       	movw	r30, r14
    1a62:	64 81       	ldd	r22, Z+4	; 0x04
    1a64:	75 81       	ldd	r23, Z+5	; 0x05
    1a66:	86 81       	ldd	r24, Z+6	; 0x06
    1a68:	97 81       	ldd	r25, Z+7	; 0x07
    1a6a:	a9 da       	rcall	.-2734   	; 0xfbe <SwapEndian_32>
    1a6c:	d8 01       	movw	r26, r16
    1a6e:	14 96       	adiw	r26, 0x04	; 4
    1a70:	6d 93       	st	X+, r22
    1a72:	7d 93       	st	X+, r23
    1a74:	8d 93       	st	X+, r24
    1a76:	9c 93       	st	X, r25
    1a78:	17 97       	sbiw	r26, 0x07	; 7
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    1a7a:	f7 01       	movw	r30, r14
    1a7c:	60 81       	ld	r22, Z
    1a7e:	71 81       	ldd	r23, Z+1	; 0x01
    1a80:	82 81       	ldd	r24, Z+2	; 0x02
    1a82:	93 81       	ldd	r25, Z+3	; 0x03
    1a84:	9c da       	rcall	.-2760   	; 0xfbe <SwapEndian_32>
    1a86:	d8 01       	movw	r26, r16
    1a88:	18 96       	adiw	r26, 0x08	; 8
    1a8a:	6d 93       	st	X+, r22
    1a8c:	7d 93       	st	X+, r23
    1a8e:	8d 93       	st	X+, r24
    1a90:	9c 93       	st	X, r25
    1a92:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1a94:	1c 96       	adiw	r26, 0x0c	; 12
    1a96:	8c 91       	ld	r24, X
    1a98:	1c 97       	sbiw	r26, 0x0c	; 12
    1a9a:	8f 70       	andi	r24, 0x0F	; 15
    1a9c:	80 65       	ori	r24, 0x50	; 80
    1a9e:	1c 96       	adiw	r26, 0x0c	; 12
    1aa0:	8c 93       	st	X, r24
    1aa2:	1c 97       	sbiw	r26, 0x0c	; 12

		if (!(ConnectionInfo->Buffer.InUse))
    1aa4:	f7 01       	movw	r30, r14
    1aa6:	e4 5f       	subi	r30, 0xF4	; 244
    1aa8:	fd 4f       	sbci	r31, 0xFD	; 253
    1aaa:	80 81       	ld	r24, Z
    1aac:	88 23       	and	r24, r24
    1aae:	09 f4       	brne	.+2      	; 0x1ab2 <TCP_ProcessTCPPacket+0x4a0>
    1ab0:	7a cf       	rjmp	.-268    	; 0x19a6 <TCP_ProcessTCPPacket+0x394>
    1ab2:	7c cf       	rjmp	.-264    	; 0x19ac <TCP_ProcessTCPPacket+0x39a>

00001ab4 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
    1ab4:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
    1ab6:	89 2f       	mov	r24, r25
    1ab8:	92 2f       	mov	r25, r18
    1aba:	08 95       	ret

00001abc <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    1abc:	ef 92       	push	r14
    1abe:	ff 92       	push	r15
    1ac0:	0f 93       	push	r16
    1ac2:	1f 93       	push	r17
    1ac4:	cf 93       	push	r28
    1ac6:	df 93       	push	r29
    1ac8:	7c 01       	movw	r14, r24
    1aca:	eb 01       	movw	r28, r22
    1acc:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1ace:	cb 01       	movw	r24, r22
    1ad0:	0e 94 b6 04 	call	0x96c	; 0x96c <DecodeUDPHeader>

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad8:	ed df       	rcall	.-38     	; 0x1ab4 <SwapEndian_16>
    1ada:	83 34       	cpi	r24, 0x43	; 67
    1adc:	91 05       	cpc	r25, r1
    1ade:	f1 f4       	brne	.+60     	; 0x1b1c <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1ae0:	be 01       	movw	r22, r28
    1ae2:	68 5f       	subi	r22, 0xF8	; 248
    1ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae6:	a8 01       	movw	r20, r16
    1ae8:	48 5f       	subi	r20, 0xF8	; 248
    1aea:	5f 4f       	sbci	r21, 0xFF	; 255
    1aec:	c7 01       	movw	r24, r14
    1aee:	20 d0       	rcall	.+64     	; 0x1b30 <DHCP_ProcessDHCPPacket>
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1af0:	18 16       	cp	r1, r24
    1af2:	19 06       	cpc	r1, r25
    1af4:	9c f4       	brge	.+38     	; 0x1b1c <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1af6:	2a 81       	ldd	r18, Y+2	; 0x02
    1af8:	3b 81       	ldd	r19, Y+3	; 0x03
    1afa:	f8 01       	movw	r30, r16
    1afc:	31 83       	std	Z+1, r19	; 0x01
    1afe:	20 83       	st	Z, r18
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1b00:	28 81       	ld	r18, Y
    1b02:	39 81       	ldd	r19, Y+1	; 0x01
    1b04:	33 83       	std	Z+3, r19	; 0x03
    1b06:	22 83       	std	Z+2, r18	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    1b08:	17 82       	std	Z+7, r1	; 0x07
    1b0a:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1b0c:	ec 01       	movw	r28, r24
    1b0e:	28 96       	adiw	r28, 0x08	; 8
    1b10:	ce 01       	movw	r24, r28
    1b12:	d0 df       	rcall	.-96     	; 0x1ab4 <SwapEndian_16>
    1b14:	f8 01       	movw	r30, r16
    1b16:	95 83       	std	Z+5, r25	; 0x05
    1b18:	84 83       	std	Z+4, r24	; 0x04

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1b1a:	02 c0       	rjmp	.+4      	; 0x1b20 <UDP_ProcessUDPPacket+0x64>
	}

	return NO_RESPONSE;
    1b1c:	c0 e0       	ldi	r28, 0x00	; 0
    1b1e:	d0 e0       	ldi	r29, 0x00	; 0
}
    1b20:	ce 01       	movw	r24, r28
    1b22:	df 91       	pop	r29
    1b24:	cf 91       	pop	r28
    1b26:	1f 91       	pop	r17
    1b28:	0f 91       	pop	r16
    1b2a:	ff 90       	pop	r15
    1b2c:	ef 90       	pop	r14
    1b2e:	08 95       	ret

00001b30 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1b30:	8f 92       	push	r8
    1b32:	9f 92       	push	r9
    1b34:	af 92       	push	r10
    1b36:	bf 92       	push	r11
    1b38:	cf 92       	push	r12
    1b3a:	df 92       	push	r13
    1b3c:	ef 92       	push	r14
    1b3e:	ff 92       	push	r15
    1b40:	0f 93       	push	r16
    1b42:	1f 93       	push	r17
    1b44:	cf 93       	push	r28
    1b46:	df 93       	push	r29
    1b48:	8b 01       	movw	r16, r22
    1b4a:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    1b4c:	4c 01       	movw	r8, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    1b4e:	80 ef       	ldi	r24, 0xF0	; 240
    1b50:	e8 2e       	mov	r14, r24
    1b52:	f1 2c       	mov	r15, r1
    1b54:	e6 0e       	add	r14, r22
    1b56:	f7 1e       	adc	r15, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1b58:	cb 01       	movw	r24, r22
    1b5a:	0e 94 b7 04 	call	0x96e	; 0x96e <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    1b5e:	6e 01       	movw	r12, r28
    1b60:	ec 2f       	mov	r30, r28
    1b62:	fd 2d       	mov	r31, r13
    1b64:	80 ef       	ldi	r24, 0xF0	; 240
    1b66:	df 01       	movw	r26, r30
    1b68:	1d 92       	st	X+, r1
    1b6a:	8a 95       	dec	r24
    1b6c:	e9 f7       	brne	.-6      	; 0x1b68 <DHCP_ProcessDHCPPacket+0x38>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1b6e:	f8 01       	movw	r30, r16
    1b70:	81 81       	ldd	r24, Z+1	; 0x01
    1b72:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1b74:	82 e0       	ldi	r24, 0x02	; 2
    1b76:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    1b78:	82 81       	ldd	r24, Z+2	; 0x02
    1b7a:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    1b7c:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    1b7e:	84 81       	ldd	r24, Z+4	; 0x04
    1b80:	95 81       	ldd	r25, Z+5	; 0x05
    1b82:	a6 81       	ldd	r26, Z+6	; 0x06
    1b84:	b7 81       	ldd	r27, Z+7	; 0x07
    1b86:	8c 83       	std	Y+4, r24	; 0x04
    1b88:	9d 83       	std	Y+5, r25	; 0x05
    1b8a:	ae 83       	std	Y+6, r26	; 0x06
    1b8c:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    1b8e:	19 86       	std	Y+9, r1	; 0x09
    1b90:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1b92:	82 85       	ldd	r24, Z+10	; 0x0a
    1b94:	93 85       	ldd	r25, Z+11	; 0x0b
    1b96:	9b 87       	std	Y+11, r25	; 0x0b
    1b98:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    1b9a:	a0 90 1c 01 	lds	r10, 0x011C
    1b9e:	b0 90 1d 01 	lds	r11, 0x011D
    1ba2:	c0 90 1e 01 	lds	r12, 0x011E
    1ba6:	d0 90 1f 01 	lds	r13, 0x011F
    1baa:	a8 8a       	std	Y+16, r10	; 0x10
    1bac:	b9 8a       	std	Y+17, r11	; 0x11
    1bae:	ca 8a       	std	Y+18, r12	; 0x12
    1bb0:	db 8a       	std	Y+19, r13	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1bb2:	b8 01       	movw	r22, r16
    1bb4:	64 5e       	subi	r22, 0xE4	; 228
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	ce 01       	movw	r24, r28
    1bba:	4c 96       	adiw	r24, 0x1c	; 28
    1bbc:	46 e0       	ldi	r20, 0x06	; 6
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	f6 d7       	rcall	.+4076   	; 0x2bae <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1bc2:	fe 01       	movw	r30, r28
    1bc4:	e4 51       	subi	r30, 0x14	; 20
    1bc6:	ff 4f       	sbci	r31, 0xFF	; 255
    1bc8:	83 e6       	ldi	r24, 0x63	; 99
    1bca:	92 e8       	ldi	r25, 0x82	; 130
    1bcc:	a3 e5       	ldi	r26, 0x53	; 83
    1bce:	b3 e6       	ldi	r27, 0x63	; 99
    1bd0:	80 83       	st	Z, r24
    1bd2:	91 83       	std	Z+1, r25	; 0x01
    1bd4:	a2 83       	std	Z+2, r26	; 0x02
    1bd6:	b3 83       	std	Z+3, r27	; 0x03

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1bd8:	d4 01       	movw	r26, r8
    1bda:	1c 96       	adiw	r26, 0x0c	; 12
    1bdc:	ad 92       	st	X+, r10
    1bde:	bd 92       	st	X+, r11
    1be0:	cd 92       	st	X+, r12
    1be2:	dc 92       	st	X, r13
    1be4:	1f 97       	sbiw	r26, 0x0f	; 15
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1be6:	80 91 0e 01 	lds	r24, 0x010E
    1bea:	90 91 0f 01 	lds	r25, 0x010F
    1bee:	a0 91 10 01 	lds	r26, 0x0110
    1bf2:	b0 91 11 01 	lds	r27, 0x0111
    1bf6:	f4 01       	movw	r30, r8
    1bf8:	80 8b       	std	Z+16, r24	; 0x10
    1bfa:	91 8b       	std	Z+17, r25	; 0x11
    1bfc:	a2 8b       	std	Z+18, r26	; 0x12
    1bfe:	b3 8b       	std	Z+19, r27	; 0x13

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1c00:	59 c0       	rjmp	.+178    	; 0x1cb4 <DHCP_ProcessDHCPPacket+0x184>
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1c02:	85 33       	cpi	r24, 0x35	; 53
    1c04:	09 f0       	breq	.+2      	; 0x1c08 <DHCP_ProcessDHCPPacket+0xd8>
    1c06:	49 c0       	rjmp	.+146    	; 0x1c9a <DHCP_ProcessDHCPPacket+0x16a>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1c08:	d7 01       	movw	r26, r14
    1c0a:	12 96       	adiw	r26, 0x02	; 2
    1c0c:	f7 01       	movw	r30, r14
    1c0e:	82 81       	ldd	r24, Z+2	; 0x02
    1c10:	81 30       	cpi	r24, 0x01	; 1
    1c12:	19 f0       	breq	.+6      	; 0x1c1a <DHCP_ProcessDHCPPacket+0xea>
    1c14:	83 30       	cpi	r24, 0x03	; 3
    1c16:	09 f0       	breq	.+2      	; 0x1c1a <DHCP_ProcessDHCPPacket+0xea>
    1c18:	42 c0       	rjmp	.+132    	; 0x1c9e <DHCP_ProcessDHCPPacket+0x16e>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    1c1a:	c0 51       	subi	r28, 0x10	; 16
    1c1c:	df 4f       	sbci	r29, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1c1e:	fe 01       	movw	r30, r28
    1c20:	85 e3       	ldi	r24, 0x35	; 53
    1c22:	81 93       	st	Z+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1c24:	81 e0       	ldi	r24, 0x01	; 1
    1c26:	89 83       	std	Y+1, r24	; 0x01
    1c28:	ef 01       	movw	r28, r30
    1c2a:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1c2c:	8c 91       	ld	r24, X
    1c2e:	81 30       	cpi	r24, 0x01	; 1
    1c30:	11 f4       	brne	.+4      	; 0x1c36 <DHCP_ProcessDHCPPacket+0x106>
    1c32:	82 e0       	ldi	r24, 0x02	; 2
    1c34:	01 c0       	rjmp	.+2      	; 0x1c38 <DHCP_ProcessDHCPPacket+0x108>
    1c36:	85 e0       	ldi	r24, 0x05	; 5
    1c38:	81 83       	std	Z+1, r24	; 0x01
    1c3a:	de 01       	movw	r26, r28
    1c3c:	11 96       	adiw	r26, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	89 83       	std	Y+1, r24	; 0x01
    1c42:	fd 01       	movw	r30, r26
    1c44:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    1c46:	84 e0       	ldi	r24, 0x04	; 4
    1c48:	11 96       	adiw	r26, 0x01	; 1
    1c4a:	8c 93       	st	X, r24
    1c4c:	df 01       	movw	r26, r30
    1c4e:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1c50:	2f ef       	ldi	r18, 0xFF	; 255
    1c52:	21 83       	std	Z+1, r18	; 0x01
    1c54:	fd 01       	movw	r30, r26
    1c56:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1c58:	11 96       	adiw	r26, 0x01	; 1
    1c5a:	2c 93       	st	X, r18
    1c5c:	df 01       	movw	r26, r30
    1c5e:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1c60:	21 83       	std	Z+1, r18	; 0x01
    1c62:	fd 01       	movw	r30, r26
    1c64:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    1c66:	11 96       	adiw	r26, 0x01	; 1
    1c68:	1c 92       	st	X, r1
    1c6a:	df 01       	movw	r26, r30
    1c6c:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1c6e:	96 e3       	ldi	r25, 0x36	; 54
    1c70:	91 83       	std	Z+1, r25	; 0x01
    1c72:	fd 01       	movw	r30, r26
    1c74:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1c76:	11 96       	adiw	r26, 0x01	; 1
    1c78:	8c 93       	st	X, r24
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    1c7a:	80 91 0e 01 	lds	r24, 0x010E
    1c7e:	90 91 0f 01 	lds	r25, 0x010F
    1c82:	a0 91 10 01 	lds	r26, 0x0110
    1c86:	b0 91 11 01 	lds	r27, 0x0111
    1c8a:	81 83       	std	Z+1, r24	; 0x01
    1c8c:	92 83       	std	Z+2, r25	; 0x02
    1c8e:	a3 83       	std	Z+3, r26	; 0x03
    1c90:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1c92:	25 83       	std	Z+5, r18	; 0x05

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	31 e0       	ldi	r19, 0x01	; 1
    1c98:	14 c0       	rjmp	.+40     	; 0x1cc2 <DHCP_ProcessDHCPPacket+0x192>
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    1c9a:	88 23       	and	r24, r24
    1c9c:	39 f0       	breq	.+14     	; 0x1cac <DHCP_ProcessDHCPPacket+0x17c>
    1c9e:	d7 01       	movw	r26, r14
    1ca0:	11 96       	adiw	r26, 0x01	; 1
    1ca2:	8c 91       	ld	r24, X
    1ca4:	11 97       	sbiw	r26, 0x01	; 1
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	02 96       	adiw	r24, 0x02	; 2
    1caa:	02 c0       	rjmp	.+4      	; 0x1cb0 <DHCP_ProcessDHCPPacket+0x180>
    1cac:	81 e0       	ldi	r24, 0x01	; 1
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	e8 0e       	add	r14, r24
    1cb2:	f9 1e       	adc	r15, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1cb4:	f7 01       	movw	r30, r14
    1cb6:	80 81       	ld	r24, Z
    1cb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cba:	09 f0       	breq	.+2      	; 0x1cbe <DHCP_ProcessDHCPPacket+0x18e>
    1cbc:	a2 cf       	rjmp	.-188    	; 0x1c02 <DHCP_ProcessDHCPPacket+0xd2>

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
    1cbe:	20 e0       	ldi	r18, 0x00	; 0
    1cc0:	30 e0       	ldi	r19, 0x00	; 0
}
    1cc2:	c9 01       	movw	r24, r18
    1cc4:	df 91       	pop	r29
    1cc6:	cf 91       	pop	r28
    1cc8:	1f 91       	pop	r17
    1cca:	0f 91       	pop	r16
    1ccc:	ff 90       	pop	r15
    1cce:	ef 90       	pop	r14
    1cd0:	df 90       	pop	r13
    1cd2:	cf 90       	pop	r12
    1cd4:	bf 90       	pop	r11
    1cd6:	af 90       	pop	r10
    1cd8:	9f 90       	pop	r9
    1cda:	8f 90       	pop	r8
    1cdc:	08 95       	ret

00001cde <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
    1cde:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
    1ce0:	89 2f       	mov	r24, r25
    1ce2:	92 2f       	mov	r25, r18
    1ce4:	08 95       	ret

00001ce6 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1ce6:	cf 92       	push	r12
    1ce8:	df 92       	push	r13
    1cea:	ef 92       	push	r14
    1cec:	ff 92       	push	r15
    1cee:	0f 93       	push	r16
    1cf0:	1f 93       	push	r17
    1cf2:	cf 93       	push	r28
    1cf4:	df 93       	push	r29
    1cf6:	18 2f       	mov	r17, r24
    1cf8:	09 2f       	mov	r16, r25
    1cfa:	7b 01       	movw	r14, r22
	DecodeARPHeader(InDataStart);
    1cfc:	0e 94 b2 04 	call	0x964	; 0x964 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1d00:	c1 2e       	mov	r12, r17
    1d02:	e6 01       	movw	r28, r12
    1d04:	6e 01       	movw	r12, r28
    1d06:	d0 2e       	mov	r13, r16
    1d08:	e6 01       	movw	r28, r12
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d0e:	e7 df       	rcall	.-50     	; 0x1cde <SwapEndian_16>
    1d10:	e8 e0       	ldi	r30, 0x08	; 8
    1d12:	80 30       	cpi	r24, 0x00	; 0
    1d14:	9e 07       	cpc	r25, r30
    1d16:	09 f0       	breq	.+2      	; 0x1d1a <ARP_ProcessARPPacket+0x34>
    1d18:	59 c0       	rjmp	.+178    	; 0x1dcc <ARP_ProcessARPPacket+0xe6>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
    1d1a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d1c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d1e:	df df       	rcall	.-66     	; 0x1cde <SwapEndian_16>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1d20:	81 30       	cpi	r24, 0x01	; 1
    1d22:	91 05       	cpc	r25, r1
    1d24:	09 f0       	breq	.+2      	; 0x1d28 <ARP_ProcessARPPacket+0x42>
    1d26:	52 c0       	rjmp	.+164    	; 0x1dcc <ARP_ProcessARPPacket+0xe6>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1d28:	c6 01       	movw	r24, r12
    1d2a:	48 96       	adiw	r24, 0x18	; 24
    1d2c:	6e e0       	ldi	r22, 0x0E	; 14
    1d2e:	71 e0       	ldi	r23, 0x01	; 1
    1d30:	44 e0       	ldi	r20, 0x04	; 4
    1d32:	50 e0       	ldi	r21, 0x00	; 0
    1d34:	26 d7       	rcall	.+3660   	; 0x2b82 <memcmp>
    1d36:	00 97       	sbiw	r24, 0x00	; 0
    1d38:	51 f0       	breq	.+20     	; 0x1d4e <ARP_ProcessARPPacket+0x68>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    1d3a:	c6 01       	movw	r24, r12
    1d3c:	42 96       	adiw	r24, 0x12	; 18
    1d3e:	68 e0       	ldi	r22, 0x08	; 8
    1d40:	71 e0       	ldi	r23, 0x01	; 1
    1d42:	46 e0       	ldi	r20, 0x06	; 6
    1d44:	50 e0       	ldi	r21, 0x00	; 0
    1d46:	1d d7       	rcall	.+3642   	; 0x2b82 <memcmp>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1d48:	00 97       	sbiw	r24, 0x00	; 0
    1d4a:	09 f0       	breq	.+2      	; 0x1d4e <ARP_ProcessARPPacket+0x68>
    1d4c:	3f c0       	rjmp	.+126    	; 0x1dcc <ARP_ProcessARPPacket+0xe6>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1d4e:	87 01       	movw	r16, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1d50:	88 81       	ld	r24, Y
    1d52:	99 81       	ldd	r25, Y+1	; 0x01
    1d54:	f7 01       	movw	r30, r14
    1d56:	91 83       	std	Z+1, r25	; 0x01
    1d58:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1d5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d5e:	93 83       	std	Z+3, r25	; 0x03
    1d60:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1d62:	8c 81       	ldd	r24, Y+4	; 0x04
    1d64:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1d66:	8d 81       	ldd	r24, Y+5	; 0x05
    1d68:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1d6a:	82 e0       	ldi	r24, 0x02	; 2
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	b7 df       	rcall	.-146    	; 0x1cde <SwapEndian_16>
    1d70:	f7 01       	movw	r30, r14
    1d72:	97 83       	std	Z+7, r25	; 0x07
    1d74:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1d76:	d7 01       	movw	r26, r14
    1d78:	52 96       	adiw	r26, 0x12	; 18
    1d7a:	fe 01       	movw	r30, r28
    1d7c:	38 96       	adiw	r30, 0x08	; 8
    1d7e:	86 e0       	ldi	r24, 0x06	; 6
    1d80:	01 90       	ld	r0, Z+
    1d82:	0d 92       	st	X+, r0
    1d84:	81 50       	subi	r24, 0x01	; 1
    1d86:	e1 f7       	brne	.-8      	; 0x1d80 <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1d88:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d8a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d8c:	a8 89       	ldd	r26, Y+16	; 0x10
    1d8e:	b9 89       	ldd	r27, Y+17	; 0x11
    1d90:	f8 01       	movw	r30, r16
    1d92:	80 8f       	std	Z+24, r24	; 0x18
    1d94:	91 8f       	std	Z+25, r25	; 0x19
    1d96:	a2 8f       	std	Z+26, r26	; 0x1a
    1d98:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1d9a:	d8 01       	movw	r26, r16
    1d9c:	18 96       	adiw	r26, 0x08	; 8
    1d9e:	e8 e0       	ldi	r30, 0x08	; 8
    1da0:	f1 e0       	ldi	r31, 0x01	; 1
    1da2:	86 e0       	ldi	r24, 0x06	; 6
    1da4:	01 90       	ld	r0, Z+
    1da6:	0d 92       	st	X+, r0
    1da8:	81 50       	subi	r24, 0x01	; 1
    1daa:	e1 f7       	brne	.-8      	; 0x1da4 <ARP_ProcessARPPacket+0xbe>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1dac:	80 91 0e 01 	lds	r24, 0x010E
    1db0:	90 91 0f 01 	lds	r25, 0x010F
    1db4:	a0 91 10 01 	lds	r26, 0x0110
    1db8:	b0 91 11 01 	lds	r27, 0x0111
    1dbc:	f8 01       	movw	r30, r16
    1dbe:	86 87       	std	Z+14, r24	; 0x0e
    1dc0:	97 87       	std	Z+15, r25	; 0x0f
    1dc2:	a0 8b       	std	Z+16, r26	; 0x10
    1dc4:	b1 8b       	std	Z+17, r27	; 0x11

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1dc6:	2c e1       	ldi	r18, 0x1C	; 28
    1dc8:	30 e0       	ldi	r19, 0x00	; 0
    1dca:	02 c0       	rjmp	.+4      	; 0x1dd0 <ARP_ProcessARPPacket+0xea>
		}
	}

	return NO_RESPONSE;
    1dcc:	20 e0       	ldi	r18, 0x00	; 0
    1dce:	30 e0       	ldi	r19, 0x00	; 0
}
    1dd0:	c9 01       	movw	r24, r18
    1dd2:	df 91       	pop	r29
    1dd4:	cf 91       	pop	r28
    1dd6:	1f 91       	pop	r17
    1dd8:	0f 91       	pop	r16
    1dda:	ff 90       	pop	r15
    1ddc:	ef 90       	pop	r14
    1dde:	df 90       	pop	r13
    1de0:	cf 90       	pop	r12
    1de2:	08 95       	ret

00001de4 <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1de4:	df 92       	push	r13
    1de6:	ef 92       	push	r14
    1de8:	ff 92       	push	r15
    1dea:	0f 93       	push	r16
    1dec:	1f 93       	push	r17
    1dee:	cf 93       	push	r28
    1df0:	df 93       	push	r29
    1df2:	8c 01       	movw	r16, r24
    1df4:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1df6:	0e 94 b3 04 	call	0x966	; 0x966 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1dfa:	f8 01       	movw	r30, r16
    1dfc:	d0 80       	ld	r13, Z
    1dfe:	ff e0       	ldi	r31, 0x0F	; 15
    1e00:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1e02:	20 e1       	ldi	r18, 0x10	; 16
    1e04:	e2 2e       	mov	r14, r18
    1e06:	f1 2c       	mov	r15, r1
    1e08:	e0 0e       	add	r14, r16
    1e0a:	f1 1e       	adc	r15, r17
    1e0c:	c7 01       	movw	r24, r14
    1e0e:	6e e0       	ldi	r22, 0x0E	; 14
    1e10:	71 e0       	ldi	r23, 0x01	; 1
    1e12:	44 e0       	ldi	r20, 0x04	; 4
    1e14:	50 e0       	ldi	r21, 0x00	; 0
    1e16:	b5 d6       	rcall	.+3434   	; 0x2b82 <memcmp>
    1e18:	00 97       	sbiw	r24, 0x00	; 0
    1e1a:	49 f0       	breq	.+18     	; 0x1e2e <IP_ProcessIPPacket+0x4a>
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    1e1c:	c7 01       	movw	r24, r14
    1e1e:	68 e1       	ldi	r22, 0x18	; 24
    1e20:	71 e0       	ldi	r23, 0x01	; 1
    1e22:	44 e0       	ldi	r20, 0x04	; 4
    1e24:	50 e0       	ldi	r21, 0x00	; 0
    1e26:	ad d6       	rcall	.+3418   	; 0x2b82 <memcmp>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1e28:	00 97       	sbiw	r24, 0x00	; 0
    1e2a:	09 f0       	breq	.+2      	; 0x1e2e <IP_ProcessIPPacket+0x4a>
    1e2c:	59 c0       	rjmp	.+178    	; 0x1ee0 <IP_ProcessIPPacket+0xfc>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1e2e:	6d 2d       	mov	r22, r13
    1e30:	70 e0       	ldi	r23, 0x00	; 0
    1e32:	66 0f       	add	r22, r22
    1e34:	77 1f       	adc	r23, r23
    1e36:	66 0f       	add	r22, r22
    1e38:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1e3a:	f8 01       	movw	r30, r16
    1e3c:	81 85       	ldd	r24, Z+9	; 0x09
    1e3e:	86 30       	cpi	r24, 0x06	; 6
    1e40:	71 f0       	breq	.+28     	; 0x1e5e <IP_ProcessIPPacket+0x7a>
    1e42:	81 31       	cpi	r24, 0x11	; 17
    1e44:	a1 f0       	breq	.+40     	; 0x1e6e <IP_ProcessIPPacket+0x8a>
    1e46:	81 30       	cpi	r24, 0x01	; 1
    1e48:	09 f0       	breq	.+2      	; 0x1e4c <IP_ProcessIPPacket+0x68>
    1e4a:	4a c0       	rjmp	.+148    	; 0x1ee0 <IP_ProcessIPPacket+0xfc>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1e4c:	9e 01       	movw	r18, r28
    1e4e:	2c 5e       	subi	r18, 0xEC	; 236
    1e50:	3f 4f       	sbci	r19, 0xFF	; 255
    1e52:	c8 01       	movw	r24, r16
    1e54:	86 0f       	add	r24, r22
    1e56:	97 1f       	adc	r25, r23
    1e58:	b9 01       	movw	r22, r18
    1e5a:	73 d8       	rcall	.-3866   	; 0xf42 <ICMP_ProcessICMPPacket>
    1e5c:	0f c0       	rjmp	.+30     	; 0x1e7c <IP_ProcessIPPacket+0x98>
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1e5e:	60 0f       	add	r22, r16
    1e60:	71 1f       	adc	r23, r17
    1e62:	ae 01       	movw	r20, r28
    1e64:	4c 5e       	subi	r20, 0xEC	; 236
    1e66:	5f 4f       	sbci	r21, 0xFF	; 255
    1e68:	c8 01       	movw	r24, r16
    1e6a:	d3 db       	rcall	.-2138   	; 0x1612 <TCP_ProcessTCPPacket>
    1e6c:	07 c0       	rjmp	.+14     	; 0x1e7c <IP_ProcessIPPacket+0x98>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1e6e:	60 0f       	add	r22, r16
    1e70:	71 1f       	adc	r23, r17
    1e72:	ae 01       	movw	r20, r28
    1e74:	4c 5e       	subi	r20, 0xEC	; 236
    1e76:	5f 4f       	sbci	r21, 0xFF	; 255
    1e78:	c8 01       	movw	r24, r16
    1e7a:	20 de       	rcall	.-960    	; 0x1abc <UDP_ProcessUDPPacket>
    1e7c:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1e7e:	18 16       	cp	r1, r24
    1e80:	19 06       	cpc	r1, r25
    1e82:	84 f5       	brge	.+96     	; 0x1ee4 <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1e84:	84 e1       	ldi	r24, 0x14	; 20
    1e86:	e8 2e       	mov	r14, r24
    1e88:	f1 2c       	mov	r15, r1
    1e8a:	e2 0e       	add	r14, r18
    1e8c:	f3 1e       	adc	r15, r19
    1e8e:	fa 82       	std	Y+2, r15	; 0x02
    1e90:	eb 82       	std	Y+3, r14	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    1e92:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1e94:	85 e4       	ldi	r24, 0x45	; 69
    1e96:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1e98:	1e 82       	std	Y+6, r1	; 0x06
    1e9a:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1e9c:	1d 82       	std	Y+5, r1	; 0x05
    1e9e:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    1ea0:	1b 86       	std	Y+11, r1	; 0x0b
    1ea2:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1ea4:	f8 01       	movw	r30, r16
    1ea6:	81 85       	ldd	r24, Z+9	; 0x09
    1ea8:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1eaa:	80 e8       	ldi	r24, 0x80	; 128
    1eac:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1eae:	80 89       	ldd	r24, Z+16	; 0x10
    1eb0:	91 89       	ldd	r25, Z+17	; 0x11
    1eb2:	a2 89       	ldd	r26, Z+18	; 0x12
    1eb4:	b3 89       	ldd	r27, Z+19	; 0x13
    1eb6:	8c 87       	std	Y+12, r24	; 0x0c
    1eb8:	9d 87       	std	Y+13, r25	; 0x0d
    1eba:	ae 87       	std	Y+14, r26	; 0x0e
    1ebc:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1ebe:	84 85       	ldd	r24, Z+12	; 0x0c
    1ec0:	95 85       	ldd	r25, Z+13	; 0x0d
    1ec2:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ec4:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ec6:	88 8b       	std	Y+16, r24	; 0x10
    1ec8:	99 8b       	std	Y+17, r25	; 0x11
    1eca:	aa 8b       	std	Y+18, r26	; 0x12
    1ecc:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1ece:	ce 01       	movw	r24, r28
    1ed0:	64 e1       	ldi	r22, 0x14	; 20
    1ed2:	70 e0       	ldi	r23, 0x00	; 0
    1ed4:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <Ethernet_Checksum16>
    1ed8:	9b 87       	std	Y+11, r25	; 0x0b
    1eda:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1edc:	97 01       	movw	r18, r14
    1ede:	02 c0       	rjmp	.+4      	; 0x1ee4 <IP_ProcessIPPacket+0x100>
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    1ee0:	20 e0       	ldi	r18, 0x00	; 0
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    1ee4:	c9 01       	movw	r24, r18
    1ee6:	df 91       	pop	r29
    1ee8:	cf 91       	pop	r28
    1eea:	1f 91       	pop	r17
    1eec:	0f 91       	pop	r16
    1eee:	ff 90       	pop	r15
    1ef0:	ef 90       	pop	r14
    1ef2:	df 90       	pop	r13
    1ef4:	08 95       	ret

00001ef6 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1ef6:	db 01       	movw	r26, r22
    1ef8:	0d 90       	ld	r0, X+
    1efa:	00 20       	and	r0, r0
    1efc:	e9 f7       	brne	.-6      	; 0x1ef8 <IsHTTPCommand+0x2>
    1efe:	ad 01       	movw	r20, r26
    1f00:	41 50       	subi	r20, 0x01	; 1
    1f02:	50 40       	sbci	r21, 0x00	; 0
    1f04:	46 1b       	sub	r20, r22
    1f06:	57 0b       	sbc	r21, r23
    1f08:	63 d6       	rcall	.+3270   	; 0x2bd0 <strncmp>
    1f0a:	9c 01       	movw	r18, r24
    1f0c:	81 e0       	ldi	r24, 0x01	; 1
    1f0e:	21 15       	cp	r18, r1
    1f10:	31 05       	cpc	r19, r1
    1f12:	09 f0       	breq	.+2      	; 0x1f16 <IsHTTPCommand+0x20>
    1f14:	80 e0       	ldi	r24, 0x00	; 0
}
    1f16:	08 95       	ret

00001f18 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1f18:	8f 92       	push	r8
    1f1a:	9f 92       	push	r9
    1f1c:	af 92       	push	r10
    1f1e:	bf 92       	push	r11
    1f20:	cf 92       	push	r12
    1f22:	df 92       	push	r13
    1f24:	ef 92       	push	r14
    1f26:	ff 92       	push	r15
    1f28:	0f 93       	push	r16
    1f2a:	1f 93       	push	r17
    1f2c:	df 93       	push	r29
    1f2e:	cf 93       	push	r28
    1f30:	00 d0       	rcall	.+0      	; 0x1f32 <Webserver_ApplicationCallback+0x1a>
    1f32:	cd b7       	in	r28, 0x3d	; 61
    1f34:	de b7       	in	r29, 0x3e	; 62
    1f36:	5c 01       	movw	r10, r24
    1f38:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1f3a:	42 e0       	ldi	r20, 0x02	; 2
    1f3c:	84 2e       	mov	r8, r20
    1f3e:	91 2c       	mov	r9, r1
    1f40:	86 0e       	add	r8, r22
    1f42:	97 1e       	adc	r9, r23
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1f44:	33 e0       	ldi	r19, 0x03	; 3
    1f46:	e3 2e       	mov	r14, r19
    1f48:	32 e0       	ldi	r19, 0x02	; 2
    1f4a:	f3 2e       	mov	r15, r19
    1f4c:	e6 0e       	add	r14, r22
    1f4e:	f7 1e       	adc	r15, r23
    1f50:	d7 01       	movw	r26, r14
    1f52:	8c 91       	ld	r24, X
    1f54:	88 23       	and	r24, r24
    1f56:	09 f4       	brne	.+2      	; 0x1f5a <Webserver_ApplicationCallback+0x42>
    1f58:	65 c0       	rjmp	.+202    	; 0x2024 <Webserver_ApplicationCallback+0x10c>
    1f5a:	22 e0       	ldi	r18, 0x02	; 2
    1f5c:	c2 2e       	mov	r12, r18
    1f5e:	d2 2e       	mov	r13, r18
    1f60:	c6 0e       	add	r12, r22
    1f62:	d7 1e       	adc	r13, r23
    1f64:	f6 01       	movw	r30, r12
    1f66:	80 81       	ld	r24, Z
    1f68:	88 23       	and	r24, r24
    1f6a:	09 f0       	breq	.+2      	; 0x1f6e <Webserver_ApplicationCallback+0x56>
    1f6c:	a2 c0       	rjmp	.+324    	; 0x20b2 <Webserver_ApplicationCallback+0x19a>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1f6e:	c4 01       	movw	r24, r8
    1f70:	68 e2       	ldi	r22, 0x28	; 40
    1f72:	71 e0       	ldi	r23, 0x01	; 1
    1f74:	c0 df       	rcall	.-128    	; 0x1ef6 <IsHTTPCommand>
    1f76:	88 23       	and	r24, r24
    1f78:	01 f1       	breq	.+64     	; 0x1fba <Webserver_ApplicationCallback+0xa2>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1f7a:	c4 01       	movw	r24, r8
    1f7c:	6c e2       	ldi	r22, 0x2C	; 44
    1f7e:	71 e0       	ldi	r23, 0x01	; 1
    1f80:	ba df       	rcall	.-140    	; 0x1ef6 <IsHTTPCommand>
    1f82:	88 23       	and	r24, r24
    1f84:	51 f1       	breq	.+84     	; 0x1fda <Webserver_ApplicationCallback+0xc2>
			{
				PageBlock = 0;
    1f86:	10 92 4c 01 	sts	0x014C, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1f8a:	c4 01       	movw	r24, r8
    1f8c:	65 eb       	ldi	r22, 0xB5	; 181
    1f8e:	71 e0       	ldi	r23, 0x01	; 1
    1f90:	d9 d5       	rcall	.+2994   	; 0x2b44 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	d6 01       	movw	r26, r12
    1f96:	8c 93       	st	X, r24
    1f98:	f4 01       	movw	r30, r8
    1f9a:	01 90       	ld	r0, Z+
    1f9c:	00 20       	and	r0, r0
    1f9e:	e9 f7       	brne	.-6      	; 0x1f9a <Webserver_ApplicationCallback+0x82>
    1fa0:	31 97       	sbiw	r30, 0x01	; 1
    1fa2:	e8 19       	sub	r30, r8
    1fa4:	f9 09       	sbc	r31, r9
    1fa6:	d8 01       	movw	r26, r16
    1fa8:	11 96       	adiw	r26, 0x01	; 1
    1faa:	fc 93       	st	X, r31
    1fac:	ee 93       	st	-X, r30
    1fae:	f7 01       	movw	r30, r14
    1fb0:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1fb2:	f8 01       	movw	r30, r16
    1fb4:	ec 5f       	subi	r30, 0xFC	; 252
    1fb6:	fd 4f       	sbci	r31, 0xFD	; 253
    1fb8:	7b c0       	rjmp	.+246    	; 0x20b0 <Webserver_ApplicationCallback+0x198>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1fba:	c4 01       	movw	r24, r8
    1fbc:	63 e3       	ldi	r22, 0x33	; 51
    1fbe:	71 e0       	ldi	r23, 0x01	; 1
    1fc0:	9a df       	rcall	.-204    	; 0x1ef6 <IsHTTPCommand>
    1fc2:	88 23       	and	r24, r24
    1fc4:	e9 f0       	breq	.+58     	; 0x2000 <Webserver_ApplicationCallback+0xe8>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1fc6:	c4 01       	movw	r24, r8
    1fc8:	68 e3       	ldi	r22, 0x38	; 56
    1fca:	71 e0       	ldi	r23, 0x01	; 1
    1fcc:	94 df       	rcall	.-216    	; 0x1ef6 <IsHTTPCommand>
    1fce:	88 23       	and	r24, r24
    1fd0:	21 f0       	breq	.+8      	; 0x1fda <Webserver_ApplicationCallback+0xc2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1fd2:	c4 01       	movw	r24, r8
    1fd4:	65 eb       	ldi	r22, 0xB5	; 181
    1fd6:	71 e0       	ldi	r23, 0x01	; 1
    1fd8:	03 c0       	rjmp	.+6      	; 0x1fe0 <Webserver_ApplicationCallback+0xc8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1fda:	c4 01       	movw	r24, r8
    1fdc:	69 e0       	ldi	r22, 0x09	; 9
    1fde:	72 e0       	ldi	r23, 0x02	; 2
    1fe0:	b1 d5       	rcall	.+2914   	; 0x2b44 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	d6 01       	movw	r26, r12
    1fe6:	8c 93       	st	X, r24
    1fe8:	f4 01       	movw	r30, r8
    1fea:	01 90       	ld	r0, Z+
    1fec:	00 20       	and	r0, r0
    1fee:	e9 f7       	brne	.-6      	; 0x1fea <Webserver_ApplicationCallback+0xd2>
    1ff0:	31 97       	sbiw	r30, 0x01	; 1
    1ff2:	e8 19       	sub	r30, r8
    1ff4:	f9 09       	sbc	r31, r9
    1ff6:	d8 01       	movw	r26, r16
    1ff8:	11 96       	adiw	r26, 0x01	; 1
    1ffa:	fc 93       	st	X, r31
    1ffc:	ee 93       	st	-X, r30
    1ffe:	09 c0       	rjmp	.+18     	; 0x2012 <Webserver_ApplicationCallback+0xfa>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    2000:	c4 01       	movw	r24, r8
    2002:	60 e4       	ldi	r22, 0x40	; 64
    2004:	71 e0       	ldi	r23, 0x01	; 1
    2006:	77 df       	rcall	.-274    	; 0x1ef6 <IsHTTPCommand>
    2008:	88 23       	and	r24, r24
    200a:	31 f0       	breq	.+12     	; 0x2018 <Webserver_ApplicationCallback+0x100>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	d6 01       	movw	r26, r12
    2010:	8c 93       	st	X, r24
    2012:	f7 01       	movw	r30, r14
    2014:	80 83       	st	Z, r24
    2016:	48 c0       	rjmp	.+144    	; 0x20a8 <Webserver_ApplicationCallback+0x190>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    2018:	d7 01       	movw	r26, r14
    201a:	1c 92       	st	X, r1
    201c:	f8 01       	movw	r30, r16
    201e:	11 82       	std	Z+1, r1	; 0x01
    2020:	10 82       	st	Z, r1
    2022:	47 c0       	rjmp	.+142    	; 0x20b2 <Webserver_ApplicationCallback+0x19a>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    2024:	fb 01       	movw	r30, r22
    2026:	ec 5f       	subi	r30, 0xFC	; 252
    2028:	fd 4f       	sbci	r31, 0xFD	; 253
    202a:	80 81       	ld	r24, Z
    202c:	88 23       	and	r24, r24
    202e:	09 f4       	brne	.+2      	; 0x2032 <Webserver_ApplicationCallback+0x11a>
    2030:	40 c0       	rjmp	.+128    	; 0x20b2 <Webserver_ApplicationCallback+0x19a>
    2032:	fb 01       	movw	r30, r22
    2034:	ee 5f       	subi	r30, 0xFE	; 254
    2036:	fd 4f       	sbci	r31, 0xFD	; 253
    2038:	80 81       	ld	r24, Z
    203a:	88 23       	and	r24, r24
    203c:	d1 f1       	breq	.+116    	; 0x20b2 <Webserver_ApplicationCallback+0x19a>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    203e:	60 91 4c 01 	lds	r22, 0x014C
    2042:	70 e0       	ldi	r23, 0x00	; 0
    2044:	76 95       	lsr	r23
    2046:	76 2f       	mov	r23, r22
    2048:	66 27       	eor	r22, r22
    204a:	77 95       	ror	r23
    204c:	67 95       	ror	r22
    204e:	65 5b       	subi	r22, 0xB5	; 181
    2050:	7d 4f       	sbci	r23, 0xFD	; 253
    2052:	cb 01       	movw	r24, r22
    2054:	69 83       	std	Y+1, r22	; 0x01
    2056:	7a 83       	std	Y+2, r23	; 0x02
    2058:	7c d5       	rcall	.+2808   	; 0x2b52 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    205a:	e8 2e       	mov	r14, r24
    205c:	f9 2e       	mov	r15, r25
    205e:	69 81       	ldd	r22, Y+1	; 0x01
    2060:	7a 81       	ldd	r23, Y+2	; 0x02
    2062:	f1 e8       	ldi	r31, 0x81	; 129
    2064:	ef 16       	cp	r14, r31
    2066:	f1 04       	cpc	r15, r1
    2068:	18 f0       	brcs	.+6      	; 0x2070 <Webserver_ApplicationCallback+0x158>
    206a:	80 e8       	ldi	r24, 0x80	; 128
    206c:	e8 2e       	mov	r14, r24
    206e:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    2070:	c4 01       	movw	r24, r8
    2072:	a7 01       	movw	r20, r14
    2074:	77 d5       	rcall	.+2798   	; 0x2b64 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    2076:	f8 01       	movw	r30, r16
    2078:	ee 5f       	subi	r30, 0xFE	; 254
    207a:	fd 4f       	sbci	r31, 0xFD	; 253
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	80 83       	st	Z, r24
    2080:	d8 01       	movw	r26, r16
    2082:	11 96       	adiw	r26, 0x01	; 1
    2084:	fc 92       	st	X, r15
    2086:	ee 92       	st	-X, r14
    2088:	f8 01       	movw	r30, r16
    208a:	ed 5f       	subi	r30, 0xFD	; 253
    208c:	fd 4f       	sbci	r31, 0xFD	; 253
    208e:	80 83       	st	Z, r24

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    2090:	80 91 4c 01 	lds	r24, 0x014C
    2094:	98 2f       	mov	r25, r24
    2096:	9f 5f       	subi	r25, 0xFF	; 255
    2098:	90 93 4c 01 	sts	0x014C, r25
    209c:	83 30       	cpi	r24, 0x03	; 3
    209e:	49 f4       	brne	.+18     	; 0x20b2 <Webserver_ApplicationCallback+0x19a>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    20a0:	f8 01       	movw	r30, r16
    20a2:	ec 5f       	subi	r30, 0xFC	; 252
    20a4:	fd 4f       	sbci	r31, 0xFD	; 253
    20a6:	10 82       	st	Z, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    20a8:	f5 01       	movw	r30, r10
    20aa:	eb 5e       	subi	r30, 0xEB	; 235
    20ac:	fd 4f       	sbci	r31, 0xFD	; 253
    20ae:	87 e0       	ldi	r24, 0x07	; 7
    20b0:	80 83       	st	Z, r24
		}
	}
}
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	cf 91       	pop	r28
    20b8:	df 91       	pop	r29
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	bf 90       	pop	r11
    20c8:	af 90       	pop	r10
    20ca:	9f 90       	pop	r9
    20cc:	8f 90       	pop	r8
    20ce:	08 95       	ret

000020d0 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    20d0:	80 e0       	ldi	r24, 0x00	; 0
    20d2:	90 e5       	ldi	r25, 0x50	; 80
    20d4:	61 e0       	ldi	r22, 0x01	; 1
    20d6:	4c e8       	ldi	r20, 0x8C	; 140
    20d8:	5f e0       	ldi	r21, 0x0F	; 15
}
    20da:	52 c9       	rjmp	.-3420   	; 0x1380 <TCP_SetPortState>

000020dc <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    20dc:	8f 92       	push	r8
    20de:	9f 92       	push	r9
    20e0:	bf 92       	push	r11
    20e2:	cf 92       	push	r12
    20e4:	df 92       	push	r13
    20e6:	ef 92       	push	r14
    20e8:	ff 92       	push	r15
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	df 93       	push	r29
    20f0:	cf 93       	push	r28
    20f2:	0f 92       	push	r0
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
    20f8:	e8 2e       	mov	r14, r24
    20fa:	4b 01       	movw	r8, r22
    20fc:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    20fe:	99 83       	std	Y+1, r25	; 0x01
    2100:	fe d1       	rcall	.+1020   	; 0x24fe <Endpoint_WaitUntilReady>
    2102:	b8 2e       	mov	r11, r24
    2104:	99 81       	ldd	r25, Y+1	; 0x01
    2106:	88 23       	and	r24, r24
    2108:	c9 f5       	brne	.+114    	; 0x217c <__stack+0x7d>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    210a:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    210c:	01 15       	cp	r16, r1
    210e:	11 05       	cpc	r17, r1
    2110:	39 f0       	breq	.+14     	; 0x2120 <__stack+0x21>
	{
		Length -= *BytesProcessed;
    2112:	f8 01       	movw	r30, r16
    2114:	20 81       	ld	r18, Z
    2116:	31 81       	ldd	r19, Z+1	; 0x01
    2118:	82 1a       	sub	r8, r18
    211a:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    211c:	e2 0e       	add	r14, r18
    211e:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2120:	cc 24       	eor	r12, r12
    2122:	dd 24       	eor	r13, r13
    2124:	26 c0       	rjmp	.+76     	; 0x2172 <__stack+0x73>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2126:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    212a:	85 fd       	sbrc	r24, 5
    212c:	17 c0       	rjmp	.+46     	; 0x215c <__stack+0x5d>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    212e:	80 91 e8 00 	lds	r24, 0x00E8
    2132:	8e 77       	andi	r24, 0x7E	; 126
    2134:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2138:	a7 d4       	rcall	.+2382   	; 0x2a88 <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    213a:	01 15       	cp	r16, r1
    213c:	11 05       	cpc	r17, r1
    213e:	51 f0       	breq	.+20     	; 0x2154 <__stack+0x55>
			{
				*BytesProcessed += BytesInTransfer;
    2140:	f8 01       	movw	r30, r16
    2142:	80 81       	ld	r24, Z
    2144:	91 81       	ldd	r25, Z+1	; 0x01
    2146:	8c 0d       	add	r24, r12
    2148:	9d 1d       	adc	r25, r13
    214a:	91 83       	std	Z+1, r25	; 0x01
    214c:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    214e:	25 e0       	ldi	r18, 0x05	; 5
    2150:	b2 2e       	mov	r11, r18
    2152:	14 c0       	rjmp	.+40     	; 0x217c <__stack+0x7d>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2154:	d4 d1       	rcall	.+936    	; 0x24fe <Endpoint_WaitUntilReady>
    2156:	88 23       	and	r24, r24
    2158:	61 f0       	breq	.+24     	; 0x2172 <__stack+0x73>
    215a:	0f c0       	rjmp	.+30     	; 0x217a <__stack+0x7b>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    215c:	f7 01       	movw	r30, r14
    215e:	81 91       	ld	r24, Z+
    2160:	7f 01       	movw	r14, r30
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2162:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2166:	08 94       	sec
    2168:	81 08       	sbc	r8, r1
    216a:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    216c:	08 94       	sec
    216e:	c1 1c       	adc	r12, r1
    2170:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    2172:	81 14       	cp	r8, r1
    2174:	91 04       	cpc	r9, r1
    2176:	b9 f6       	brne	.-82     	; 0x2126 <__stack+0x27>
    2178:	01 c0       	rjmp	.+2      	; 0x217c <__stack+0x7d>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    217a:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    217c:	8b 2d       	mov	r24, r11
    217e:	0f 90       	pop	r0
    2180:	cf 91       	pop	r28
    2182:	df 91       	pop	r29
    2184:	1f 91       	pop	r17
    2186:	0f 91       	pop	r16
    2188:	ff 90       	pop	r15
    218a:	ef 90       	pop	r14
    218c:	df 90       	pop	r13
    218e:	cf 90       	pop	r12
    2190:	bf 90       	pop	r11
    2192:	9f 90       	pop	r9
    2194:	8f 90       	pop	r8
    2196:	08 95       	ret

00002198 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2198:	8f 92       	push	r8
    219a:	9f 92       	push	r9
    219c:	bf 92       	push	r11
    219e:	cf 92       	push	r12
    21a0:	df 92       	push	r13
    21a2:	ef 92       	push	r14
    21a4:	ff 92       	push	r15
    21a6:	0f 93       	push	r16
    21a8:	1f 93       	push	r17
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	0f 92       	push	r0
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	e8 2e       	mov	r14, r24
    21b6:	4b 01       	movw	r8, r22
    21b8:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    21ba:	99 83       	std	Y+1, r25	; 0x01
    21bc:	a0 d1       	rcall	.+832    	; 0x24fe <Endpoint_WaitUntilReady>
    21be:	b8 2e       	mov	r11, r24
    21c0:	99 81       	ldd	r25, Y+1	; 0x01
    21c2:	88 23       	and	r24, r24
    21c4:	c9 f5       	brne	.+114    	; 0x2238 <Endpoint_Read_Stream_LE+0xa0>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    21c6:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    21c8:	01 15       	cp	r16, r1
    21ca:	11 05       	cpc	r17, r1
    21cc:	39 f0       	breq	.+14     	; 0x21dc <Endpoint_Read_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
    21ce:	f8 01       	movw	r30, r16
    21d0:	20 81       	ld	r18, Z
    21d2:	31 81       	ldd	r19, Z+1	; 0x01
    21d4:	82 1a       	sub	r8, r18
    21d6:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    21d8:	e2 0e       	add	r14, r18
    21da:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    21dc:	cc 24       	eor	r12, r12
    21de:	dd 24       	eor	r13, r13
    21e0:	26 c0       	rjmp	.+76     	; 0x222e <Endpoint_Read_Stream_LE+0x96>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    21e2:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    21e6:	85 fd       	sbrc	r24, 5
    21e8:	17 c0       	rjmp	.+46     	; 0x2218 <Endpoint_Read_Stream_LE+0x80>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    21ea:	80 91 e8 00 	lds	r24, 0x00E8
    21ee:	8b 77       	andi	r24, 0x7B	; 123
    21f0:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    21f4:	49 d4       	rcall	.+2194   	; 0x2a88 <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    21f6:	01 15       	cp	r16, r1
    21f8:	11 05       	cpc	r17, r1
    21fa:	51 f0       	breq	.+20     	; 0x2210 <Endpoint_Read_Stream_LE+0x78>
			{
				*BytesProcessed += BytesInTransfer;
    21fc:	f8 01       	movw	r30, r16
    21fe:	80 81       	ld	r24, Z
    2200:	91 81       	ldd	r25, Z+1	; 0x01
    2202:	8c 0d       	add	r24, r12
    2204:	9d 1d       	adc	r25, r13
    2206:	91 83       	std	Z+1, r25	; 0x01
    2208:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    220a:	45 e0       	ldi	r20, 0x05	; 5
    220c:	b4 2e       	mov	r11, r20
    220e:	14 c0       	rjmp	.+40     	; 0x2238 <Endpoint_Read_Stream_LE+0xa0>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2210:	76 d1       	rcall	.+748    	; 0x24fe <Endpoint_WaitUntilReady>
    2212:	88 23       	and	r24, r24
    2214:	61 f0       	breq	.+24     	; 0x222e <Endpoint_Read_Stream_LE+0x96>
    2216:	0f c0       	rjmp	.+30     	; 0x2236 <Endpoint_Read_Stream_LE+0x9e>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2218:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    221c:	f7 01       	movw	r30, r14
    221e:	81 93       	st	Z+, r24
    2220:	7f 01       	movw	r14, r30
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2222:	08 94       	sec
    2224:	81 08       	sbc	r8, r1
    2226:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    2228:	08 94       	sec
    222a:	c1 1c       	adc	r12, r1
    222c:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    222e:	81 14       	cp	r8, r1
    2230:	91 04       	cpc	r9, r1
    2232:	b9 f6       	brne	.-82     	; 0x21e2 <Endpoint_Read_Stream_LE+0x4a>
    2234:	01 c0       	rjmp	.+2      	; 0x2238 <Endpoint_Read_Stream_LE+0xa0>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2236:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2238:	8b 2d       	mov	r24, r11
    223a:	0f 90       	pop	r0
    223c:	cf 91       	pop	r28
    223e:	df 91       	pop	r29
    2240:	1f 91       	pop	r17
    2242:	0f 91       	pop	r16
    2244:	ff 90       	pop	r15
    2246:	ef 90       	pop	r14
    2248:	df 90       	pop	r13
    224a:	cf 90       	pop	r12
    224c:	bf 90       	pop	r11
    224e:	9f 90       	pop	r9
    2250:	8f 90       	pop	r8
    2252:	08 95       	ret

00002254 <Endpoint_Write_Control_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2254:	28 2f       	mov	r18, r24
    2256:	39 2f       	mov	r19, r25
    2258:	f9 01       	movw	r30, r18
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    225a:	80 91 df 13 	lds	r24, 0x13DF
    225e:	90 91 e0 13 	lds	r25, 0x13E0
    2262:	86 17       	cp	r24, r22
    2264:	97 07       	cpc	r25, r23
    2266:	18 f4       	brcc	.+6      	; 0x226e <Endpoint_Write_Control_Stream_LE+0x1a>
    2268:	bc 01       	movw	r22, r24
    226a:	20 e0       	ldi	r18, 0x00	; 0
    226c:	37 c0       	rjmp	.+110    	; 0x22dc <Endpoint_Write_Control_Stream_LE+0x88>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    226e:	61 15       	cp	r22, r1
    2270:	71 05       	cpc	r23, r1
    2272:	d9 f7       	brne	.-10     	; 0x226a <Endpoint_Write_Control_Stream_LE+0x16>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2274:	80 91 e8 00 	lds	r24, 0x00E8
    2278:	8e 77       	andi	r24, 0x7E	; 126
    227a:	80 93 e8 00 	sts	0x00E8, r24
    227e:	f5 cf       	rjmp	.-22     	; 0x226a <Endpoint_Write_Control_Stream_LE+0x16>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2280:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2284:	88 23       	and	r24, r24
    2286:	09 f4       	brne	.+2      	; 0x228a <Endpoint_Write_Control_Stream_LE+0x36>
    2288:	3f c0       	rjmp	.+126    	; 0x2308 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    228a:	85 30       	cpi	r24, 0x05	; 5
    228c:	c9 f1       	breq	.+114    	; 0x2300 <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    228e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2292:	83 fd       	sbrc	r24, 3
    2294:	37 c0       	rjmp	.+110    	; 0x2304 <Endpoint_Write_Control_Stream_LE+0xb0>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2296:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    229a:	82 fd       	sbrc	r24, 2
    229c:	2b c0       	rjmp	.+86     	; 0x22f4 <Endpoint_Write_Control_Stream_LE+0xa0>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    229e:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    22a2:	80 ff       	sbrs	r24, 0
    22a4:	1b c0       	rjmp	.+54     	; 0x22dc <Endpoint_Write_Control_Stream_LE+0x88>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    22a6:	80 91 f2 00 	lds	r24, 0x00F2
    22aa:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    22ae:	06 c0       	rjmp	.+12     	; 0x22bc <Endpoint_Write_Control_Stream_LE+0x68>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    22b0:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    22b2:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    22b6:	61 50       	subi	r22, 0x01	; 1
    22b8:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    22ba:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    22bc:	61 15       	cp	r22, r1
    22be:	71 05       	cpc	r23, r1
    22c0:	19 f0       	breq	.+6      	; 0x22c8 <Endpoint_Write_Control_Stream_LE+0x74>
    22c2:	88 30       	cpi	r24, 0x08	; 8
    22c4:	91 05       	cpc	r25, r1
    22c6:	a0 f3       	brcs	.-24     	; 0x22b0 <Endpoint_Write_Control_Stream_LE+0x5c>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    22c8:	21 e0       	ldi	r18, 0x01	; 1
    22ca:	88 30       	cpi	r24, 0x08	; 8
    22cc:	91 05       	cpc	r25, r1
    22ce:	09 f0       	breq	.+2      	; 0x22d2 <Endpoint_Write_Control_Stream_LE+0x7e>
    22d0:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    22d2:	80 91 e8 00 	lds	r24, 0x00E8
    22d6:	8e 77       	andi	r24, 0x7E	; 126
    22d8:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    22dc:	61 15       	cp	r22, r1
    22de:	71 05       	cpc	r23, r1
    22e0:	79 f6       	brne	.-98     	; 0x2280 <Endpoint_Write_Control_Stream_LE+0x2c>
    22e2:	22 23       	and	r18, r18
    22e4:	69 f6       	brne	.-102    	; 0x2280 <Endpoint_Write_Control_Stream_LE+0x2c>
    22e6:	06 c0       	rjmp	.+12     	; 0x22f4 <Endpoint_Write_Control_Stream_LE+0xa0>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    22e8:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    22ec:	88 23       	and	r24, r24
    22ee:	61 f0       	breq	.+24     	; 0x2308 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    22f0:	85 30       	cpi	r24, 0x05	; 5
    22f2:	61 f0       	breq	.+24     	; 0x230c <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    22f4:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    22f8:	82 ff       	sbrs	r24, 2
    22fa:	f6 cf       	rjmp	.-20     	; 0x22e8 <Endpoint_Write_Control_Stream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2300:	83 e0       	ldi	r24, 0x03	; 3
    2302:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2308:	82 e0       	ldi	r24, 0x02	; 2
    230a:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    230c:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    230e:	08 95       	ret

00002310 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    2310:	61 15       	cp	r22, r1
    2312:	71 05       	cpc	r23, r1
    2314:	31 f5       	brne	.+76     	; 0x2362 <Endpoint_Read_Control_Stream_LE+0x52>
    2316:	20 c0       	rjmp	.+64     	; 0x2358 <Endpoint_Read_Control_Stream_LE+0x48>
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2318:	20 91 d8 13 	lds	r18, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    231c:	22 23       	and	r18, r18
    231e:	a9 f1       	breq	.+106    	; 0x238a <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2320:	25 30       	cpi	r18, 0x05	; 5
    2322:	79 f1       	breq	.+94     	; 0x2382 <Endpoint_Read_Control_Stream_LE+0x72>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2324:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2328:	23 fd       	sbrc	r18, 3
    232a:	2d c0       	rjmp	.+90     	; 0x2386 <Endpoint_Read_Control_Stream_LE+0x76>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    232c:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2330:	22 ff       	sbrs	r18, 2
    2332:	f2 cf       	rjmp	.-28     	; 0x2318 <Endpoint_Read_Control_Stream_LE+0x8>
    2334:	e8 2f       	mov	r30, r24
    2336:	f9 2f       	mov	r31, r25
    2338:	07 c0       	rjmp	.+14     	; 0x2348 <Endpoint_Read_Control_Stream_LE+0x38>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    233a:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    233e:	81 93       	st	Z+, r24
    2340:	cf 01       	movw	r24, r30
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    2342:	61 50       	subi	r22, 0x01	; 1
    2344:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2346:	41 f0       	breq	.+16     	; 0x2358 <Endpoint_Read_Control_Stream_LE+0x48>
    2348:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    234a:	20 91 f2 00 	lds	r18, 0x00F2
    234e:	30 91 f3 00 	lds	r19, 0x00F3
    2352:	21 15       	cp	r18, r1
    2354:	31 05       	cpc	r19, r1
    2356:	89 f7       	brne	.-30     	; 0x233a <Endpoint_Read_Control_Stream_LE+0x2a>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2358:	20 91 e8 00 	lds	r18, 0x00E8
    235c:	2b 77       	andi	r18, 0x7B	; 123
    235e:	20 93 e8 00 	sts	0x00E8, r18
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    2362:	61 15       	cp	r22, r1
    2364:	71 05       	cpc	r23, r1
    2366:	c1 f6       	brne	.-80     	; 0x2318 <Endpoint_Read_Control_Stream_LE+0x8>
    2368:	06 c0       	rjmp	.+12     	; 0x2376 <Endpoint_Read_Control_Stream_LE+0x66>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    236a:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    236e:	88 23       	and	r24, r24
    2370:	61 f0       	breq	.+24     	; 0x238a <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2372:	85 30       	cpi	r24, 0x05	; 5
    2374:	61 f0       	breq	.+24     	; 0x238e <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2376:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    237a:	80 ff       	sbrs	r24, 0
    237c:	f6 cf       	rjmp	.-20     	; 0x236a <Endpoint_Read_Control_Stream_LE+0x5a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    237e:	80 e0       	ldi	r24, 0x00	; 0
    2380:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2382:	83 e0       	ldi	r24, 0x03	; 3
    2384:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2386:	81 e0       	ldi	r24, 0x01	; 1
    2388:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    238a:	82 e0       	ldi	r24, 0x02	; 2
    238c:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    238e:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2390:	08 95       	ret

00002392 <Endpoint_Write_Control_PStream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2392:	e8 2f       	mov	r30, r24
    2394:	f9 2f       	mov	r31, r25
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2396:	80 91 df 13 	lds	r24, 0x13DF
    239a:	90 91 e0 13 	lds	r25, 0x13E0
    239e:	86 17       	cp	r24, r22
    23a0:	97 07       	cpc	r25, r23
    23a2:	18 f4       	brcc	.+6      	; 0x23aa <Endpoint_Write_Control_PStream_LE+0x18>
    23a4:	bc 01       	movw	r22, r24
    23a6:	20 e0       	ldi	r18, 0x00	; 0
    23a8:	38 c0       	rjmp	.+112    	; 0x241a <Endpoint_Write_Control_PStream_LE+0x88>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    23aa:	61 15       	cp	r22, r1
    23ac:	71 05       	cpc	r23, r1
    23ae:	d9 f7       	brne	.-10     	; 0x23a6 <Endpoint_Write_Control_PStream_LE+0x14>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23b0:	80 91 e8 00 	lds	r24, 0x00E8
    23b4:	8e 77       	andi	r24, 0x7E	; 126
    23b6:	80 93 e8 00 	sts	0x00E8, r24
    23ba:	f5 cf       	rjmp	.-22     	; 0x23a6 <Endpoint_Write_Control_PStream_LE+0x14>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    23bc:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    23c0:	88 23       	and	r24, r24
    23c2:	09 f4       	brne	.+2      	; 0x23c6 <Endpoint_Write_Control_PStream_LE+0x34>
    23c4:	40 c0       	rjmp	.+128    	; 0x2446 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23c6:	85 30       	cpi	r24, 0x05	; 5
    23c8:	d1 f1       	breq	.+116    	; 0x243e <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    23ca:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    23ce:	83 fd       	sbrc	r24, 3
    23d0:	38 c0       	rjmp	.+112    	; 0x2442 <Endpoint_Write_Control_PStream_LE+0xb0>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    23d2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    23d6:	82 fd       	sbrc	r24, 2
    23d8:	2c c0       	rjmp	.+88     	; 0x2432 <Endpoint_Write_Control_PStream_LE+0xa0>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    23da:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    23de:	80 ff       	sbrs	r24, 0
    23e0:	1c c0       	rjmp	.+56     	; 0x241a <Endpoint_Write_Control_PStream_LE+0x88>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    23e2:	80 91 f2 00 	lds	r24, 0x00F2
    23e6:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    23ea:	07 c0       	rjmp	.+14     	; 0x23fa <Endpoint_Write_Control_PStream_LE+0x68>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    23ec:	24 91       	lpm	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    23ee:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    23f2:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    23f4:	61 50       	subi	r22, 0x01	; 1
    23f6:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    23f8:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    23fa:	61 15       	cp	r22, r1
    23fc:	71 05       	cpc	r23, r1
    23fe:	19 f0       	breq	.+6      	; 0x2406 <Endpoint_Write_Control_PStream_LE+0x74>
    2400:	88 30       	cpi	r24, 0x08	; 8
    2402:	91 05       	cpc	r25, r1
    2404:	98 f3       	brcs	.-26     	; 0x23ec <Endpoint_Write_Control_PStream_LE+0x5a>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2406:	21 e0       	ldi	r18, 0x01	; 1
    2408:	88 30       	cpi	r24, 0x08	; 8
    240a:	91 05       	cpc	r25, r1
    240c:	09 f0       	breq	.+2      	; 0x2410 <Endpoint_Write_Control_PStream_LE+0x7e>
    240e:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2410:	80 91 e8 00 	lds	r24, 0x00E8
    2414:	8e 77       	andi	r24, 0x7E	; 126
    2416:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    241a:	61 15       	cp	r22, r1
    241c:	71 05       	cpc	r23, r1
    241e:	71 f6       	brne	.-100    	; 0x23bc <Endpoint_Write_Control_PStream_LE+0x2a>
    2420:	22 23       	and	r18, r18
    2422:	61 f6       	brne	.-104    	; 0x23bc <Endpoint_Write_Control_PStream_LE+0x2a>
    2424:	06 c0       	rjmp	.+12     	; 0x2432 <Endpoint_Write_Control_PStream_LE+0xa0>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2426:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    242a:	88 23       	and	r24, r24
    242c:	61 f0       	breq	.+24     	; 0x2446 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    242e:	85 30       	cpi	r24, 0x05	; 5
    2430:	61 f0       	breq	.+24     	; 0x244a <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2432:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2436:	82 ff       	sbrs	r24, 2
    2438:	f6 cf       	rjmp	.-20     	; 0x2426 <Endpoint_Write_Control_PStream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    243a:	80 e0       	ldi	r24, 0x00	; 0
    243c:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    243e:	83 e0       	ldi	r24, 0x03	; 3
    2440:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    2446:	82 e0       	ldi	r24, 0x02	; 2
    2448:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    244a:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    244c:	08 95       	ret

0000244e <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    244e:	98 2f       	mov	r25, r24
    2450:	2c c0       	rjmp	.+88     	; 0x24aa <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2452:	29 2f       	mov	r18, r25
    2454:	2f 70       	andi	r18, 0x0F	; 15
    2456:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    245a:	98 17       	cp	r25, r24
    245c:	39 f0       	breq	.+14     	; 0x246c <Endpoint_ConfigureEndpoint_Prv+0x1e>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    245e:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    2462:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    2466:	50 91 f0 00 	lds	r21, 0x00F0
    246a:	03 c0       	rjmp	.+6      	; 0x2472 <Endpoint_ConfigureEndpoint_Prv+0x24>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    246c:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    246e:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    2470:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    2472:	21 ff       	sbrs	r18, 1
    2474:	19 c0       	rjmp	.+50     	; 0x24a8 <Endpoint_ConfigureEndpoint_Prv+0x5a>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    2476:	30 91 eb 00 	lds	r19, 0x00EB
    247a:	3e 7f       	andi	r19, 0xFE	; 254
    247c:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    2480:	30 91 ed 00 	lds	r19, 0x00ED
    2484:	3d 7f       	andi	r19, 0xFD	; 253
    2486:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    248a:	30 91 eb 00 	lds	r19, 0x00EB
    248e:	31 60       	ori	r19, 0x01	; 1
    2490:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    2494:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    2498:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    249c:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    24a0:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    24a4:	27 ff       	sbrs	r18, 7
    24a6:	08 c0       	rjmp	.+16     	; 0x24b8 <Endpoint_ConfigureEndpoint_Prv+0x6a>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    24a8:	9f 5f       	subi	r25, 0xFF	; 255
    24aa:	97 30       	cpi	r25, 0x07	; 7
    24ac:	90 f2       	brcs	.-92     	; 0x2452 <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    24ae:	8f 70       	andi	r24, 0x0F	; 15
    24b0:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    24b4:	81 e0       	ldi	r24, 0x01	; 1
    24b6:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    24b8:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    24ba:	08 95       	ret

000024bc <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    24bc:	80 91 d9 13 	lds	r24, 0x13D9
    24c0:	87 ff       	sbrs	r24, 7
    24c2:	13 c0       	rjmp	.+38     	; 0x24ea <Endpoint_ClearStatusStage+0x2e>
    24c4:	04 c0       	rjmp	.+8      	; 0x24ce <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    24c6:	80 91 d8 13 	lds	r24, 0x13D8
    24ca:	88 23       	and	r24, r24
    24cc:	b9 f0       	breq	.+46     	; 0x24fc <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    24ce:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    24d2:	82 ff       	sbrs	r24, 2
    24d4:	f8 cf       	rjmp	.-16     	; 0x24c6 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    24d6:	80 91 e8 00 	lds	r24, 0x00E8
    24da:	8b 77       	andi	r24, 0x7B	; 123
    24dc:	80 93 e8 00 	sts	0x00E8, r24
    24e0:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    24e2:	80 91 d8 13 	lds	r24, 0x13D8
    24e6:	88 23       	and	r24, r24
    24e8:	49 f0       	breq	.+18     	; 0x24fc <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    24ea:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    24ee:	80 ff       	sbrs	r24, 0
    24f0:	f8 cf       	rjmp	.-16     	; 0x24e2 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    24f2:	80 91 e8 00 	lds	r24, 0x00E8
    24f6:	8e 77       	andi	r24, 0x7E	; 126
    24f8:	80 93 e8 00 	sts	0x00E8, r24
    24fc:	08 95       	ret

000024fe <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    24fe:	80 91 e4 00 	lds	r24, 0x00E4
    2502:	90 91 e5 00 	lds	r25, 0x00E5

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    2506:	44 e6       	ldi	r20, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2508:	20 91 ec 00 	lds	r18, 0x00EC
    250c:	20 ff       	sbrs	r18, 0
    250e:	26 c0       	rjmp	.+76     	; 0x255c <Endpoint_WaitUntilReady+0x5e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2510:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    2514:	20 fd       	sbrc	r18, 0
    2516:	16 c0       	rjmp	.+44     	; 0x2544 <Endpoint_WaitUntilReady+0x46>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2518:	20 91 d8 13 	lds	r18, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    251c:	22 23       	and	r18, r18
    251e:	a1 f0       	breq	.+40     	; 0x2548 <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2520:	25 30       	cpi	r18, 0x05	; 5
    2522:	a1 f0       	breq	.+40     	; 0x254c <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2524:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    2528:	25 fd       	sbrc	r18, 5
    252a:	12 c0       	rjmp	.+36     	; 0x2550 <Endpoint_WaitUntilReady+0x52>
    252c:	20 91 e4 00 	lds	r18, 0x00E4
    2530:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    2534:	28 17       	cp	r18, r24
    2536:	39 07       	cpc	r19, r25
    2538:	39 f3       	breq	.-50     	; 0x2508 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    253a:	44 23       	and	r20, r20
    253c:	59 f0       	breq	.+22     	; 0x2554 <Endpoint_WaitUntilReady+0x56>
    253e:	41 50       	subi	r20, 0x01	; 1
    2540:	c9 01       	movw	r24, r18
    2542:	e2 cf       	rjmp	.-60     	; 0x2508 <Endpoint_WaitUntilReady+0xa>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    2544:	80 e0       	ldi	r24, 0x00	; 0
    2546:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    2548:	82 e0       	ldi	r24, 0x02	; 2
    254a:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    254c:	83 e0       	ldi	r24, 0x03	; 3
    254e:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    2554:	84 e0       	ldi	r24, 0x04	; 4
    2556:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    2558:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    255a:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    255c:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    2560:	22 ff       	sbrs	r18, 2
    2562:	da cf       	rjmp	.-76     	; 0x2518 <Endpoint_WaitUntilReady+0x1a>
    2564:	f9 cf       	rjmp	.-14     	; 0x2558 <Endpoint_WaitUntilReady+0x5a>

00002566 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    2566:	0f 93       	push	r16
    2568:	1f 93       	push	r17
    256a:	cf 93       	push	r28
    256c:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    256e:	4e d0       	rcall	.+156    	; 0x260c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2570:	55 d0       	rcall	.+170    	; 0x261c <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    2572:	c8 ed       	ldi	r28, 0xD8	; 216
    2574:	d0 e0       	ldi	r29, 0x00	; 0
    2576:	88 81       	ld	r24, Y
    2578:	8f 77       	andi	r24, 0x7F	; 127
    257a:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    257c:	88 81       	ld	r24, Y
    257e:	80 68       	ori	r24, 0x80	; 128
    2580:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2582:	88 81       	ld	r24, Y
    2584:	8f 7d       	andi	r24, 0xDF	; 223
    2586:	88 83       	st	Y, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    2588:	e7 ed       	ldi	r30, 0xD7	; 215
    258a:	f0 e0       	ldi	r31, 0x00	; 0
    258c:	80 81       	ld	r24, Z
    258e:	80 68       	ori	r24, 0x80	; 128
    2590:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2592:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    2594:	10 92 d8 13 	sts	0x13D8, r1
	USB_Device_ConfigurationNumber  = 0;
    2598:	10 92 d4 13 	sts	0x13D4, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    259c:	10 92 d6 13 	sts	0x13D6, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    25a0:	10 92 d5 13 	sts	0x13D5, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    25a4:	00 ee       	ldi	r16, 0xE0	; 224
    25a6:	10 e0       	ldi	r17, 0x00	; 0
    25a8:	f8 01       	movw	r30, r16
    25aa:	80 81       	ld	r24, Z
    25ac:	8b 7f       	andi	r24, 0xFB	; 251
    25ae:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    25b0:	88 81       	ld	r24, Y
    25b2:	81 60       	ori	r24, 0x01	; 1
    25b4:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    25b6:	80 e0       	ldi	r24, 0x00	; 0
    25b8:	60 e0       	ldi	r22, 0x00	; 0
    25ba:	42 e0       	ldi	r20, 0x02	; 2
    25bc:	48 df       	rcall	.-368    	; 0x244e <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    25be:	e1 ee       	ldi	r30, 0xE1	; 225
    25c0:	f0 e0       	ldi	r31, 0x00	; 0
    25c2:	80 81       	ld	r24, Z
    25c4:	8e 7f       	andi	r24, 0xFE	; 254
    25c6:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    25c8:	e2 ee       	ldi	r30, 0xE2	; 226
    25ca:	f0 e0       	ldi	r31, 0x00	; 0
    25cc:	80 81       	ld	r24, Z
    25ce:	81 60       	ori	r24, 0x01	; 1
    25d0:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    25d2:	80 81       	ld	r24, Z
    25d4:	88 60       	ori	r24, 0x08	; 8
    25d6:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    25d8:	f8 01       	movw	r30, r16
    25da:	80 81       	ld	r24, Z
    25dc:	8e 7f       	andi	r24, 0xFE	; 254
    25de:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    25e0:	88 81       	ld	r24, Y
    25e2:	80 61       	ori	r24, 0x10	; 16
    25e4:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    25e6:	df 91       	pop	r29
    25e8:	cf 91       	pop	r28
    25ea:	1f 91       	pop	r17
    25ec:	0f 91       	pop	r16
    25ee:	08 95       	ret

000025f0 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    25f0:	e8 ed       	ldi	r30, 0xD8	; 216
    25f2:	f0 e0       	ldi	r31, 0x00	; 0
    25f4:	80 81       	ld	r24, Z
    25f6:	8f 7e       	andi	r24, 0xEF	; 239
    25f8:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    25fa:	e7 ed       	ldi	r30, 0xD7	; 215
    25fc:	f0 e0       	ldi	r31, 0x00	; 0
    25fe:	80 81       	ld	r24, Z
    2600:	81 60       	ori	r24, 0x01	; 1
    2602:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	80 93 d7 13 	sts	0x13D7, r24

	USB_ResetInterface();
}
    260a:	ad cf       	rjmp	.-166    	; 0x2566 <USB_ResetInterface>

0000260c <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    260c:	e8 ed       	ldi	r30, 0xD8	; 216
    260e:	f0 e0       	ldi	r31, 0x00	; 0
    2610:	80 81       	ld	r24, Z
    2612:	8c 7f       	andi	r24, 0xFC	; 252
    2614:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    2616:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    261a:	08 95       	ret

0000261c <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    261c:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    2620:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    2624:	08 95       	ret

00002626 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    2626:	1f 92       	push	r1
    2628:	0f 92       	push	r0
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	0f 92       	push	r0
    262e:	0b b6       	in	r0, 0x3b	; 59
    2630:	0f 92       	push	r0
    2632:	11 24       	eor	r1, r1
    2634:	2f 93       	push	r18
    2636:	3f 93       	push	r19
    2638:	4f 93       	push	r20
    263a:	5f 93       	push	r21
    263c:	6f 93       	push	r22
    263e:	7f 93       	push	r23
    2640:	8f 93       	push	r24
    2642:	9f 93       	push	r25
    2644:	af 93       	push	r26
    2646:	bf 93       	push	r27
    2648:	ef 93       	push	r30
    264a:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    264c:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    2650:	82 ff       	sbrs	r24, 2
    2652:	0a c0       	rjmp	.+20     	; 0x2668 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    2654:	80 91 e2 00 	lds	r24, 0x00E2
    2658:	82 ff       	sbrs	r24, 2
    265a:	06 c0       	rjmp	.+12     	; 0x2668 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    265c:	80 91 e1 00 	lds	r24, 0x00E1
    2660:	8b 7f       	andi	r24, 0xFB	; 251
    2662:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    2666:	0f d2       	rcall	.+1054   	; 0x2a86 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    2668:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    266c:	80 ff       	sbrs	r24, 0
    266e:	1f c0       	rjmp	.+62     	; 0x26ae <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    2670:	80 91 d8 00 	lds	r24, 0x00D8
    2674:	80 ff       	sbrs	r24, 0
    2676:	1b c0       	rjmp	.+54     	; 0x26ae <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    2678:	80 91 da 00 	lds	r24, 0x00DA
    267c:	8e 7f       	andi	r24, 0xFE	; 254
    267e:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    2682:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    2686:	80 ff       	sbrs	r24, 0
    2688:	0d c0       	rjmp	.+26     	; 0x26a4 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    268a:	8c e0       	ldi	r24, 0x0C	; 12
    268c:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    268e:	8e e0       	ldi	r24, 0x0E	; 14
    2690:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    2692:	09 b4       	in	r0, 0x29	; 41
    2694:	00 fe       	sbrs	r0, 0
    2696:	fd cf       	rjmp	.-6      	; 0x2692 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    2698:	81 e0       	ldi	r24, 0x01	; 1
    269a:	80 93 d8 13 	sts	0x13D8, r24
			EVENT_USB_Device_Connect();
    269e:	0e 94 71 02 	call	0x4e2	; 0x4e2 <EVENT_USB_Device_Connect>
    26a2:	05 c0       	rjmp	.+10     	; 0x26ae <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    26a4:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    26a6:	10 92 d8 13 	sts	0x13D8, r1
			EVENT_USB_Device_Disconnect();
    26aa:	0e 94 73 02 	call	0x4e6	; 0x4e6 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    26ae:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    26b2:	80 ff       	sbrs	r24, 0
    26b4:	18 c0       	rjmp	.+48     	; 0x26e6 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    26b6:	80 91 e2 00 	lds	r24, 0x00E2
    26ba:	80 ff       	sbrs	r24, 0
    26bc:	14 c0       	rjmp	.+40     	; 0x26e6 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    26be:	80 91 e2 00 	lds	r24, 0x00E2
    26c2:	8e 7f       	andi	r24, 0xFE	; 254
    26c4:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    26c8:	80 91 e2 00 	lds	r24, 0x00E2
    26cc:	80 61       	ori	r24, 0x10	; 16
    26ce:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    26d2:	80 91 d8 00 	lds	r24, 0x00D8
    26d6:	80 62       	ori	r24, 0x20	; 32
    26d8:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    26dc:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    26de:	85 e0       	ldi	r24, 0x05	; 5
    26e0:	80 93 d8 13 	sts	0x13D8, r24
		EVENT_USB_Device_Suspend();
    26e4:	d0 d1       	rcall	.+928    	; 0x2a86 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    26e6:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    26ea:	84 ff       	sbrs	r24, 4
    26ec:	2d c0       	rjmp	.+90     	; 0x2748 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    26ee:	80 91 e2 00 	lds	r24, 0x00E2
    26f2:	84 ff       	sbrs	r24, 4
    26f4:	29 c0       	rjmp	.+82     	; 0x2748 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    26f6:	8c e0       	ldi	r24, 0x0C	; 12
    26f8:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    26fa:	8e e0       	ldi	r24, 0x0E	; 14
    26fc:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    26fe:	09 b4       	in	r0, 0x29	; 41
    2700:	00 fe       	sbrs	r0, 0
    2702:	fd cf       	rjmp	.-6      	; 0x26fe <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2704:	80 91 d8 00 	lds	r24, 0x00D8
    2708:	8f 7d       	andi	r24, 0xDF	; 223
    270a:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    270e:	80 91 e1 00 	lds	r24, 0x00E1
    2712:	8f 7e       	andi	r24, 0xEF	; 239
    2714:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    2718:	80 91 e2 00 	lds	r24, 0x00E2
    271c:	8f 7e       	andi	r24, 0xEF	; 239
    271e:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    2722:	80 91 e2 00 	lds	r24, 0x00E2
    2726:	81 60       	ori	r24, 0x01	; 1
    2728:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    272c:	80 91 d4 13 	lds	r24, 0x13D4
    2730:	88 23       	and	r24, r24
    2732:	21 f4       	brne	.+8      	; 0x273c <__vector_10+0x116>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2734:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2738:	87 ff       	sbrs	r24, 7
    273a:	02 c0       	rjmp	.+4      	; 0x2740 <__vector_10+0x11a>
    273c:	84 e0       	ldi	r24, 0x04	; 4
    273e:	01 c0       	rjmp	.+2      	; 0x2742 <__vector_10+0x11c>
    2740:	81 e0       	ldi	r24, 0x01	; 1
    2742:	80 93 d8 13 	sts	0x13D8, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    2746:	9f d1       	rcall	.+830    	; 0x2a86 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    2748:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    274c:	83 ff       	sbrs	r24, 3
    274e:	22 c0       	rjmp	.+68     	; 0x2794 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    2750:	80 91 e2 00 	lds	r24, 0x00E2
    2754:	83 ff       	sbrs	r24, 3
    2756:	1e c0       	rjmp	.+60     	; 0x2794 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    2758:	80 91 e1 00 	lds	r24, 0x00E1
    275c:	87 7f       	andi	r24, 0xF7	; 247
    275e:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    2762:	82 e0       	ldi	r24, 0x02	; 2
    2764:	80 93 d8 13 	sts	0x13D8, r24
		USB_Device_ConfigurationNumber = 0;
    2768:	10 92 d4 13 	sts	0x13D4, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    276c:	80 91 e1 00 	lds	r24, 0x00E1
    2770:	8e 7f       	andi	r24, 0xFE	; 254
    2772:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2776:	80 91 e2 00 	lds	r24, 0x00E2
    277a:	8e 7f       	andi	r24, 0xFE	; 254
    277c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2780:	80 91 e2 00 	lds	r24, 0x00E2
    2784:	80 61       	ori	r24, 0x10	; 16
    2786:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    278a:	80 e0       	ldi	r24, 0x00	; 0
    278c:	60 e0       	ldi	r22, 0x00	; 0
    278e:	42 e0       	ldi	r20, 0x02	; 2
    2790:	5e de       	rcall	.-836    	; 0x244e <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2792:	79 d1       	rcall	.+754    	; 0x2a86 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2794:	ff 91       	pop	r31
    2796:	ef 91       	pop	r30
    2798:	bf 91       	pop	r27
    279a:	af 91       	pop	r26
    279c:	9f 91       	pop	r25
    279e:	8f 91       	pop	r24
    27a0:	7f 91       	pop	r23
    27a2:	6f 91       	pop	r22
    27a4:	5f 91       	pop	r21
    27a6:	4f 91       	pop	r20
    27a8:	3f 91       	pop	r19
    27aa:	2f 91       	pop	r18
    27ac:	0f 90       	pop	r0
    27ae:	0b be       	out	0x3b, r0	; 59
    27b0:	0f 90       	pop	r0
    27b2:	0f be       	out	0x3f, r0	; 63
    27b4:	0f 90       	pop	r0
    27b6:	1f 90       	pop	r1
    27b8:	18 95       	reti

000027ba <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    27ba:	1f 93       	push	r17
    27bc:	df 93       	push	r29
    27be:	cf 93       	push	r28
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
    27c4:	ac 97       	sbiw	r28, 0x2c	; 44
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	de bf       	out	0x3e, r29	; 62
    27cc:	0f be       	out	0x3f, r0	; 63
    27ce:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    27d0:	e9 ed       	ldi	r30, 0xD9	; 217
    27d2:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    27d4:	80 91 f1 00 	lds	r24, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    27d8:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    27da:	23 e1       	ldi	r18, 0x13	; 19
    27dc:	e1 3e       	cpi	r30, 0xE1	; 225
    27de:	f2 07       	cpc	r31, r18
    27e0:	c9 f7       	brne	.-14     	; 0x27d4 <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    27e2:	0e 94 9d 02 	call	0x53a	; 0x53a <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27e6:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    27ea:	83 ff       	sbrs	r24, 3
    27ec:	34 c1       	rjmp	.+616    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    27ee:	80 91 d9 13 	lds	r24, 0x13D9

		switch (USB_ControlRequest.bRequest)
    27f2:	20 91 da 13 	lds	r18, 0x13DA
    27f6:	25 30       	cpi	r18, 0x05	; 5
    27f8:	09 f4       	brne	.+2      	; 0x27fc <USB_Device_ProcessControlRequest+0x42>
    27fa:	84 c0       	rjmp	.+264    	; 0x2904 <USB_Device_ProcessControlRequest+0x14a>
    27fc:	26 30       	cpi	r18, 0x06	; 6
    27fe:	40 f4       	brcc	.+16     	; 0x2810 <USB_Device_ProcessControlRequest+0x56>
    2800:	21 30       	cpi	r18, 0x01	; 1
    2802:	a1 f1       	breq	.+104    	; 0x286c <USB_Device_ProcessControlRequest+0xb2>
    2804:	21 30       	cpi	r18, 0x01	; 1
    2806:	70 f0       	brcs	.+28     	; 0x2824 <USB_Device_ProcessControlRequest+0x6a>
    2808:	23 30       	cpi	r18, 0x03	; 3
    280a:	09 f0       	breq	.+2      	; 0x280e <USB_Device_ProcessControlRequest+0x54>
    280c:	24 c1       	rjmp	.+584    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
    280e:	2e c0       	rjmp	.+92     	; 0x286c <USB_Device_ProcessControlRequest+0xb2>
    2810:	28 30       	cpi	r18, 0x08	; 8
    2812:	09 f4       	brne	.+2      	; 0x2816 <USB_Device_ProcessControlRequest+0x5c>
    2814:	f1 c0       	rjmp	.+482    	; 0x29f8 <USB_Device_ProcessControlRequest+0x23e>
    2816:	29 30       	cpi	r18, 0x09	; 9
    2818:	09 f4       	brne	.+2      	; 0x281c <USB_Device_ProcessControlRequest+0x62>
    281a:	00 c1       	rjmp	.+512    	; 0x2a1c <USB_Device_ProcessControlRequest+0x262>
    281c:	26 30       	cpi	r18, 0x06	; 6
    281e:	09 f0       	breq	.+2      	; 0x2822 <USB_Device_ProcessControlRequest+0x68>
    2820:	1a c1       	rjmp	.+564    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
    2822:	93 c0       	rjmp	.+294    	; 0x294a <USB_Device_ProcessControlRequest+0x190>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2824:	80 38       	cpi	r24, 0x80	; 128
    2826:	21 f0       	breq	.+8      	; 0x2830 <USB_Device_ProcessControlRequest+0x76>
    2828:	82 38       	cpi	r24, 0x82	; 130
    282a:	09 f0       	breq	.+2      	; 0x282e <USB_Device_ProcessControlRequest+0x74>
    282c:	14 c1       	rjmp	.+552    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
    282e:	08 c0       	rjmp	.+16     	; 0x2840 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    2830:	80 91 d5 13 	lds	r24, 0x13D5
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2834:	90 91 d6 13 	lds	r25, 0x13D6
    2838:	99 23       	and	r25, r25
    283a:	71 f0       	breq	.+28     	; 0x2858 <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    283c:	82 60       	ori	r24, 0x02	; 2
    283e:	0c c0       	rjmp	.+24     	; 0x2858 <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2840:	80 91 dd 13 	lds	r24, 0x13DD
    2844:	8f 70       	andi	r24, 0x0F	; 15
    2846:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    284a:	90 91 eb 00 	lds	r25, 0x00EB
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);

			CurrentStatus = Endpoint_IsStalled();
    284e:	81 e0       	ldi	r24, 0x01	; 1
    2850:	95 ff       	sbrs	r25, 5
    2852:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2854:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2858:	90 91 e8 00 	lds	r25, 0x00E8
    285c:	97 7f       	andi	r25, 0xF7	; 247
    285e:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2862:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    2866:	10 92 f1 00 	sts	0x00F1, r1
    286a:	d1 c0       	rjmp	.+418    	; 0x2a0e <USB_Device_ProcessControlRequest+0x254>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    286c:	88 23       	and	r24, r24
    286e:	19 f0       	breq	.+6      	; 0x2876 <USB_Device_ProcessControlRequest+0xbc>
    2870:	82 30       	cpi	r24, 0x02	; 2
    2872:	09 f0       	breq	.+2      	; 0x2876 <USB_Device_ProcessControlRequest+0xbc>
    2874:	f0 c0       	rjmp	.+480    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2876:	90 e0       	ldi	r25, 0x00	; 0
    2878:	8f 71       	andi	r24, 0x1F	; 31
    287a:	90 70       	andi	r25, 0x00	; 0
    287c:	00 97       	sbiw	r24, 0x00	; 0
    287e:	29 f0       	breq	.+10     	; 0x288a <USB_Device_ProcessControlRequest+0xd0>
    2880:	82 30       	cpi	r24, 0x02	; 2
    2882:	91 05       	cpc	r25, r1
    2884:	09 f0       	breq	.+2      	; 0x2888 <USB_Device_ProcessControlRequest+0xce>
    2886:	e7 c0       	rjmp	.+462    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
    2888:	0b c0       	rjmp	.+22     	; 0x28a0 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    288a:	80 91 db 13 	lds	r24, 0x13DB
    288e:	81 30       	cpi	r24, 0x01	; 1
    2890:	09 f0       	breq	.+2      	; 0x2894 <USB_Device_ProcessControlRequest+0xda>
    2892:	e1 c0       	rjmp	.+450    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2894:	23 30       	cpi	r18, 0x03	; 3
    2896:	09 f0       	breq	.+2      	; 0x289a <USB_Device_ProcessControlRequest+0xe0>
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	80 93 d6 13 	sts	0x13D6, r24
    289e:	2c c0       	rjmp	.+88     	; 0x28f8 <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    28a0:	80 91 db 13 	lds	r24, 0x13DB
    28a4:	88 23       	and	r24, r24
    28a6:	41 f5       	brne	.+80     	; 0x28f8 <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    28a8:	20 91 dd 13 	lds	r18, 0x13DD
    28ac:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    28ae:	09 f4       	brne	.+2      	; 0x28b2 <USB_Device_ProcessControlRequest+0xf8>
    28b0:	d2 c0       	rjmp	.+420    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    28b2:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    28b6:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    28ba:	80 ff       	sbrs	r24, 0
    28bc:	1d c0       	rjmp	.+58     	; 0x28f8 <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    28be:	80 91 da 13 	lds	r24, 0x13DA
    28c2:	83 30       	cpi	r24, 0x03	; 3
    28c4:	21 f4       	brne	.+8      	; 0x28ce <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    28c6:	80 91 eb 00 	lds	r24, 0x00EB
    28ca:	80 62       	ori	r24, 0x20	; 32
    28cc:	13 c0       	rjmp	.+38     	; 0x28f4 <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    28ce:	80 91 eb 00 	lds	r24, 0x00EB
    28d2:	80 61       	ori	r24, 0x10	; 16
    28d4:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	02 c0       	rjmp	.+4      	; 0x28e2 <USB_Device_ProcessControlRequest+0x128>
    28de:	88 0f       	add	r24, r24
    28e0:	99 1f       	adc	r25, r25
    28e2:	2a 95       	dec	r18
    28e4:	e2 f7       	brpl	.-8      	; 0x28de <USB_Device_ProcessControlRequest+0x124>
    28e6:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    28ea:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    28ee:	80 91 eb 00 	lds	r24, 0x00EB
    28f2:	88 60       	ori	r24, 0x08	; 8
    28f4:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    28f8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    28fc:	80 91 e8 00 	lds	r24, 0x00E8
    2900:	87 7f       	andi	r24, 0xF7	; 247
    2902:	88 c0       	rjmp	.+272    	; 0x2a14 <USB_Device_ProcessControlRequest+0x25a>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2904:	88 23       	and	r24, r24
    2906:	09 f0       	breq	.+2      	; 0x290a <USB_Device_ProcessControlRequest+0x150>
    2908:	a6 c0       	rjmp	.+332    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    290a:	10 91 db 13 	lds	r17, 0x13DB
    290e:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2910:	80 91 e3 00 	lds	r24, 0x00E3
    2914:	80 78       	andi	r24, 0x80	; 128
    2916:	81 2b       	or	r24, r17
    2918:	80 93 e3 00 	sts	0x00E3, r24
    291c:	80 91 e8 00 	lds	r24, 0x00E8
    2920:	87 7f       	andi	r24, 0xF7	; 247
    2922:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2926:	ca dd       	rcall	.-1132   	; 0x24bc <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2928:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    292c:	80 ff       	sbrs	r24, 0
    292e:	fc cf       	rjmp	.-8      	; 0x2928 <USB_Device_ProcessControlRequest+0x16e>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    2930:	80 91 e3 00 	lds	r24, 0x00E3
    2934:	80 68       	ori	r24, 0x80	; 128
    2936:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    293a:	11 23       	and	r17, r17
    293c:	11 f0       	breq	.+4      	; 0x2942 <USB_Device_ProcessControlRequest+0x188>
    293e:	83 e0       	ldi	r24, 0x03	; 3
    2940:	01 c0       	rjmp	.+2      	; 0x2944 <USB_Device_ProcessControlRequest+0x18a>
    2942:	82 e0       	ldi	r24, 0x02	; 2
    2944:	80 93 d8 13 	sts	0x13D8, r24
    2948:	86 c0       	rjmp	.+268    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    294a:	80 58       	subi	r24, 0x80	; 128
    294c:	82 30       	cpi	r24, 0x02	; 2
    294e:	08 f0       	brcs	.+2      	; 0x2952 <USB_Device_ProcessControlRequest+0x198>
    2950:	82 c0       	rjmp	.+260    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2952:	80 91 db 13 	lds	r24, 0x13DB
    2956:	90 91 dc 13 	lds	r25, 0x13DC
    295a:	23 e0       	ldi	r18, 0x03	; 3
    295c:	8c 3d       	cpi	r24, 0xDC	; 220
    295e:	92 07       	cpc	r25, r18
    2960:	91 f5       	brne	.+100    	; 0x29c6 <USB_Device_ProcessControlRequest+0x20c>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    2962:	83 e0       	ldi	r24, 0x03	; 3
    2964:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2966:	8a e2       	ldi	r24, 0x2A	; 42
    2968:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    296a:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    296c:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    296e:	de 01       	movw	r26, r28
    2970:	15 96       	adiw	r26, 0x05	; 5
    2972:	80 e0       	ldi	r24, 0x00	; 0
    2974:	90 e0       	ldi	r25, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    2976:	4e e0       	ldi	r20, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2978:	61 e2       	ldi	r22, 0x21	; 33
    297a:	e4 2f       	mov	r30, r20
    297c:	f0 e0       	ldi	r31, 0x00	; 0
    297e:	60 93 57 00 	sts	0x0057, r22
    2982:	e4 91       	lpm	r30, Z+

					if (SerialCharNum & 0x01)
    2984:	80 ff       	sbrs	r24, 0
    2986:	03 c0       	rjmp	.+6      	; 0x298e <USB_Device_ProcessControlRequest+0x1d4>
					{
						SerialByte >>= 4;
    2988:	e2 95       	swap	r30
    298a:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    298c:	4f 5f       	subi	r20, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    298e:	ef 70       	andi	r30, 0x0F	; 15
    2990:	2e 2f       	mov	r18, r30
    2992:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2994:	ea 30       	cpi	r30, 0x0A	; 10
    2996:	18 f0       	brcs	.+6      	; 0x299e <USB_Device_ProcessControlRequest+0x1e4>
    2998:	29 5c       	subi	r18, 0xC9	; 201
    299a:	3f 4f       	sbci	r19, 0xFF	; 255
    299c:	02 c0       	rjmp	.+4      	; 0x29a2 <USB_Device_ProcessControlRequest+0x1e8>
    299e:	20 5d       	subi	r18, 0xD0	; 208
    29a0:	3f 4f       	sbci	r19, 0xFF	; 255
    29a2:	2d 93       	st	X+, r18
    29a4:	3d 93       	st	X+, r19
    29a6:	01 96       	adiw	r24, 0x01	; 1
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    29a8:	84 31       	cpi	r24, 0x14	; 20
    29aa:	91 05       	cpc	r25, r1
    29ac:	31 f7       	brne	.-52     	; 0x297a <USB_Device_ProcessControlRequest+0x1c0>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    29ae:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    29b0:	80 91 e8 00 	lds	r24, 0x00E8
    29b4:	87 7f       	andi	r24, 0xF7	; 247
    29b6:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    29ba:	ce 01       	movw	r24, r28
    29bc:	03 96       	adiw	r24, 0x03	; 3
    29be:	6a e2       	ldi	r22, 0x2A	; 42
    29c0:	70 e0       	ldi	r23, 0x00	; 0
    29c2:	48 dc       	rcall	.-1904   	; 0x2254 <Endpoint_Write_Control_Stream_LE>
    29c4:	13 c0       	rjmp	.+38     	; 0x29ec <USB_Device_ProcessControlRequest+0x232>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    29c6:	60 91 dd 13 	lds	r22, 0x13DD
    29ca:	ae 01       	movw	r20, r28
    29cc:	4f 5f       	subi	r20, 0xFF	; 255
    29ce:	5f 4f       	sbci	r21, 0xFF	; 255
    29d0:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <CALLBACK_USB_GetDescriptor>
    29d4:	bc 01       	movw	r22, r24
    29d6:	00 97       	sbiw	r24, 0x00	; 0
    29d8:	09 f4       	brne	.+2      	; 0x29dc <USB_Device_ProcessControlRequest+0x222>
    29da:	3d c0       	rjmp	.+122    	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
    29dc:	80 91 e8 00 	lds	r24, 0x00E8
    29e0:	87 7f       	andi	r24, 0xF7	; 247
    29e2:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ea:	d3 dc       	rcall	.-1626   	; 0x2392 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    29ec:	80 91 e8 00 	lds	r24, 0x00E8
    29f0:	8b 77       	andi	r24, 0x7B	; 123
    29f2:	80 93 e8 00 	sts	0x00E8, r24
    29f6:	2f c0       	rjmp	.+94     	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    29f8:	80 38       	cpi	r24, 0x80	; 128
    29fa:	69 f5       	brne	.+90     	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    29fc:	80 91 e8 00 	lds	r24, 0x00E8
    2a00:	87 7f       	andi	r24, 0xF7	; 247
    2a02:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2a06:	80 91 d4 13 	lds	r24, 0x13D4
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2a0a:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2a0e:	80 91 e8 00 	lds	r24, 0x00E8
    2a12:	8e 77       	andi	r24, 0x7E	; 126
    2a14:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2a18:	51 dd       	rcall	.-1374   	; 0x24bc <Endpoint_ClearStatusStage>
    2a1a:	1d c0       	rjmp	.+58     	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2a1c:	88 23       	and	r24, r24
    2a1e:	d9 f4       	brne	.+54     	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2a20:	90 91 db 13 	lds	r25, 0x13DB
    2a24:	92 30       	cpi	r25, 0x02	; 2
    2a26:	b8 f4       	brcc	.+46     	; 0x2a56 <USB_Device_ProcessControlRequest+0x29c>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2a28:	80 91 e8 00 	lds	r24, 0x00E8
    2a2c:	87 7f       	andi	r24, 0xF7	; 247
    2a2e:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2a32:	90 93 d4 13 	sts	0x13D4, r25

	Endpoint_ClearStatusStage();
    2a36:	42 dd       	rcall	.-1404   	; 0x24bc <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2a38:	80 91 d4 13 	lds	r24, 0x13D4
    2a3c:	88 23       	and	r24, r24
    2a3e:	21 f4       	brne	.+8      	; 0x2a48 <USB_Device_ProcessControlRequest+0x28e>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2a40:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2a44:	87 ff       	sbrs	r24, 7
    2a46:	02 c0       	rjmp	.+4      	; 0x2a4c <USB_Device_ProcessControlRequest+0x292>
    2a48:	84 e0       	ldi	r24, 0x04	; 4
    2a4a:	01 c0       	rjmp	.+2      	; 0x2a4e <USB_Device_ProcessControlRequest+0x294>
    2a4c:	81 e0       	ldi	r24, 0x01	; 1
    2a4e:	80 93 d8 13 	sts	0x13D8, r24

	EVENT_USB_Device_ConfigurationChanged();
    2a52:	0e 94 75 02 	call	0x4ea	; 0x4ea <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2a56:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2a5a:	83 ff       	sbrs	r24, 3
    2a5c:	0a c0       	rjmp	.+20     	; 0x2a72 <USB_Device_ProcessControlRequest+0x2b8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2a5e:	80 91 e8 00 	lds	r24, 0x00E8
    2a62:	87 7f       	andi	r24, 0xF7	; 247
    2a64:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2a68:	80 91 eb 00 	lds	r24, 0x00EB
    2a6c:	80 62       	ori	r24, 0x20	; 32
    2a6e:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    2a72:	ac 96       	adiw	r28, 0x2c	; 44
    2a74:	0f b6       	in	r0, 0x3f	; 63
    2a76:	f8 94       	cli
    2a78:	de bf       	out	0x3e, r29	; 62
    2a7a:	0f be       	out	0x3f, r0	; 63
    2a7c:	cd bf       	out	0x3d, r28	; 61
    2a7e:	cf 91       	pop	r28
    2a80:	df 91       	pop	r29
    2a82:	1f 91       	pop	r17
    2a84:	08 95       	ret

00002a86 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2a86:	08 95       	ret

00002a88 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2a88:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    2a8a:	80 91 d8 13 	lds	r24, 0x13D8
    2a8e:	88 23       	and	r24, r24
    2a90:	a9 f0       	breq	.+42     	; 0x2abc <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2a92:	80 91 e9 00 	lds	r24, 0x00E9
    2a96:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2a98:	90 91 ec 00 	lds	r25, 0x00EC
    2a9c:	90 ff       	sbrs	r25, 0
    2a9e:	02 c0       	rjmp	.+4      	; 0x2aa4 <USB_USBTask+0x1c>
    2aa0:	10 e8       	ldi	r17, 0x80	; 128
    2aa2:	01 c0       	rjmp	.+2      	; 0x2aa6 <USB_USBTask+0x1e>
    2aa4:	10 e0       	ldi	r17, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2aa6:	18 2b       	or	r17, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2aa8:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2aac:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    2ab0:	83 ff       	sbrs	r24, 3
    2ab2:	01 c0       	rjmp	.+2      	; 0x2ab6 <USB_USBTask+0x2e>
	  USB_Device_ProcessControlRequest();
    2ab4:	82 de       	rcall	.-764    	; 0x27ba <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2ab6:	1f 70       	andi	r17, 0x0F	; 15
    2ab8:	10 93 e9 00 	sts	0x00E9, r17
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    2abc:	1f 91       	pop	r17
    2abe:	08 95       	ret

00002ac0 <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2ac0:	90 91 c8 00 	lds	r25, 0x00C8
    2ac4:	95 ff       	sbrs	r25, 5
    2ac6:	fc cf       	rjmp	.-8      	; 0x2ac0 <Serial_putchar>
				UDR1 = DataByte;
    2ac8:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2acc:	80 e0       	ldi	r24, 0x00	; 0
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	08 95       	ret

00002ad2 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2ad2:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2ad6:	87 ff       	sbrs	r24, 7
    2ad8:	08 c0       	rjmp	.+16     	; 0x2aea <Serial_getchar+0x18>
    2ada:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2ade:	87 ff       	sbrs	r24, 7
    2ae0:	07 c0       	rjmp	.+14     	; 0x2af0 <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    2ae2:	20 91 ce 00 	lds	r18, 0x00CE
    2ae6:	30 e0       	ldi	r19, 0x00	; 0
    2ae8:	05 c0       	rjmp	.+10     	; 0x2af4 <Serial_getchar+0x22>
	  return _FDEV_EOF;
    2aea:	2e ef       	ldi	r18, 0xFE	; 254
    2aec:	3f ef       	ldi	r19, 0xFF	; 255
    2aee:	02 c0       	rjmp	.+4      	; 0x2af4 <Serial_getchar+0x22>
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2af0:	2f ef       	ldi	r18, 0xFF	; 255
    2af2:	3f ef       	ldi	r19, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2af4:	c9 01       	movw	r24, r18
    2af6:	08 95       	ret

00002af8 <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2af8:	fc 01       	movw	r30, r24
	if (!(Stream))
    2afa:	00 97       	sbiw	r24, 0x00	; 0
    2afc:	51 f4       	brne	.+20     	; 0x2b12 <Serial_CreateStream+0x1a>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    2afe:	e1 ee       	ldi	r30, 0xE1	; 225
    2b00:	f3 e1       	ldi	r31, 0x13	; 19
    2b02:	f0 93 f0 13 	sts	0x13F0, r31
    2b06:	e0 93 ef 13 	sts	0x13EF, r30
		stdout = Stream;
    2b0a:	f0 93 f2 13 	sts	0x13F2, r31
    2b0e:	e0 93 f1 13 	sts	0x13F1, r30
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2b12:	8e e0       	ldi	r24, 0x0E	; 14
    2b14:	df 01       	movw	r26, r30
    2b16:	1d 92       	st	X+, r1
    2b18:	8a 95       	dec	r24
    2b1a:	e9 f7       	brne	.-6      	; 0x2b16 <Serial_CreateStream+0x1e>
    2b1c:	83 e0       	ldi	r24, 0x03	; 3
    2b1e:	83 83       	std	Z+3, r24	; 0x03
    2b20:	80 e6       	ldi	r24, 0x60	; 96
    2b22:	95 e1       	ldi	r25, 0x15	; 21
    2b24:	91 87       	std	Z+9, r25	; 0x09
    2b26:	80 87       	std	Z+8, r24	; 0x08
    2b28:	89 e6       	ldi	r24, 0x69	; 105
    2b2a:	95 e1       	ldi	r25, 0x15	; 21
    2b2c:	93 87       	std	Z+11, r25	; 0x0b
    2b2e:	82 87       	std	Z+10, r24	; 0x0a
}
    2b30:	08 95       	ret

00002b32 <memcpy_P>:
    2b32:	fb 01       	movw	r30, r22
    2b34:	dc 01       	movw	r26, r24
    2b36:	02 c0       	rjmp	.+4      	; 0x2b3c <memcpy_P+0xa>
    2b38:	05 90       	lpm	r0, Z+
    2b3a:	0d 92       	st	X+, r0
    2b3c:	41 50       	subi	r20, 0x01	; 1
    2b3e:	50 40       	sbci	r21, 0x00	; 0
    2b40:	d8 f7       	brcc	.-10     	; 0x2b38 <memcpy_P+0x6>
    2b42:	08 95       	ret

00002b44 <strcpy_P>:
    2b44:	fb 01       	movw	r30, r22
    2b46:	dc 01       	movw	r26, r24
    2b48:	05 90       	lpm	r0, Z+
    2b4a:	0d 92       	st	X+, r0
    2b4c:	00 20       	and	r0, r0
    2b4e:	e1 f7       	brne	.-8      	; 0x2b48 <strcpy_P+0x4>
    2b50:	08 95       	ret

00002b52 <strlen_P>:
    2b52:	fc 01       	movw	r30, r24
    2b54:	05 90       	lpm	r0, Z+
    2b56:	00 20       	and	r0, r0
    2b58:	e9 f7       	brne	.-6      	; 0x2b54 <strlen_P+0x2>
    2b5a:	80 95       	com	r24
    2b5c:	90 95       	com	r25
    2b5e:	8e 0f       	add	r24, r30
    2b60:	9f 1f       	adc	r25, r31
    2b62:	08 95       	ret

00002b64 <strncpy_P>:
    2b64:	fb 01       	movw	r30, r22
    2b66:	dc 01       	movw	r26, r24
    2b68:	41 50       	subi	r20, 0x01	; 1
    2b6a:	50 40       	sbci	r21, 0x00	; 0
    2b6c:	48 f0       	brcs	.+18     	; 0x2b80 <strncpy_P+0x1c>
    2b6e:	05 90       	lpm	r0, Z+
    2b70:	0d 92       	st	X+, r0
    2b72:	00 20       	and	r0, r0
    2b74:	c9 f7       	brne	.-14     	; 0x2b68 <strncpy_P+0x4>
    2b76:	01 c0       	rjmp	.+2      	; 0x2b7a <strncpy_P+0x16>
    2b78:	1d 92       	st	X+, r1
    2b7a:	41 50       	subi	r20, 0x01	; 1
    2b7c:	50 40       	sbci	r21, 0x00	; 0
    2b7e:	e0 f7       	brcc	.-8      	; 0x2b78 <strncpy_P+0x14>
    2b80:	08 95       	ret

00002b82 <memcmp>:
    2b82:	fb 01       	movw	r30, r22
    2b84:	dc 01       	movw	r26, r24
    2b86:	04 c0       	rjmp	.+8      	; 0x2b90 <memcmp+0xe>
    2b88:	8d 91       	ld	r24, X+
    2b8a:	01 90       	ld	r0, Z+
    2b8c:	80 19       	sub	r24, r0
    2b8e:	21 f4       	brne	.+8      	; 0x2b98 <memcmp+0x16>
    2b90:	41 50       	subi	r20, 0x01	; 1
    2b92:	50 40       	sbci	r21, 0x00	; 0
    2b94:	c8 f7       	brcc	.-14     	; 0x2b88 <memcmp+0x6>
    2b96:	88 1b       	sub	r24, r24
    2b98:	99 0b       	sbc	r25, r25
    2b9a:	08 95       	ret

00002b9c <memcpy>:
    2b9c:	fb 01       	movw	r30, r22
    2b9e:	dc 01       	movw	r26, r24
    2ba0:	02 c0       	rjmp	.+4      	; 0x2ba6 <memcpy+0xa>
    2ba2:	01 90       	ld	r0, Z+
    2ba4:	0d 92       	st	X+, r0
    2ba6:	41 50       	subi	r20, 0x01	; 1
    2ba8:	50 40       	sbci	r21, 0x00	; 0
    2baa:	d8 f7       	brcc	.-10     	; 0x2ba2 <memcpy+0x6>
    2bac:	08 95       	ret

00002bae <memmove>:
    2bae:	68 17       	cp	r22, r24
    2bb0:	79 07       	cpc	r23, r25
    2bb2:	68 f4       	brcc	.+26     	; 0x2bce <memmove+0x20>
    2bb4:	fb 01       	movw	r30, r22
    2bb6:	dc 01       	movw	r26, r24
    2bb8:	e4 0f       	add	r30, r20
    2bba:	f5 1f       	adc	r31, r21
    2bbc:	a4 0f       	add	r26, r20
    2bbe:	b5 1f       	adc	r27, r21
    2bc0:	02 c0       	rjmp	.+4      	; 0x2bc6 <memmove+0x18>
    2bc2:	02 90       	ld	r0, -Z
    2bc4:	0e 92       	st	-X, r0
    2bc6:	41 50       	subi	r20, 0x01	; 1
    2bc8:	50 40       	sbci	r21, 0x00	; 0
    2bca:	d8 f7       	brcc	.-10     	; 0x2bc2 <memmove+0x14>
    2bcc:	08 95       	ret
    2bce:	e6 cf       	rjmp	.-52     	; 0x2b9c <memcpy>

00002bd0 <strncmp>:
    2bd0:	fb 01       	movw	r30, r22
    2bd2:	dc 01       	movw	r26, r24
    2bd4:	41 50       	subi	r20, 0x01	; 1
    2bd6:	50 40       	sbci	r21, 0x00	; 0
    2bd8:	30 f0       	brcs	.+12     	; 0x2be6 <strncmp+0x16>
    2bda:	8d 91       	ld	r24, X+
    2bdc:	01 90       	ld	r0, Z+
    2bde:	80 19       	sub	r24, r0
    2be0:	19 f4       	brne	.+6      	; 0x2be8 <strncmp+0x18>
    2be2:	00 20       	and	r0, r0
    2be4:	b9 f7       	brne	.-18     	; 0x2bd4 <strncmp+0x4>
    2be6:	88 1b       	sub	r24, r24
    2be8:	99 0b       	sbc	r25, r25
    2bea:	08 95       	ret

00002bec <_exit>:
    2bec:	f8 94       	cli

00002bee <__stop_program>:
    2bee:	ff cf       	rjmp	.-2      	; 0x2bee <__stop_program>
