
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000fa  00800100  00002cc4  00002d58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002cc4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001fa  008001fa  00002e52  2**0
                  ALLOC
  3 .stab         000010f8  00000000  00000000  00002e54  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a0e  00000000  00000000  00003f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000006a0  00000000  00000000  0000495a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000010f1  00000000  00000000  00004ffa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000aca5  00000000  00000000  000060eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002cd5  00000000  00000000  00010d90  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00008b40  00000000  00000000  00013a65  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000009c0  00000000  00000000  0001c5a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00004418  00000000  00000000  0001cf68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000553b  00000000  00000000  00021380  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 000015bf  00000000  00000000  000268bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000008e8  00000000  00000000  00027e7a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 54 0f 	jmp	0x1ea8	; 0x1ea8 <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 33 30 33 30 33 09 09 3c 2f 70 3e     </i>130303..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e4 ec       	ldi	r30, 0xC4	; 196
     436:	fc e2       	ldi	r31, 0x2C	; 44
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	aa 3f       	cpi	r26, 0xFA	; 250
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	aa ef       	ldi	r26, 0xFA	; 250
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	af 31       	cpi	r26, 0x1F	; 31
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	37 d0       	rcall	.+110    	; 0x4c8 <main>
     45a:	0c 94 60 16 	jmp	0x2cc0	; 0x2cc0 <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	9b b1       	in	r25, 0x0b	; 11
     462:	9f 70       	andi	r25, 0x0F	; 15
     464:	98 2b       	or	r25, r24
     466:	9b b9       	out	0x0b, r25	; 11
			}
     468:	08 95       	ret

0000046a <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     46a:	84 b7       	in	r24, 0x34	; 52
     46c:	87 7f       	andi	r24, 0xF7	; 247
     46e:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     470:	28 e1       	ldi	r18, 0x18	; 24
     472:	0f b6       	in	r0, 0x3f	; 63
     474:	f8 94       	cli
     476:	20 93 60 00 	sts	0x0060, r18
     47a:	10 92 60 00 	sts	0x0060, r1
     47e:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	80 e8       	ldi	r24, 0x80	; 128
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	f8 94       	cli
     488:	80 93 61 00 	sts	0x0061, r24
     48c:	90 93 61 00 	sts	0x0061, r25
     490:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     492:	8a b1       	in	r24, 0x0a	; 10
     494:	80 6f       	ori	r24, 0xF0	; 240
     496:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     498:	8b b1       	in	r24, 0x0b	; 11
     49a:	8f 70       	andi	r24, 0x0F	; 15
     49c:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     49e:	83 e3       	ldi	r24, 0x33	; 51
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	90 93 cd 00 	sts	0x00CD, r25
     4a6:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4aa:	86 e0       	ldi	r24, 0x06	; 6
     4ac:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4b0:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4b4:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     4b8:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4ba:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4bc:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <USB_Init>

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	0c 94 e6 15 	jmp	0x2bcc	; 0x2bcc <Serial_CreateStream>

000004c8 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     4c8:	d0 df       	rcall	.-96     	; 0x46a <SetupHardware>

	TCP_Init();
     4ca:	42 d3       	rcall	.+1668   	; 0xb50 <TCP_Init>
	Webserver_Init();
     4cc:	0e 94 65 0c 	call	0x18ca	; 0x18ca <Webserver_Init>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     4d0:	80 e1       	ldi	r24, 0x10	; 16
     4d2:	c6 df       	rcall	.-116    	; 0x460 <LEDs_SetAllLEDs>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     4d4:	78 94       	sei
	GlobalInterruptEnable();

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     4d6:	88 e1       	ldi	r24, 0x18	; 24
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <RNDIS_Device_IsPacketReceived>
     4de:	88 23       	and	r24, r24
     4e0:	11 f1       	breq	.+68     	; 0x526 <main+0x5e>
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     4e2:	80 e2       	ldi	r24, 0x20	; 32
     4e4:	bd df       	rcall	.-134    	; 0x460 <LEDs_SetAllLEDs>

			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     4e6:	88 e1       	ldi	r24, 0x18	; 24
     4e8:	91 e0       	ldi	r25, 0x01	; 1
     4ea:	6a ef       	ldi	r22, 0xFA	; 250
     4ec:	71 e0       	ldi	r23, 0x01	; 1
     4ee:	46 ed       	ldi	r20, 0xD6	; 214
     4f0:	57 e0       	ldi	r21, 0x07	; 7
     4f2:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <RNDIS_Device_ReadPacket>
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     4f6:	8a ef       	ldi	r24, 0xFA	; 250
     4f8:	91 e0       	ldi	r25, 0x01	; 1
     4fa:	68 ed       	ldi	r22, 0xD8	; 216
     4fc:	77 e0       	ldi	r23, 0x07	; 7
     4fe:	62 d0       	rcall	.+196    	; 0x5c4 <Ethernet_ProcessPacket>

			if (FrameOUT.FrameLength)
     500:	40 91 b4 0d 	lds	r20, 0x0DB4
     504:	50 91 b5 0d 	lds	r21, 0x0DB5
     508:	41 15       	cp	r20, r1
     50a:	51 05       	cpc	r21, r1
     50c:	51 f0       	breq	.+20     	; 0x522 <main+0x5a>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);
     50e:	88 e1       	ldi	r24, 0x18	; 24
     510:	91 e0       	ldi	r25, 0x01	; 1
     512:	68 ed       	ldi	r22, 0xD8	; 216
     514:	77 e0       	ldi	r23, 0x07	; 7
     516:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <RNDIS_Device_SendPacket>
				FrameOUT.FrameLength = 0;
     51a:	10 92 b5 0d 	sts	0x0DB5, r1
     51e:	10 92 b4 0d 	sts	0x0DB4, r1
			}

			LEDs_SetAllLEDs(LEDMASK_USB_READY);
     522:	80 e6       	ldi	r24, 0x60	; 96
     524:	9d df       	rcall	.-198    	; 0x460 <LEDs_SetAllLEDs>
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     526:	88 e1       	ldi	r24, 0x18	; 24
     528:	91 e0       	ldi	r25, 0x01	; 1
     52a:	68 ed       	ldi	r22, 0xD8	; 216
     52c:	77 e0       	ldi	r23, 0x07	; 7
     52e:	c4 d1       	rcall	.+904    	; 0x8b8 <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     530:	88 e1       	ldi	r24, 0x18	; 24
     532:	91 e0       	ldi	r25, 0x01	; 1
     534:	0e 94 9f 14 	call	0x293e	; 0x293e <RNDIS_Device_USBTask>
		USB_USBTask();
     538:	0e 94 85 11 	call	0x230a	; 0x230a <USB_USBTask>
	}
     53c:	cc cf       	rjmp	.-104    	; 0x4d6 <main+0xe>

0000053e <EVENT_USB_Device_Connect>:
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     53e:	80 ea       	ldi	r24, 0xA0	; 160
}
     540:	8f cf       	rjmp	.-226    	; 0x460 <LEDs_SetAllLEDs>

00000542 <EVENT_USB_Device_Disconnect>:

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     542:	80 e1       	ldi	r24, 0x10	; 16
}
     544:	8d cf       	rjmp	.-230    	; 0x460 <LEDs_SetAllLEDs>

00000546 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     546:	88 e1       	ldi	r24, 0x18	; 24
     548:	91 e0       	ldi	r25, 0x01	; 1
     54a:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     54e:	80 ff       	sbrs	r24, 0
     550:	02 c0       	rjmp	.+4      	; 0x556 <EVENT_USB_Device_ConfigurationChanged+0x10>
     552:	80 e6       	ldi	r24, 0x60	; 96
     554:	01 c0       	rjmp	.+2      	; 0x558 <EVENT_USB_Device_ConfigurationChanged+0x12>
     556:	80 e9       	ldi	r24, 0x90	; 144
}
     558:	83 cf       	rjmp	.-250    	; 0x460 <LEDs_SetAllLEDs>

0000055a <EVENT_USB_Device_ControlRequest>:

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	91 e0       	ldi	r25, 0x01	; 1
     55e:	0c 94 a1 11 	jmp	0x2342	; 0x2342 <RNDIS_Device_ProcessControlRequest>

00000562 <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     562:	92 30       	cpi	r25, 0x02	; 2
     564:	29 f0       	breq	.+10     	; 0x570 <CALLBACK_USB_GetDescriptor+0xe>
     566:	93 30       	cpi	r25, 0x03	; 3
     568:	41 f0       	breq	.+16     	; 0x57a <CALLBACK_USB_GetDescriptor+0x18>
     56a:	91 30       	cpi	r25, 0x01	; 1
     56c:	e9 f4       	brne	.+58     	; 0x5a8 <CALLBACK_USB_GetDescriptor+0x46>
     56e:	17 c0       	rjmp	.+46     	; 0x59e <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     570:	2e e3       	ldi	r18, 0x3E	; 62
     572:	30 e0       	ldi	r19, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     574:	ea ea       	ldi	r30, 0xAA	; 170
     576:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     578:	1b c0       	rjmp	.+54     	; 0x5b0 <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     57a:	81 30       	cpi	r24, 0x01	; 1
     57c:	41 f0       	breq	.+16     	; 0x58e <CALLBACK_USB_GetDescriptor+0x2c>
     57e:	81 30       	cpi	r24, 0x01	; 1
     580:	18 f0       	brcs	.+6      	; 0x588 <CALLBACK_USB_GetDescriptor+0x26>
     582:	82 30       	cpi	r24, 0x02	; 2
     584:	89 f4       	brne	.+34     	; 0x5a8 <CALLBACK_USB_GetDescriptor+0x46>
     586:	06 c0       	rjmp	.+12     	; 0x594 <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     588:	e8 ee       	ldi	r30, 0xE8	; 232
     58a:	f0 e0       	ldi	r31, 0x00	; 0
     58c:	05 c0       	rjmp	.+10     	; 0x598 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     58e:	ec ee       	ldi	r30, 0xEC	; 236
     590:	f0 e0       	ldi	r31, 0x00	; 0
     592:	02 c0       	rjmp	.+4      	; 0x598 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     594:	e6 e0       	ldi	r30, 0x06	; 6
     596:	f1 e0       	ldi	r31, 0x01	; 1
     598:	24 91       	lpm	r18, Z+
     59a:	30 e0       	ldi	r19, 0x00	; 0
					break;
     59c:	09 c0       	rjmp	.+18     	; 0x5b0 <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     59e:	22 e1       	ldi	r18, 0x12	; 18
     5a0:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     5a2:	e8 e9       	ldi	r30, 0x98	; 152
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	04 c0       	rjmp	.+8      	; 0x5b0 <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     5a8:	20 e0       	ldi	r18, 0x00	; 0
     5aa:	30 e0       	ldi	r19, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     5ac:	e0 e0       	ldi	r30, 0x00	; 0
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     5b0:	da 01       	movw	r26, r20
     5b2:	11 96       	adiw	r26, 0x01	; 1
     5b4:	fc 93       	st	X, r31
     5b6:	ee 93       	st	-X, r30
	return Size;
}
     5b8:	c9 01       	movw	r24, r18
     5ba:	08 95       	ret

000005bc <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     5bc:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     5be:	89 2f       	mov	r24, r25
     5c0:	92 2f       	mov	r25, r18
     5c2:	08 95       	ret

000005c4 <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     5c4:	ef 92       	push	r14
     5c6:	ff 92       	push	r15
     5c8:	0f 93       	push	r16
     5ca:	1f 93       	push	r17
     5cc:	cf 93       	push	r28
     5ce:	df 93       	push	r29
     5d0:	ec 01       	movw	r28, r24
     5d2:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     5d4:	9b d0       	rcall	.+310    	; 0x70c <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     5d6:	ce 01       	movw	r24, r28
     5d8:	66 eb       	ldi	r22, 0xB6	; 182
     5da:	71 e0       	ldi	r23, 0x01	; 1
     5dc:	46 e0       	ldi	r20, 0x06	; 6
     5de:	50 e0       	ldi	r21, 0x00	; 0
     5e0:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
     5e4:	00 97       	sbiw	r24, 0x00	; 0
     5e6:	51 f0       	breq	.+20     	; 0x5fc <Ethernet_ProcessPacket+0x38>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     5e8:	ce 01       	movw	r24, r28
     5ea:	60 ec       	ldi	r22, 0xC0	; 192
     5ec:	71 e0       	ldi	r23, 0x01	; 1
     5ee:	46 e0       	ldi	r20, 0x06	; 6
     5f0:	50 e0       	ldi	r21, 0x00	; 0
     5f2:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     5f6:	00 97       	sbiw	r24, 0x00	; 0
     5f8:	09 f0       	breq	.+2      	; 0x5fc <Ethernet_ProcessPacket+0x38>
     5fa:	48 c0       	rjmp	.+144    	; 0x68c <Ethernet_ProcessPacket+0xc8>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
     5fc:	fe 01       	movw	r30, r28
     5fe:	e4 52       	subi	r30, 0x24	; 36
     600:	fa 4f       	sbci	r31, 0xFA	; 250
     602:	80 81       	ld	r24, Z
     604:	91 81       	ldd	r25, Z+1	; 0x01
     606:	da df       	rcall	.-76     	; 0x5bc <SwapEndian_16>

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     608:	26 e0       	ldi	r18, 0x06	; 6
     60a:	81 30       	cpi	r24, 0x01	; 1
     60c:	92 07       	cpc	r25, r18
     60e:	08 f4       	brcc	.+2      	; 0x612 <Ethernet_ProcessPacket+0x4e>
     610:	3d c0       	rjmp	.+122    	; 0x68c <Ethernet_ProcessPacket+0xc8>
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     612:	8c 85       	ldd	r24, Y+12	; 0x0c
     614:	9d 85       	ldd	r25, Y+13	; 0x0d
     616:	d2 df       	rcall	.-92     	; 0x5bc <SwapEndian_16>
     618:	38 e0       	ldi	r19, 0x08	; 8
     61a:	80 30       	cpi	r24, 0x00	; 0
     61c:	93 07       	cpc	r25, r19
     61e:	59 f0       	breq	.+22     	; 0x636 <Ethernet_ProcessPacket+0x72>
     620:	e8 e0       	ldi	r30, 0x08	; 8
     622:	86 30       	cpi	r24, 0x06	; 6
     624:	9e 07       	cpc	r25, r30
     626:	91 f5       	brne	.+100    	; 0x68c <Ethernet_ProcessPacket+0xc8>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     628:	b8 01       	movw	r22, r16
     62a:	62 5f       	subi	r22, 0xF2	; 242
     62c:	7f 4f       	sbci	r23, 0xFF	; 255
     62e:	ce 01       	movw	r24, r28
     630:	0e 96       	adiw	r24, 0x0e	; 14
     632:	4a d7       	rcall	.+3732   	; 0x14c8 <ARP_ProcessARPPacket>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     634:	08 c0       	rjmp	.+16     	; 0x646 <Ethernet_ProcessPacket+0x82>
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     636:	be 01       	movw	r22, r28
     638:	62 5f       	subi	r22, 0xF2	; 242
     63a:	7f 4f       	sbci	r23, 0xFF	; 255
     63c:	a8 01       	movw	r20, r16
     63e:	42 5f       	subi	r20, 0xF2	; 242
     640:	5f 4f       	sbci	r21, 0xFF	; 255
     642:	ce 01       	movw	r24, r28
     644:	c1 d7       	rcall	.+3970   	; 0x15c8 <IP_ProcessIPPacket>
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     646:	18 16       	cp	r1, r24
     648:	19 06       	cpc	r1, r25
     64a:	e4 f4       	brge	.+56     	; 0x684 <Ethernet_ProcessPacket+0xc0>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     64c:	d8 01       	movw	r26, r16
     64e:	16 96       	adiw	r26, 0x06	; 6
     650:	e6 eb       	ldi	r30, 0xB6	; 182
     652:	f1 e0       	ldi	r31, 0x01	; 1
     654:	26 e0       	ldi	r18, 0x06	; 6
     656:	01 90       	ld	r0, Z+
     658:	0d 92       	st	X+, r0
     65a:	21 50       	subi	r18, 0x01	; 1
     65c:	e1 f7       	brne	.-8      	; 0x656 <Ethernet_ProcessPacket+0x92>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     65e:	d8 01       	movw	r26, r16
     660:	fe 01       	movw	r30, r28
     662:	36 96       	adiw	r30, 0x06	; 6
     664:	26 e0       	ldi	r18, 0x06	; 6
     666:	01 90       	ld	r0, Z+
     668:	0d 92       	st	X+, r0
     66a:	21 50       	subi	r18, 0x01	; 1
     66c:	e1 f7       	brne	.-8      	; 0x666 <Ethernet_ProcessPacket+0xa2>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     66e:	2c 85       	ldd	r18, Y+12	; 0x0c
     670:	3d 85       	ldd	r19, Y+13	; 0x0d
     672:	f8 01       	movw	r30, r16
     674:	35 87       	std	Z+13, r19	; 0x0d
     676:	24 87       	std	Z+12, r18	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     678:	e4 52       	subi	r30, 0x24	; 36
     67a:	fa 4f       	sbci	r31, 0xFA	; 250
     67c:	0e 96       	adiw	r24, 0x0e	; 14
     67e:	91 83       	std	Z+1, r25	; 0x01
     680:	80 83       	st	Z, r24
     682:	04 c0       	rjmp	.+8      	; 0x68c <Ethernet_ProcessPacket+0xc8>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     684:	ff ef       	ldi	r31, 0xFF	; 255
     686:	8f 3f       	cpi	r24, 0xFF	; 255
     688:	9f 07       	cpc	r25, r31
     68a:	21 f0       	breq	.+8      	; 0x694 <Ethernet_ProcessPacket+0xd0>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     68c:	c4 52       	subi	r28, 0x24	; 36
     68e:	da 4f       	sbci	r29, 0xFA	; 250
     690:	19 82       	std	Y+1, r1	; 0x01
     692:	18 82       	st	Y, r1
	}
}
     694:	df 91       	pop	r29
     696:	cf 91       	pop	r28
     698:	1f 91       	pop	r17
     69a:	0f 91       	pop	r16
     69c:	ff 90       	pop	r15
     69e:	ef 90       	pop	r14
     6a0:	08 95       	ret

000006a2 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6a6:	76 95       	lsr	r23
     6a8:	67 95       	ror	r22
     6aa:	28 2f       	mov	r18, r24
     6ac:	39 2f       	mov	r19, r25
     6ae:	e9 01       	movw	r28, r18
     6b0:	e0 e0       	ldi	r30, 0x00	; 0
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	dc 01       	movw	r26, r24

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6ba:	09 c0       	rjmp	.+18     	; 0x6ce <Ethernet_Checksum16+0x2c>
	  Checksum += Words[CurrWord];
     6bc:	29 91       	ld	r18, Y+
     6be:	39 91       	ld	r19, Y+
     6c0:	40 e0       	ldi	r20, 0x00	; 0
     6c2:	50 e0       	ldi	r21, 0x00	; 0
     6c4:	82 0f       	add	r24, r18
     6c6:	93 1f       	adc	r25, r19
     6c8:	a4 1f       	adc	r26, r20
     6ca:	b5 1f       	adc	r27, r21
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     6cc:	31 96       	adiw	r30, 0x01	; 1
     6ce:	e6 17       	cp	r30, r22
     6d0:	f7 07       	cpc	r31, r23
     6d2:	a0 f3       	brcs	.-24     	; 0x6bc <Ethernet_Checksum16+0x1a>
     6d4:	0b c0       	rjmp	.+22     	; 0x6ec <Ethernet_Checksum16+0x4a>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     6d6:	9c 01       	movw	r18, r24
     6d8:	ad 01       	movw	r20, r26
     6da:	40 70       	andi	r20, 0x00	; 0
     6dc:	50 70       	andi	r21, 0x00	; 0
     6de:	cd 01       	movw	r24, r26
     6e0:	aa 27       	eor	r26, r26
     6e2:	bb 27       	eor	r27, r27
     6e4:	82 0f       	add	r24, r18
     6e6:	93 1f       	adc	r25, r19
     6e8:	a4 1f       	adc	r26, r20
     6ea:	b5 1f       	adc	r27, r21
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     6ec:	9c 01       	movw	r18, r24
     6ee:	ad 01       	movw	r20, r26
     6f0:	20 70       	andi	r18, 0x00	; 0
     6f2:	30 70       	andi	r19, 0x00	; 0
     6f4:	21 15       	cp	r18, r1
     6f6:	31 05       	cpc	r19, r1
     6f8:	41 05       	cpc	r20, r1
     6fa:	51 05       	cpc	r21, r1
     6fc:	61 f7       	brne	.-40     	; 0x6d6 <Ethernet_Checksum16+0x34>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     6fe:	9c 01       	movw	r18, r24
     700:	20 95       	com	r18
     702:	30 95       	com	r19
}
     704:	c9 01       	movw	r24, r18
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     70c:	08 95       	ret

0000070e <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     70e:	08 95       	ret

00000710 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     710:	08 95       	ret

00000712 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     712:	08 95       	ret

00000714 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     714:	08 95       	ret

00000716 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     716:	08 95       	ret

00000718 <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     718:	08 95       	ret

0000071a <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     71a:	cf 92       	push	r12
     71c:	df 92       	push	r13
     71e:	ef 92       	push	r14
     720:	ff 92       	push	r15
     722:	0f 93       	push	r16
     724:	1f 93       	push	r17
     726:	cf 93       	push	r28
     728:	df 93       	push	r29
     72a:	6c 01       	movw	r12, r24
     72c:	8b 01       	movw	r16, r22
     72e:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     730:	cb 01       	movw	r24, r22
     732:	ef df       	rcall	.-34     	; 0x712 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     734:	f8 01       	movw	r30, r16
     736:	80 81       	ld	r24, Z
     738:	88 30       	cpi	r24, 0x08	; 8
     73a:	31 f5       	brne	.+76     	; 0x788 <ICMP_ProcessICMPPacket+0x6e>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     73c:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     73e:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     740:	1b 82       	std	Y+3, r1	; 0x03
     742:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     744:	84 81       	ldd	r24, Z+4	; 0x04
     746:	95 81       	ldd	r25, Z+5	; 0x05
     748:	9d 83       	std	Y+5, r25	; 0x05
     74a:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     74c:	86 81       	ldd	r24, Z+6	; 0x06
     74e:	97 81       	ldd	r25, Z+7	; 0x07
     750:	9f 83       	std	Y+7, r25	; 0x07
     752:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     754:	f6 01       	movw	r30, r12
     756:	e4 52       	subi	r30, 0x24	; 36
     758:	fa 4f       	sbci	r31, 0xFA	; 250
     75a:	e0 80       	ld	r14, Z
     75c:	f1 80       	ldd	r15, Z+1	; 0x01
     75e:	ec 0c       	add	r14, r12
     760:	fd 1c       	adc	r15, r13
     762:	e0 1a       	sub	r14, r16
     764:	f1 0a       	sbc	r15, r17

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     766:	b8 01       	movw	r22, r16
     768:	68 5f       	subi	r22, 0xF8	; 248
     76a:	7f 4f       	sbci	r23, 0xFF	; 255
		ICMPHeaderOUT->Code     = 0;
		ICMPHeaderOUT->Checksum = 0;
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     76c:	a7 01       	movw	r20, r14
     76e:	48 50       	subi	r20, 0x08	; 8
     770:	50 40       	sbci	r21, 0x00	; 0

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     772:	ce 01       	movw	r24, r28
     774:	08 96       	adiw	r24, 0x08	; 8
     776:	0e 94 41 16 	call	0x2c82	; 0x2c82 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     77a:	ce 01       	movw	r24, r28
     77c:	b7 01       	movw	r22, r14
     77e:	91 df       	rcall	.-222    	; 0x6a2 <Ethernet_Checksum16>
     780:	9b 83       	std	Y+3, r25	; 0x03
     782:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     784:	97 01       	movw	r18, r14
     786:	02 c0       	rjmp	.+4      	; 0x78c <ICMP_ProcessICMPPacket+0x72>
	}

	return NO_RESPONSE;
     788:	20 e0       	ldi	r18, 0x00	; 0
     78a:	30 e0       	ldi	r19, 0x00	; 0
}
     78c:	c9 01       	movw	r24, r18
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	ff 90       	pop	r15
     798:	ef 90       	pop	r14
     79a:	df 90       	pop	r13
     79c:	cf 90       	pop	r12
     79e:	08 95       	ret

000007a0 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     7a0:	9b 01       	movw	r18, r22
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     7a2:	69 2f       	mov	r22, r25
     7a4:	78 2f       	mov	r23, r24
     7a6:	83 2f       	mov	r24, r19
     7a8:	92 2f       	mov	r25, r18
     7aa:	08 95       	ret

000007ac <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     7ac:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     7ae:	89 2f       	mov	r24, r25
     7b0:	92 2f       	mov	r25, r18
     7b2:	08 95       	ret

000007b4 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     7b4:	af 92       	push	r10
     7b6:	bf 92       	push	r11
     7b8:	cf 92       	push	r12
     7ba:	df 92       	push	r13
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	0f 93       	push	r16
     7c2:	1f 93       	push	r17
     7c4:	cf 93       	push	r28
     7c6:	df 93       	push	r29
     7c8:	5c 01       	movw	r10, r24
     7ca:	69 01       	movw	r12, r18
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     7cc:	e6 2e       	mov	r14, r22
     7ce:	e7 01       	movw	r28, r14
     7d0:	7e 01       	movw	r14, r28
     7d2:	f7 2e       	mov	r15, r23
     7d4:	e7 01       	movw	r28, r14
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7d6:	fa 01       	movw	r30, r20

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     7d8:	ea 80       	ldd	r14, Y+2	; 0x02
     7da:	fb 80       	ldd	r15, Y+3	; 0x03
     7dc:	00 e0       	ldi	r16, 0x00	; 0
     7de:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7e0:	80 81       	ld	r24, Z
     7e2:	91 81       	ldd	r25, Z+1	; 0x01
     7e4:	a0 e0       	ldi	r26, 0x00	; 0
     7e6:	b0 e0       	ldi	r27, 0x00	; 0

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
	Checksum += ((uint16_t*)SourceAddress)[1];
     7e8:	e8 0e       	add	r14, r24
     7ea:	f9 1e       	adc	r15, r25
     7ec:	0a 1f       	adc	r16, r26
     7ee:	1b 1f       	adc	r17, r27
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     7f0:	88 81       	ld	r24, Y
     7f2:	99 81       	ldd	r25, Y+1	; 0x01
     7f4:	a0 e0       	ldi	r26, 0x00	; 0
     7f6:	b0 e0       	ldi	r27, 0x00	; 0
	Checksum += ((uint16_t*)SourceAddress)[1];
	Checksum += ((uint16_t*)DestinationAddress)[0];
     7f8:	e8 0e       	add	r14, r24
     7fa:	f9 1e       	adc	r15, r25
     7fc:	0a 1f       	adc	r16, r26
     7fe:	1b 1f       	adc	r17, r27
	Checksum += ((uint16_t*)DestinationAddress)[1];
     800:	82 81       	ldd	r24, Z+2	; 0x02
     802:	93 81       	ldd	r25, Z+3	; 0x03
     804:	a0 e0       	ldi	r26, 0x00	; 0
     806:	b0 e0       	ldi	r27, 0x00	; 0
     808:	e8 0e       	add	r14, r24
     80a:	f9 1e       	adc	r15, r25
     80c:	0a 1f       	adc	r16, r26
     80e:	1b 1f       	adc	r17, r27
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     810:	86 e0       	ldi	r24, 0x06	; 6
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	cb df       	rcall	.-106    	; 0x7ac <SwapEndian_16>
     816:	a0 e0       	ldi	r26, 0x00	; 0
     818:	b0 e0       	ldi	r27, 0x00	; 0
     81a:	e8 0e       	add	r14, r24
     81c:	f9 1e       	adc	r15, r25
     81e:	0a 1f       	adc	r16, r26
     820:	1b 1f       	adc	r17, r27
	Checksum += SwapEndian_16(TCPOutSize);
     822:	c6 01       	movw	r24, r12
     824:	c3 df       	rcall	.-122    	; 0x7ac <SwapEndian_16>
     826:	a0 e0       	ldi	r26, 0x00	; 0
     828:	b0 e0       	ldi	r27, 0x00	; 0
     82a:	8e 0d       	add	r24, r14
     82c:	9f 1d       	adc	r25, r15
     82e:	a0 1f       	adc	r26, r16
     830:	b1 1f       	adc	r27, r17

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     832:	f6 01       	movw	r30, r12
     834:	f6 95       	lsr	r31
     836:	e7 95       	ror	r30
     838:	e5 01       	movw	r28, r10
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	0a c0       	rjmp	.+20     	; 0x854 <TCP_Checksum16+0xa0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     840:	29 91       	ld	r18, Y+
     842:	39 91       	ld	r19, Y+
     844:	40 e0       	ldi	r20, 0x00	; 0
     846:	50 e0       	ldi	r21, 0x00	; 0
     848:	82 0f       	add	r24, r18
     84a:	93 1f       	adc	r25, r19
     84c:	a4 1f       	adc	r26, r20
     84e:	b5 1f       	adc	r27, r21
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     850:	6f 5f       	subi	r22, 0xFF	; 255
     852:	7f 4f       	sbci	r23, 0xFF	; 255
     854:	6e 17       	cp	r22, r30
     856:	7f 07       	cpc	r23, r31
     858:	98 f3       	brcs	.-26     	; 0x840 <TCP_Checksum16+0x8c>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     85a:	c0 fe       	sbrs	r12, 0
     85c:	15 c0       	rjmp	.+42     	; 0x888 <TCP_Checksum16+0xd4>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     85e:	ee 0f       	add	r30, r30
     860:	ff 1f       	adc	r31, r31
     862:	ea 0d       	add	r30, r10
     864:	fb 1d       	adc	r31, r11
     866:	20 81       	ld	r18, Z
     868:	82 0f       	add	r24, r18
     86a:	91 1d       	adc	r25, r1
     86c:	a1 1d       	adc	r26, r1
     86e:	b1 1d       	adc	r27, r1
     870:	0b c0       	rjmp	.+22     	; 0x888 <TCP_Checksum16+0xd4>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     872:	9c 01       	movw	r18, r24
     874:	ad 01       	movw	r20, r26
     876:	40 70       	andi	r20, 0x00	; 0
     878:	50 70       	andi	r21, 0x00	; 0
     87a:	cd 01       	movw	r24, r26
     87c:	aa 27       	eor	r26, r26
     87e:	bb 27       	eor	r27, r27
     880:	82 0f       	add	r24, r18
     882:	93 1f       	adc	r25, r19
     884:	a4 1f       	adc	r26, r20
     886:	b5 1f       	adc	r27, r21
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     888:	9c 01       	movw	r18, r24
     88a:	ad 01       	movw	r20, r26
     88c:	20 70       	andi	r18, 0x00	; 0
     88e:	30 70       	andi	r19, 0x00	; 0
     890:	21 15       	cp	r18, r1
     892:	31 05       	cpc	r19, r1
     894:	41 05       	cpc	r20, r1
     896:	51 05       	cpc	r21, r1
     898:	61 f7       	brne	.-40     	; 0x872 <TCP_Checksum16+0xbe>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     89a:	9c 01       	movw	r18, r24
     89c:	20 95       	com	r18
     89e:	30 95       	com	r19
}
     8a0:	c9 01       	movw	r24, r18
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	1f 91       	pop	r17
     8a8:	0f 91       	pop	r16
     8aa:	ff 90       	pop	r15
     8ac:	ef 90       	pop	r14
     8ae:	df 90       	pop	r13
     8b0:	cf 90       	pop	r12
     8b2:	bf 90       	pop	r11
     8b4:	af 90       	pop	r10
     8b6:	08 95       	ret

000008b8 <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     8b8:	4f 92       	push	r4
     8ba:	5f 92       	push	r5
     8bc:	6f 92       	push	r6
     8be:	7f 92       	push	r7
     8c0:	8f 92       	push	r8
     8c2:	9f 92       	push	r9
     8c4:	af 92       	push	r10
     8c6:	bf 92       	push	r11
     8c8:	cf 92       	push	r12
     8ca:	df 92       	push	r13
     8cc:	ef 92       	push	r14
     8ce:	ff 92       	push	r15
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	df 93       	push	r29
     8d6:	cf 93       	push	r28
     8d8:	0f 92       	push	r0
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	7b 01       	movw	r14, r22
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     8e0:	07 eb       	ldi	r16, 0xB7	; 183
     8e2:	1d e0       	ldi	r17, 0x0D	; 13
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     8e4:	aa 24       	eor	r10, r10
     8e6:	bb 24       	eor	r11, r11
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     8e8:	26 e1       	ldi	r18, 0x16	; 22
     8ea:	c2 2e       	mov	r12, r18
     8ec:	22 e0       	ldi	r18, 0x02	; 2
     8ee:	d2 2e       	mov	r13, r18
     8f0:	1e c0       	rjmp	.+60     	; 0x92e <TCP_TCPTask+0x76>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     8f2:	80 91 fb 13 	lds	r24, 0x13FB
     8f6:	81 30       	cpi	r24, 0x01	; 1
     8f8:	89 f4       	brne	.+34     	; 0x91c <TCP_TCPTask+0x64>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     8fa:	ac 9c       	mul	r10, r12
     8fc:	c0 01       	movw	r24, r0
     8fe:	ad 9c       	mul	r10, r13
     900:	90 0d       	add	r25, r0
     902:	bc 9c       	mul	r11, r12
     904:	90 0d       	add	r25, r0
     906:	11 24       	eor	r1, r1
     908:	bc 01       	movw	r22, r24
     90a:	69 53       	subi	r22, 0x39	; 57
     90c:	72 4f       	sbci	r23, 0xF2	; 242
     90e:	e0 91 fc 13 	lds	r30, 0x13FC
     912:	f0 91 fd 13 	lds	r31, 0x13FD
     916:	89 54       	subi	r24, 0x49	; 73
     918:	92 4f       	sbci	r25, 0xF2	; 242
     91a:	09 95       	icall
     91c:	08 94       	sec
     91e:	a1 1c       	adc	r10, r1
     920:	b1 1c       	adc	r11, r1
     922:	0a 5e       	subi	r16, 0xEA	; 234
     924:	1d 4f       	sbci	r17, 0xFD	; 253
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     926:	83 e0       	ldi	r24, 0x03	; 3
     928:	a8 16       	cp	r10, r24
     92a:	b1 04       	cpc	r11, r1
     92c:	59 f0       	breq	.+22     	; 0x944 <TCP_TCPTask+0x8c>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     92e:	20 91 f9 13 	lds	r18, 0x13F9
     932:	30 91 fa 13 	lds	r19, 0x13FA
     936:	f8 01       	movw	r30, r16
     938:	80 81       	ld	r24, Z
     93a:	91 81       	ldd	r25, Z+1	; 0x01
     93c:	28 17       	cp	r18, r24
     93e:	39 07       	cpc	r19, r25
     940:	69 f7       	brne	.-38     	; 0x91c <TCP_TCPTask+0x64>
     942:	d7 cf       	rjmp	.-82     	; 0x8f2 <TCP_TCPTask+0x3a>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     944:	f7 01       	movw	r30, r14
     946:	e4 52       	subi	r30, 0x24	; 36
     948:	fa 4f       	sbci	r31, 0xFA	; 250
     94a:	80 81       	ld	r24, Z
     94c:	91 81       	ldd	r25, Z+1	; 0x01
     94e:	00 97       	sbiw	r24, 0x00	; 0
     950:	09 f0       	breq	.+2      	; 0x954 <TCP_TCPTask+0x9c>
     952:	ec c0       	rjmp	.+472    	; 0xb2c <TCP_TCPTask+0x274>
     954:	e9 ec       	ldi	r30, 0xC9	; 201
     956:	ff e0       	ldi	r31, 0x0F	; 15
     958:	aa 24       	eor	r10, r10
     95a:	bb 24       	eor	r11, r11

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     95c:	80 81       	ld	r24, Z
     95e:	88 23       	and	r24, r24
     960:	09 f4       	brne	.+2      	; 0x964 <TCP_TCPTask+0xac>
     962:	da c0       	rjmp	.+436    	; 0xb18 <TCP_TCPTask+0x260>
     964:	81 81       	ldd	r24, Z+1	; 0x01
     966:	88 23       	and	r24, r24
     968:	09 f4       	brne	.+2      	; 0x96c <TCP_TCPTask+0xb4>
     96a:	d6 c0       	rjmp	.+428    	; 0xb18 <TCP_TCPTask+0x260>
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
     96c:	87 01       	movw	r16, r14
     96e:	02 5f       	subi	r16, 0xF2	; 242
     970:	1f 4f       	sbci	r17, 0xFF	; 255
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
     972:	92 e2       	ldi	r25, 0x22	; 34
     974:	49 2e       	mov	r4, r25
     976:	51 2c       	mov	r5, r1
     978:	4e 0c       	add	r4, r14
     97a:	5f 1c       	adc	r5, r15
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     97c:	86 e1       	ldi	r24, 0x16	; 22
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	a8 9e       	mul	r10, r24
     982:	30 01       	movw	r6, r0
     984:	a9 9e       	mul	r10, r25
     986:	70 0c       	add	r7, r0
     988:	b8 9e       	mul	r11, r24
     98a:	70 0c       	add	r7, r0
     98c:	11 24       	eor	r1, r1
     98e:	87 eb       	ldi	r24, 0xB7	; 183
     990:	c8 2e       	mov	r12, r24
     992:	8d e0       	ldi	r24, 0x0D	; 13
     994:	d8 2e       	mov	r13, r24
     996:	c6 0c       	add	r12, r6
     998:	d7 1c       	adc	r13, r7
     99a:	f6 01       	movw	r30, r12
     99c:	80 88       	ldd	r8, Z+16	; 0x10
     99e:	91 88       	ldd	r9, Z+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     9a0:	80 81       	ld	r24, Z
     9a2:	91 81       	ldd	r25, Z+1	; 0x01
     9a4:	f7 01       	movw	r30, r14
     9a6:	93 a3       	std	Z+35, r25	; 0x23
     9a8:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     9aa:	f6 01       	movw	r30, r12
     9ac:	82 81       	ldd	r24, Z+2	; 0x02
     9ae:	93 81       	ldd	r25, Z+3	; 0x03
     9b0:	f2 01       	movw	r30, r4
     9b2:	93 83       	std	Z+3, r25	; 0x03
     9b4:	82 83       	std	Z+2, r24	; 0x02
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     9b6:	f6 01       	movw	r30, r12
     9b8:	64 85       	ldd	r22, Z+12	; 0x0c
     9ba:	75 85       	ldd	r23, Z+13	; 0x0d
     9bc:	86 85       	ldd	r24, Z+14	; 0x0e
     9be:	97 85       	ldd	r25, Z+15	; 0x0f
     9c0:	ef de       	rcall	.-546    	; 0x7a0 <SwapEndian_32>
     9c2:	f2 01       	movw	r30, r4
     9c4:	64 83       	std	Z+4, r22	; 0x04
     9c6:	75 83       	std	Z+5, r23	; 0x05
     9c8:	86 83       	std	Z+6, r24	; 0x06
     9ca:	97 83       	std	Z+7, r25	; 0x07
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     9cc:	f6 01       	movw	r30, r12
     9ce:	60 85       	ldd	r22, Z+8	; 0x08
     9d0:	71 85       	ldd	r23, Z+9	; 0x09
     9d2:	82 85       	ldd	r24, Z+10	; 0x0a
     9d4:	93 85       	ldd	r25, Z+11	; 0x0b
     9d6:	e4 de       	rcall	.-568    	; 0x7a0 <SwapEndian_32>
     9d8:	f2 01       	movw	r30, r4
     9da:	60 87       	std	Z+8, r22	; 0x08
     9dc:	71 87       	std	Z+9, r23	; 0x09
     9de:	82 87       	std	Z+10, r24	; 0x0a
     9e0:	93 87       	std	Z+11, r25	; 0x0b
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
     9e2:	24 85       	ldd	r18, Z+12	; 0x0c
     9e4:	2f 70       	andi	r18, 0x0F	; 15
     9e6:	20 65       	ori	r18, 0x50	; 80
     9e8:	24 87       	std	Z+12, r18	; 0x0c
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	92 e0       	ldi	r25, 0x02	; 2
     9ee:	29 83       	std	Y+1, r18	; 0x01
     9f0:	dd de       	rcall	.-582    	; 0x7ac <SwapEndian_16>
     9f2:	f2 01       	movw	r30, r4
     9f4:	97 87       	std	Z+15, r25	; 0x0f
     9f6:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     9f8:	80 e1       	ldi	r24, 0x10	; 16
     9fa:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
     9fc:	13 8a       	std	Z+19, r1	; 0x13
     9fe:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
     a00:	11 8a       	std	Z+17, r1	; 0x11
     a02:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
     a04:	29 81       	ldd	r18, Y+1	; 0x01
     a06:	20 7f       	andi	r18, 0xF0	; 240
     a08:	24 87       	std	Z+12, r18	; 0x0c
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
     a0a:	a7 01       	movw	r20, r14
     a0c:	4a 5c       	subi	r20, 0xCA	; 202
     a0e:	5f 4f       	sbci	r21, 0xFF	; 255
			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
			TCPHeaderOUT->UrgentPointer        = 0;
			TCPHeaderOUT->Checksum             = 0;
			TCPHeaderOUT->Reserved             = 0;

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     a10:	93 01       	movw	r18, r6
     a12:	27 53       	subi	r18, 0x37	; 55
     a14:	32 4f       	sbci	r19, 0xF2	; 242
     a16:	ca 01       	movw	r24, r20
     a18:	b9 01       	movw	r22, r18
     a1a:	a4 01       	movw	r20, r8
     a1c:	0e 94 38 16 	call	0x2c70	; 0x2c70 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     a20:	94 01       	movw	r18, r8
     a22:	40 e0       	ldi	r20, 0x00	; 0
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	f6 01       	movw	r30, r12
     a28:	84 85       	ldd	r24, Z+12	; 0x0c
     a2a:	95 85       	ldd	r25, Z+13	; 0x0d
     a2c:	a6 85       	ldd	r26, Z+14	; 0x0e
     a2e:	b7 85       	ldd	r27, Z+15	; 0x0f
     a30:	28 0f       	add	r18, r24
     a32:	39 1f       	adc	r19, r25
     a34:	4a 1f       	adc	r20, r26
     a36:	5b 1f       	adc	r21, r27
     a38:	24 87       	std	Z+12, r18	; 0x0c
     a3a:	35 87       	std	Z+13, r19	; 0x0d
     a3c:	46 87       	std	Z+14, r20	; 0x0e
     a3e:	57 87       	std	Z+15, r21	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     a40:	94 01       	movw	r18, r8
     a42:	2c 5e       	subi	r18, 0xEC	; 236
     a44:	3f 4f       	sbci	r19, 0xFF	; 255
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
     a46:	a3 01       	movw	r20, r6
     a48:	45 54       	subi	r20, 0x45	; 69
     a4a:	52 4f       	sbci	r21, 0xF2	; 242

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     a4c:	c2 01       	movw	r24, r4
     a4e:	6c eb       	ldi	r22, 0xBC	; 188
     a50:	71 e0       	ldi	r23, 0x01	; 1
     a52:	b0 de       	rcall	.-672    	; 0x7b4 <TCP_Checksum16>
     a54:	f2 01       	movw	r30, r4
     a56:	91 8b       	std	Z+17, r25	; 0x11
     a58:	80 8b       	std	Z+16, r24	; 0x10
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     a5a:	88 e2       	ldi	r24, 0x28	; 40
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	88 0e       	add	r8, r24
     a60:	99 1e       	adc	r9, r25
     a62:	c4 01       	movw	r24, r8
     a64:	a3 de       	rcall	.-698    	; 0x7ac <SwapEndian_16>
     a66:	f8 01       	movw	r30, r16
     a68:	93 83       	std	Z+3, r25	; 0x03
     a6a:	82 83       	std	Z+2, r24	; 0x02
			IPHeaderOUT->TypeOfService      = 0;
     a6c:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     a6e:	85 e4       	ldi	r24, 0x45	; 69
     a70:	f7 01       	movw	r30, r14
     a72:	86 87       	std	Z+14, r24	; 0x0e
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     a74:	f8 01       	movw	r30, r16
     a76:	16 82       	std	Z+6, r1	; 0x06
     a78:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
     a7a:	15 82       	std	Z+5, r1	; 0x05
     a7c:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
     a7e:	13 86       	std	Z+11, r1	; 0x0b
     a80:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     a82:	86 e0       	ldi	r24, 0x06	; 6
     a84:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     a86:	80 e8       	ldi	r24, 0x80	; 128
     a88:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     a8a:	80 91 bc 01 	lds	r24, 0x01BC
     a8e:	90 91 bd 01 	lds	r25, 0x01BD
     a92:	a0 91 be 01 	lds	r26, 0x01BE
     a96:	b0 91 bf 01 	lds	r27, 0x01BF
     a9a:	84 87       	std	Z+12, r24	; 0x0c
     a9c:	95 87       	std	Z+13, r25	; 0x0d
     a9e:	a6 87       	std	Z+14, r26	; 0x0e
     aa0:	b7 87       	std	Z+15, r27	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     aa2:	f6 01       	movw	r30, r12
     aa4:	84 81       	ldd	r24, Z+4	; 0x04
     aa6:	95 81       	ldd	r25, Z+5	; 0x05
     aa8:	a6 81       	ldd	r26, Z+6	; 0x06
     aaa:	b7 81       	ldd	r27, Z+7	; 0x07
     aac:	f8 01       	movw	r30, r16
     aae:	80 8b       	std	Z+16, r24	; 0x10
     ab0:	91 8b       	std	Z+17, r25	; 0x11
     ab2:	a2 8b       	std	Z+18, r26	; 0x12
     ab4:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     ab6:	c8 01       	movw	r24, r16
     ab8:	64 e1       	ldi	r22, 0x14	; 20
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	f2 dd       	rcall	.-1052   	; 0x6a2 <Ethernet_Checksum16>
     abe:	f8 01       	movw	r30, r16
     ac0:	93 87       	std	Z+11, r25	; 0x0b
     ac2:	82 87       	std	Z+10, r24	; 0x0a

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     ac4:	d7 01       	movw	r26, r14
     ac6:	16 96       	adiw	r26, 0x06	; 6
     ac8:	e6 eb       	ldi	r30, 0xB6	; 182
     aca:	f1 e0       	ldi	r31, 0x01	; 1
     acc:	86 e0       	ldi	r24, 0x06	; 6
     ace:	01 90       	ld	r0, Z+
     ad0:	0d 92       	st	X+, r0
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	e1 f7       	brne	.-8      	; 0xace <TCP_TCPTask+0x216>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     ad6:	d7 01       	movw	r26, r14
     ad8:	ee ec       	ldi	r30, 0xCE	; 206
     ada:	f1 e0       	ldi	r31, 0x01	; 1
     adc:	86 e0       	ldi	r24, 0x06	; 6
     ade:	01 90       	ld	r0, Z+
     ae0:	0d 92       	st	X+, r0
     ae2:	81 50       	subi	r24, 0x01	; 1
     ae4:	e1 f7       	brne	.-8      	; 0xade <TCP_TCPTask+0x226>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	98 e0       	ldi	r25, 0x08	; 8
     aea:	60 de       	rcall	.-832    	; 0x7ac <SwapEndian_16>
     aec:	f7 01       	movw	r30, r14
     aee:	95 87       	std	Z+13, r25	; 0x0d
     af0:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     af2:	e4 52       	subi	r30, 0x24	; 36
     af4:	fa 4f       	sbci	r31, 0xFA	; 250
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);

			PacketSize += sizeof(Ethernet_Frame_Header_t);
     af6:	c4 01       	movw	r24, r8
     af8:	0e 96       	adiw	r24, 0x0e	; 14

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     afa:	91 83       	std	Z+1, r25	; 0x01
     afc:	80 83       	st	Z, r24

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     afe:	86 e1       	ldi	r24, 0x16	; 22
     b00:	92 e0       	ldi	r25, 0x02	; 2
     b02:	a8 9e       	mul	r10, r24
     b04:	f0 01       	movw	r30, r0
     b06:	a9 9e       	mul	r10, r25
     b08:	f0 0d       	add	r31, r0
     b0a:	b8 9e       	mul	r11, r24
     b0c:	f0 0d       	add	r31, r0
     b0e:	11 24       	eor	r1, r1
     b10:	e6 53       	subi	r30, 0x36	; 54
     b12:	f0 4f       	sbci	r31, 0xF0	; 240
     b14:	10 82       	st	Z, r1

			break;
     b16:	0a c0       	rjmp	.+20     	; 0xb2c <TCP_TCPTask+0x274>
     b18:	08 94       	sec
     b1a:	a1 1c       	adc	r10, r1
     b1c:	b1 1c       	adc	r11, r1
     b1e:	ea 5e       	subi	r30, 0xEA	; 234
     b20:	fd 4f       	sbci	r31, 0xFD	; 253
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b22:	83 e0       	ldi	r24, 0x03	; 3
     b24:	a8 16       	cp	r10, r24
     b26:	b1 04       	cpc	r11, r1
     b28:	09 f0       	breq	.+2      	; 0xb2c <TCP_TCPTask+0x274>
     b2a:	18 cf       	rjmp	.-464    	; 0x95c <TCP_TCPTask+0xa4>
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     b2c:	0f 90       	pop	r0
     b2e:	cf 91       	pop	r28
     b30:	df 91       	pop	r29
     b32:	1f 91       	pop	r17
     b34:	0f 91       	pop	r16
     b36:	ff 90       	pop	r15
     b38:	ef 90       	pop	r14
     b3a:	df 90       	pop	r13
     b3c:	cf 90       	pop	r12
     b3e:	bf 90       	pop	r11
     b40:	af 90       	pop	r10
     b42:	9f 90       	pop	r9
     b44:	8f 90       	pop	r8
     b46:	7f 90       	pop	r7
     b48:	6f 90       	pop	r6
     b4a:	5f 90       	pop	r5
     b4c:	4f 90       	pop	r4
     b4e:	08 95       	ret

00000b50 <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     b50:	10 92 fb 13 	sts	0x13FB, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     b54:	8a e0       	ldi	r24, 0x0A	; 10
     b56:	80 93 cc 0f 	sts	0x0FCC, r24
     b5a:	80 93 e2 11 	sts	0x11E2, r24
     b5e:	80 93 f8 13 	sts	0x13F8, r24
}
     b62:	08 95       	ret

00000b64 <TCP_SetPortState>:

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     b64:	20 91 f9 13 	lds	r18, 0x13F9
     b68:	30 91 fa 13 	lds	r19, 0x13FA
     b6c:	28 17       	cp	r18, r24
     b6e:	39 07       	cpc	r19, r25
     b70:	51 f0       	breq	.+20     	; 0xb86 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     b72:	61 30       	cpi	r22, 0x01	; 1
     b74:	71 f4       	brne	.+28     	; 0xb92 <TCP_SetPortState+0x2e>
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     b76:	20 91 fb 13 	lds	r18, 0x13FB
     b7a:	22 23       	and	r18, r18
     b7c:	61 f4       	brne	.+24     	; 0xb96 <TCP_SetPortState+0x32>
			{
				PortStateTable[PTableEntry].Port  = Port;
     b7e:	90 93 fa 13 	sts	0x13FA, r25
     b82:	80 93 f9 13 	sts	0x13F9, r24
				PortStateTable[PTableEntry].State = State;
     b86:	60 93 fb 13 	sts	0x13FB, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     b8a:	50 93 fd 13 	sts	0x13FD, r21
     b8e:	40 93 fc 13 	sts	0x13FC, r20
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     b92:	81 e0       	ldi	r24, 0x01	; 1
     b94:	08 95       	ret
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     b96:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     b98:	08 95       	ret

00000b9a <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     b9a:	20 91 f9 13 	lds	r18, 0x13F9
     b9e:	30 91 fa 13 	lds	r19, 0x13FA
     ba2:	28 17       	cp	r18, r24
     ba4:	39 07       	cpc	r19, r25
     ba6:	19 f4       	brne	.+6      	; 0xbae <TCP_GetPortState+0x14>
		  return PortStateTable[PTableEntry].State;
     ba8:	80 91 fb 13 	lds	r24, 0x13FB
     bac:	08 95       	ret
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     bae:	80 e0       	ldi	r24, 0x00	; 0
}
     bb0:	08 95       	ret

00000bb2 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     bb2:	4f 92       	push	r4
     bb4:	5f 92       	push	r5
     bb6:	7f 92       	push	r7
     bb8:	8f 92       	push	r8
     bba:	9f 92       	push	r9
     bbc:	af 92       	push	r10
     bbe:	bf 92       	push	r11
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	6c 01       	movw	r12, r24
     bd2:	5b 01       	movw	r10, r22
     bd4:	4a 01       	movw	r8, r20
     bd6:	72 2e       	mov	r7, r18
			ConnectionStateTable[CSTableEntry].State         = State;
			return true;
		}
	}

	return false;
     bd8:	c7 eb       	ldi	r28, 0xB7	; 183
     bda:	dd e0       	ldi	r29, 0x0D	; 13
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     bdc:	00 e0       	ldi	r16, 0x00	; 0
     bde:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     be0:	36 e1       	ldi	r19, 0x16	; 22
     be2:	43 2e       	mov	r4, r19
     be4:	32 e0       	ldi	r19, 0x02	; 2
     be6:	53 2e       	mov	r5, r19
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     be8:	88 81       	ld	r24, Y
     bea:	99 81       	ldd	r25, Y+1	; 0x01
     bec:	8c 15       	cp	r24, r12
     bee:	9d 05       	cpc	r25, r13
     bf0:	d1 f4       	brne	.+52     	; 0xc26 <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     bf2:	04 9d       	mul	r16, r4
     bf4:	70 01       	movw	r14, r0
     bf6:	05 9d       	mul	r16, r5
     bf8:	f0 0c       	add	r15, r0
     bfa:	14 9d       	mul	r17, r4
     bfc:	f0 0c       	add	r15, r0
     bfe:	11 24       	eor	r1, r1
     c00:	c7 01       	movw	r24, r14
     c02:	85 54       	subi	r24, 0x45	; 69
     c04:	92 4f       	sbci	r25, 0xF2	; 242
     c06:	b5 01       	movw	r22, r10
     c08:	44 e0       	ldi	r20, 0x04	; 4
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c10:	00 97       	sbiw	r24, 0x00	; 0
     c12:	49 f4       	brne	.+18     	; 0xc26 <TCP_SetConnectionState+0x74>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     c14:	8a 81       	ldd	r24, Y+2	; 0x02
     c16:	9b 81       	ldd	r25, Y+3	; 0x03
     c18:	88 15       	cp	r24, r8
     c1a:	99 05       	cpc	r25, r9
     c1c:	21 f4       	brne	.+8      	; 0xc26 <TCP_SetConnectionState+0x74>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     c1e:	f7 01       	movw	r30, r14
     c20:	e4 53       	subi	r30, 0x34	; 52
     c22:	f0 4f       	sbci	r31, 0xF0	; 240
     c24:	33 c0       	rjmp	.+102    	; 0xc8c <TCP_SetConnectionState+0xda>
			return true;
     c26:	0f 5f       	subi	r16, 0xFF	; 255
     c28:	1f 4f       	sbci	r17, 0xFF	; 255
     c2a:	ca 5e       	subi	r28, 0xEA	; 234
     c2c:	dd 4f       	sbci	r29, 0xFD	; 253
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c2e:	03 30       	cpi	r16, 0x03	; 3
     c30:	11 05       	cpc	r17, r1
     c32:	d1 f6       	brne	.-76     	; 0xbe8 <TCP_SetConnectionState+0x36>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c34:	80 91 cc 0f 	lds	r24, 0x0FCC
     c38:	8a 30       	cpi	r24, 0x0A	; 10
     c3a:	51 f0       	breq	.+20     	; 0xc50 <TCP_SetConnectionState+0x9e>
     c3c:	80 91 e2 11 	lds	r24, 0x11E2
     c40:	8a 30       	cpi	r24, 0x0A	; 10
     c42:	41 f0       	breq	.+16     	; 0xc54 <TCP_SetConnectionState+0xa2>
     c44:	80 91 f8 13 	lds	r24, 0x13F8
     c48:	8a 30       	cpi	r24, 0x0A	; 10
     c4a:	19 f5       	brne	.+70     	; 0xc92 <TCP_SetConnectionState+0xe0>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c4c:	22 e0       	ldi	r18, 0x02	; 2
     c4e:	03 c0       	rjmp	.+6      	; 0xc56 <TCP_SetConnectionState+0xa4>
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c50:	20 e0       	ldi	r18, 0x00	; 0
     c52:	01 c0       	rjmp	.+2      	; 0xc56 <TCP_SetConnectionState+0xa4>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c54:	21 e0       	ldi	r18, 0x01	; 1
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     c56:	30 e0       	ldi	r19, 0x00	; 0
     c58:	86 e1       	ldi	r24, 0x16	; 22
     c5a:	92 e0       	ldi	r25, 0x02	; 2
     c5c:	28 9f       	mul	r18, r24
     c5e:	f0 01       	movw	r30, r0
     c60:	29 9f       	mul	r18, r25
     c62:	f0 0d       	add	r31, r0
     c64:	38 9f       	mul	r19, r24
     c66:	f0 0d       	add	r31, r0
     c68:	11 24       	eor	r1, r1
     c6a:	e9 54       	subi	r30, 0x49	; 73
     c6c:	f2 4f       	sbci	r31, 0xF2	; 242
     c6e:	d1 82       	std	Z+1, r13	; 0x01
     c70:	c0 82       	st	Z, r12
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
     c72:	e5 01       	movw	r28, r10
     c74:	88 81       	ld	r24, Y
     c76:	99 81       	ldd	r25, Y+1	; 0x01
     c78:	aa 81       	ldd	r26, Y+2	; 0x02
     c7a:	bb 81       	ldd	r27, Y+3	; 0x03
     c7c:	84 83       	std	Z+4, r24	; 0x04
     c7e:	95 83       	std	Z+5, r25	; 0x05
     c80:	a6 83       	std	Z+6, r26	; 0x06
     c82:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c84:	93 82       	std	Z+3, r9	; 0x03
     c86:	82 82       	std	Z+2, r8	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     c88:	eb 5e       	subi	r30, 0xEB	; 235
     c8a:	fd 4f       	sbci	r31, 0xFD	; 253
     c8c:	70 82       	st	Z, r7
			return true;
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <TCP_SetConnectionState+0xe2>
		}
	}

	return false;
     c92:	80 e0       	ldi	r24, 0x00	; 0
}
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	1f 91       	pop	r17
     c9a:	0f 91       	pop	r16
     c9c:	ff 90       	pop	r15
     c9e:	ef 90       	pop	r14
     ca0:	df 90       	pop	r13
     ca2:	cf 90       	pop	r12
     ca4:	bf 90       	pop	r11
     ca6:	af 90       	pop	r10
     ca8:	9f 90       	pop	r9
     caa:	8f 90       	pop	r8
     cac:	7f 90       	pop	r7
     cae:	5f 90       	pop	r5
     cb0:	4f 90       	pop	r4
     cb2:	08 95       	ret

00000cb4 <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
     cb4:	6f 92       	push	r6
     cb6:	7f 92       	push	r7
     cb8:	8f 92       	push	r8
     cba:	9f 92       	push	r9
     cbc:	af 92       	push	r10
     cbe:	bf 92       	push	r11
     cc0:	cf 92       	push	r12
     cc2:	df 92       	push	r13
     cc4:	ef 92       	push	r14
     cc6:	ff 92       	push	r15
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	cf 93       	push	r28
     cce:	df 93       	push	r29
     cd0:	6c 01       	movw	r12, r24
     cd2:	5b 01       	movw	r10, r22
     cd4:	4a 01       	movw	r8, r20
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     cd6:	c7 eb       	ldi	r28, 0xB7	; 183
     cd8:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
     cda:	00 e0       	ldi	r16, 0x00	; 0
     cdc:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     cde:	46 e1       	ldi	r20, 0x16	; 22
     ce0:	64 2e       	mov	r6, r20
     ce2:	42 e0       	ldi	r20, 0x02	; 2
     ce4:	74 2e       	mov	r7, r20
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     ce6:	88 81       	ld	r24, Y
     ce8:	99 81       	ldd	r25, Y+1	; 0x01
     cea:	8c 15       	cp	r24, r12
     cec:	9d 05       	cpc	r25, r13
     cee:	d9 f4       	brne	.+54     	; 0xd26 <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     cf0:	06 9d       	mul	r16, r6
     cf2:	70 01       	movw	r14, r0
     cf4:	07 9d       	mul	r16, r7
     cf6:	f0 0c       	add	r15, r0
     cf8:	16 9d       	mul	r17, r6
     cfa:	f0 0c       	add	r15, r0
     cfc:	11 24       	eor	r1, r1
     cfe:	c7 01       	movw	r24, r14
     d00:	85 54       	subi	r24, 0x45	; 69
     d02:	92 4f       	sbci	r25, 0xF2	; 242
     d04:	b5 01       	movw	r22, r10
     d06:	44 e0       	ldi	r20, 0x04	; 4
     d08:	50 e0       	ldi	r21, 0x00	; 0
     d0a:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d0e:	00 97       	sbiw	r24, 0x00	; 0
     d10:	51 f4       	brne	.+20     	; 0xd26 <TCP_GetConnectionState+0x72>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d12:	8a 81       	ldd	r24, Y+2	; 0x02
     d14:	9b 81       	ldd	r25, Y+3	; 0x03
     d16:	88 15       	cp	r24, r8
     d18:	99 05       	cpc	r25, r9
     d1a:	29 f4       	brne	.+10     	; 0xd26 <TCP_GetConnectionState+0x72>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     d1c:	f7 01       	movw	r30, r14
     d1e:	e4 53       	subi	r30, 0x34	; 52
     d20:	f0 4f       	sbci	r31, 0xF0	; 240
     d22:	80 81       	ld	r24, Z
     d24:	08 c0       	rjmp	.+16     	; 0xd36 <TCP_GetConnectionState+0x82>
     d26:	0f 5f       	subi	r16, 0xFF	; 255
     d28:	1f 4f       	sbci	r17, 0xFF	; 255
     d2a:	ca 5e       	subi	r28, 0xEA	; 234
     d2c:	dd 4f       	sbci	r29, 0xFD	; 253
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d2e:	03 30       	cpi	r16, 0x03	; 3
     d30:	11 05       	cpc	r17, r1
     d32:	c9 f6       	brne	.-78     	; 0xce6 <TCP_GetConnectionState+0x32>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
     d34:	8a e0       	ldi	r24, 0x0A	; 10
}
     d36:	df 91       	pop	r29
     d38:	cf 91       	pop	r28
     d3a:	1f 91       	pop	r17
     d3c:	0f 91       	pop	r16
     d3e:	ff 90       	pop	r15
     d40:	ef 90       	pop	r14
     d42:	df 90       	pop	r13
     d44:	cf 90       	pop	r12
     d46:	bf 90       	pop	r11
     d48:	af 90       	pop	r10
     d4a:	9f 90       	pop	r9
     d4c:	8f 90       	pop	r8
     d4e:	7f 90       	pop	r7
     d50:	6f 90       	pop	r6
     d52:	08 95       	ret

00000d54 <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
     d54:	6f 92       	push	r6
     d56:	7f 92       	push	r7
     d58:	8f 92       	push	r8
     d5a:	9f 92       	push	r9
     d5c:	af 92       	push	r10
     d5e:	bf 92       	push	r11
     d60:	cf 92       	push	r12
     d62:	df 92       	push	r13
     d64:	ef 92       	push	r14
     d66:	ff 92       	push	r15
     d68:	0f 93       	push	r16
     d6a:	1f 93       	push	r17
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	6c 01       	movw	r12, r24
     d72:	5b 01       	movw	r10, r22
     d74:	4a 01       	movw	r8, r20
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     d76:	c7 eb       	ldi	r28, 0xB7	; 183
     d78:	dd e0       	ldi	r29, 0x0D	; 13
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
     d7a:	00 e0       	ldi	r16, 0x00	; 0
     d7c:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d7e:	56 e1       	ldi	r21, 0x16	; 22
     d80:	65 2e       	mov	r6, r21
     d82:	52 e0       	ldi	r21, 0x02	; 2
     d84:	75 2e       	mov	r7, r21
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d86:	88 81       	ld	r24, Y
     d88:	99 81       	ldd	r25, Y+1	; 0x01
     d8a:	8c 15       	cp	r24, r12
     d8c:	9d 05       	cpc	r25, r13
     d8e:	d1 f4       	brne	.+52     	; 0xdc4 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     d90:	06 9d       	mul	r16, r6
     d92:	70 01       	movw	r14, r0
     d94:	07 9d       	mul	r16, r7
     d96:	f0 0c       	add	r15, r0
     d98:	16 9d       	mul	r17, r6
     d9a:	f0 0c       	add	r15, r0
     d9c:	11 24       	eor	r1, r1
     d9e:	c7 01       	movw	r24, r14
     da0:	85 54       	subi	r24, 0x45	; 69
     da2:	92 4f       	sbci	r25, 0xF2	; 242
     da4:	b5 01       	movw	r22, r10
     da6:	44 e0       	ldi	r20, 0x04	; 4
     da8:	50 e0       	ldi	r21, 0x00	; 0
     daa:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     dae:	00 97       	sbiw	r24, 0x00	; 0
     db0:	49 f4       	brne	.+18     	; 0xdc4 <TCP_GetConnectionInfo+0x70>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     db2:	8a 81       	ldd	r24, Y+2	; 0x02
     db4:	9b 81       	ldd	r25, Y+3	; 0x03
     db6:	88 15       	cp	r24, r8
     db8:	99 05       	cpc	r25, r9
     dba:	21 f4       	brne	.+8      	; 0xdc4 <TCP_GetConnectionInfo+0x70>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     dbc:	97 01       	movw	r18, r14
     dbe:	21 54       	subi	r18, 0x41	; 65
     dc0:	32 4f       	sbci	r19, 0xF2	; 242
     dc2:	09 c0       	rjmp	.+18     	; 0xdd6 <TCP_GetConnectionInfo+0x82>
     dc4:	0f 5f       	subi	r16, 0xFF	; 255
     dc6:	1f 4f       	sbci	r17, 0xFF	; 255
     dc8:	ca 5e       	subi	r28, 0xEA	; 234
     dca:	dd 4f       	sbci	r29, 0xFD	; 253
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     dcc:	03 30       	cpi	r16, 0x03	; 3
     dce:	11 05       	cpc	r17, r1
     dd0:	d1 f6       	brne	.-76     	; 0xd86 <TCP_GetConnectionInfo+0x32>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
     dd2:	20 e0       	ldi	r18, 0x00	; 0
     dd4:	30 e0       	ldi	r19, 0x00	; 0
}
     dd6:	c9 01       	movw	r24, r18
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	ff 90       	pop	r15
     de2:	ef 90       	pop	r14
     de4:	df 90       	pop	r13
     de6:	cf 90       	pop	r12
     de8:	bf 90       	pop	r11
     dea:	af 90       	pop	r10
     dec:	9f 90       	pop	r9
     dee:	8f 90       	pop	r8
     df0:	7f 90       	pop	r7
     df2:	6f 90       	pop	r6
     df4:	08 95       	ret

00000df6 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     df6:	4f 92       	push	r4
     df8:	5f 92       	push	r5
     dfa:	6f 92       	push	r6
     dfc:	7f 92       	push	r7
     dfe:	8f 92       	push	r8
     e00:	9f 92       	push	r9
     e02:	af 92       	push	r10
     e04:	bf 92       	push	r11
     e06:	cf 92       	push	r12
     e08:	df 92       	push	r13
     e0a:	ef 92       	push	r14
     e0c:	ff 92       	push	r15
     e0e:	0f 93       	push	r16
     e10:	1f 93       	push	r17
     e12:	df 93       	push	r29
     e14:	cf 93       	push	r28
     e16:	0f 92       	push	r0
     e18:	cd b7       	in	r28, 0x3d	; 61
     e1a:	de b7       	in	r29, 0x3e	; 62
     e1c:	2b 01       	movw	r4, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     e1e:	3c 01       	movw	r6, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     e20:	8a 01       	movw	r16, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     e22:	cb 01       	movw	r24, r22
     e24:	77 dc       	rcall	.-1810   	; 0x714 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     e26:	d2 01       	movw	r26, r4
     e28:	12 96       	adiw	r26, 0x02	; 2
     e2a:	ed 90       	ld	r14, X+
     e2c:	fc 90       	ld	r15, X
     e2e:	13 97       	sbiw	r26, 0x03	; 3
     e30:	c7 01       	movw	r24, r14
     e32:	b3 de       	rcall	.-666    	; 0xb9a <TCP_GetPortState>
     e34:	81 30       	cpi	r24, 0x01	; 1
     e36:	09 f0       	breq	.+2      	; 0xe3a <TCP_ProcessTCPPacket+0x44>
     e38:	a2 c1       	rjmp	.+836    	; 0x117e <TCP_ProcessTCPPacket+0x388>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     e3a:	f2 01       	movw	r30, r4
     e3c:	85 85       	ldd	r24, Z+13	; 0x0d
     e3e:	81 ff       	sbrs	r24, 1
     e40:	08 c0       	rjmp	.+16     	; 0xe52 <TCP_ProcessTCPPacket+0x5c>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     e42:	b3 01       	movw	r22, r6
     e44:	64 5f       	subi	r22, 0xF4	; 244
     e46:	7f 4f       	sbci	r23, 0xFF	; 255
     e48:	40 81       	ld	r20, Z
     e4a:	51 81       	ldd	r21, Z+1	; 0x01
     e4c:	c7 01       	movw	r24, r14
     e4e:	20 e0       	ldi	r18, 0x00	; 0
     e50:	b0 de       	rcall	.-672    	; 0xbb2 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     e52:	d2 01       	movw	r26, r4
     e54:	1d 96       	adiw	r26, 0x0d	; 13
     e56:	2c 91       	ld	r18, X
     e58:	1d 97       	sbiw	r26, 0x0d	; 13
     e5a:	12 96       	adiw	r26, 0x02	; 2
     e5c:	ed 90       	ld	r14, X+
     e5e:	fc 90       	ld	r15, X
     e60:	13 97       	sbiw	r26, 0x03	; 3
     e62:	8c e0       	ldi	r24, 0x0C	; 12
     e64:	a8 2e       	mov	r10, r24
     e66:	b1 2c       	mov	r11, r1
     e68:	a6 0c       	add	r10, r6
     e6a:	b7 1c       	adc	r11, r7
     e6c:	cd 90       	ld	r12, X+
     e6e:	dc 90       	ld	r13, X
     e70:	11 97       	sbiw	r26, 0x01	; 1
     e72:	22 ff       	sbrs	r18, 2
     e74:	0a c0       	rjmp	.+20     	; 0xe8a <TCP_ProcessTCPPacket+0x94>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     e76:	c7 01       	movw	r24, r14
     e78:	b5 01       	movw	r22, r10
     e7a:	a6 01       	movw	r20, r12
     e7c:	2a e0       	ldi	r18, 0x0A	; 10
     e7e:	99 de       	rcall	.-718    	; 0xbb2 <TCP_SetConnectionState>
     e80:	88 23       	and	r24, r24
     e82:	09 f4       	brne	.+2      	; 0xe86 <TCP_ProcessTCPPacket+0x90>
     e84:	b2 c1       	rjmp	.+868    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     e86:	84 e1       	ldi	r24, 0x14	; 20
     e88:	23 c1       	rjmp	.+582    	; 0x10d0 <TCP_ProcessTCPPacket+0x2da>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     e8a:	c7 01       	movw	r24, r14
     e8c:	b5 01       	movw	r22, r10
     e8e:	a6 01       	movw	r20, r12
     e90:	29 83       	std	Y+1, r18	; 0x01
     e92:	10 df       	rcall	.-480    	; 0xcb4 <TCP_GetConnectionState>
     e94:	29 81       	ldd	r18, Y+1	; 0x01
     e96:	84 30       	cpi	r24, 0x04	; 4
     e98:	09 f4       	brne	.+2      	; 0xe9c <TCP_ProcessTCPPacket+0xa6>
     e9a:	32 c1       	rjmp	.+612    	; 0x1100 <TCP_ProcessTCPPacket+0x30a>
     e9c:	85 30       	cpi	r24, 0x05	; 5
     e9e:	48 f4       	brcc	.+18     	; 0xeb2 <TCP_ProcessTCPPacket+0xbc>
     ea0:	82 30       	cpi	r24, 0x02	; 2
     ea2:	09 f4       	brne	.+2      	; 0xea6 <TCP_ProcessTCPPacket+0xb0>
     ea4:	43 c0       	rjmp	.+134    	; 0xf2c <TCP_ProcessTCPPacket+0x136>
     ea6:	83 30       	cpi	r24, 0x03	; 3
     ea8:	08 f0       	brcs	.+2      	; 0xeac <TCP_ProcessTCPPacket+0xb6>
     eaa:	60 c0       	rjmp	.+192    	; 0xf6c <TCP_ProcessTCPPacket+0x176>
     eac:	88 23       	and	r24, r24
     eae:	59 f0       	breq	.+22     	; 0xec6 <TCP_ProcessTCPPacket+0xd0>
     eb0:	9c c1       	rjmp	.+824    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
     eb2:	86 30       	cpi	r24, 0x06	; 6
     eb4:	09 f4       	brne	.+2      	; 0xeb8 <TCP_ProcessTCPPacket+0xc2>
     eb6:	5a c1       	rjmp	.+692    	; 0x116c <TCP_ProcessTCPPacket+0x376>
     eb8:	86 30       	cpi	r24, 0x06	; 6
     eba:	08 f4       	brcc	.+2      	; 0xebe <TCP_ProcessTCPPacket+0xc8>
     ebc:	2b c1       	rjmp	.+598    	; 0x1114 <TCP_ProcessTCPPacket+0x31e>
     ebe:	87 30       	cpi	r24, 0x07	; 7
     ec0:	09 f0       	breq	.+2      	; 0xec4 <TCP_ProcessTCPPacket+0xce>
     ec2:	93 c1       	rjmp	.+806    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
     ec4:	08 c1       	rjmp	.+528    	; 0x10d6 <TCP_ProcessTCPPacket+0x2e0>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     ec6:	22 30       	cpi	r18, 0x02	; 2
     ec8:	09 f0       	breq	.+2      	; 0xecc <TCP_ProcessTCPPacket+0xd6>
     eca:	8f c1       	rjmp	.+798    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     ecc:	c7 01       	movw	r24, r14
     ece:	b5 01       	movw	r22, r10
     ed0:	a6 01       	movw	r20, r12
     ed2:	6f de       	rcall	.-802    	; 0xbb2 <TCP_SetConnectionState>
     ed4:	88 23       	and	r24, r24
     ed6:	41 f1       	breq	.+80     	; 0xf28 <TCP_ProcessTCPPacket+0x132>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     ed8:	82 e1       	ldi	r24, 0x12	; 18
     eda:	d8 01       	movw	r26, r16
     edc:	1d 96       	adiw	r26, 0x0d	; 13
     ede:	8c 93       	st	X, r24

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     ee0:	f2 01       	movw	r30, r4
     ee2:	40 81       	ld	r20, Z
     ee4:	51 81       	ldd	r21, Z+1	; 0x01
     ee6:	82 81       	ldd	r24, Z+2	; 0x02
     ee8:	93 81       	ldd	r25, Z+3	; 0x03
     eea:	b5 01       	movw	r22, r10
     eec:	33 df       	rcall	.-410    	; 0xd54 <TCP_GetConnectionInfo>
     eee:	7c 01       	movw	r14, r24

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     ef0:	d2 01       	movw	r26, r4
     ef2:	14 96       	adiw	r26, 0x04	; 4
     ef4:	6d 91       	ld	r22, X+
     ef6:	7d 91       	ld	r23, X+
     ef8:	8d 91       	ld	r24, X+
     efa:	9c 91       	ld	r25, X
     efc:	17 97       	sbiw	r26, 0x07	; 7
     efe:	50 dc       	rcall	.-1888   	; 0x7a0 <SwapEndian_32>
     f00:	6f 5f       	subi	r22, 0xFF	; 255
     f02:	7f 4f       	sbci	r23, 0xFF	; 255
     f04:	8f 4f       	sbci	r24, 0xFF	; 255
     f06:	9f 4f       	sbci	r25, 0xFF	; 255
     f08:	f7 01       	movw	r30, r14
     f0a:	60 83       	st	Z, r22
     f0c:	71 83       	std	Z+1, r23	; 0x01
     f0e:	82 83       	std	Z+2, r24	; 0x02
     f10:	93 83       	std	Z+3, r25	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
     f12:	d7 01       	movw	r26, r14
     f14:	14 96       	adiw	r26, 0x04	; 4
     f16:	1d 92       	st	X+, r1
     f18:	1d 92       	st	X+, r1
     f1a:	1d 92       	st	X+, r1
     f1c:	1c 92       	st	X, r1
     f1e:	17 97       	sbiw	r26, 0x07	; 7
							ConnectionInfo->Buffer.InUse      = false;
     f20:	e4 5f       	subi	r30, 0xF4	; 244
     f22:	fd 4f       	sbci	r31, 0xFD	; 253
     f24:	10 82       	st	Z, r1
     f26:	76 c1       	rjmp	.+748    	; 0x1214 <TCP_ProcessTCPPacket+0x41e>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     f28:	84 e0       	ldi	r24, 0x04	; 4
     f2a:	d2 c0       	rjmp	.+420    	; 0x10d0 <TCP_ProcessTCPPacket+0x2da>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     f2c:	20 31       	cpi	r18, 0x10	; 16
     f2e:	09 f0       	breq	.+2      	; 0xf32 <TCP_ProcessTCPPacket+0x13c>
     f30:	5c c1       	rjmp	.+696    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f32:	c7 01       	movw	r24, r14
     f34:	b5 01       	movw	r22, r10
     f36:	a6 01       	movw	r20, r12
     f38:	23 e0       	ldi	r18, 0x03	; 3
     f3a:	3b de       	rcall	.-906    	; 0xbb2 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f3c:	d2 01       	movw	r26, r4
     f3e:	4d 91       	ld	r20, X+
     f40:	5c 91       	ld	r21, X
     f42:	11 97       	sbiw	r26, 0x01	; 1
     f44:	12 96       	adiw	r26, 0x02	; 2
     f46:	8d 91       	ld	r24, X+
     f48:	9c 91       	ld	r25, X
     f4a:	13 97       	sbiw	r26, 0x03	; 3
     f4c:	b5 01       	movw	r22, r10
     f4e:	02 df       	rcall	.-508    	; 0xd54 <TCP_GetConnectionInfo>
     f50:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     f52:	24 81       	ldd	r18, Z+4	; 0x04
     f54:	35 81       	ldd	r19, Z+5	; 0x05
     f56:	46 81       	ldd	r20, Z+6	; 0x06
     f58:	57 81       	ldd	r21, Z+7	; 0x07
     f5a:	2f 5f       	subi	r18, 0xFF	; 255
     f5c:	3f 4f       	sbci	r19, 0xFF	; 255
     f5e:	4f 4f       	sbci	r20, 0xFF	; 255
     f60:	5f 4f       	sbci	r21, 0xFF	; 255
     f62:	24 83       	std	Z+4, r18	; 0x04
     f64:	35 83       	std	Z+5, r19	; 0x05
     f66:	46 83       	std	Z+6, r20	; 0x06
     f68:	57 83       	std	Z+7, r21	; 0x07
     f6a:	3f c1       	rjmp	.+638    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     f6c:	21 31       	cpi	r18, 0x11	; 17
     f6e:	69 f5       	brne	.+90     	; 0xfca <TCP_ProcessTCPPacket+0x1d4>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     f70:	f8 01       	movw	r30, r16
     f72:	25 87       	std	Z+13, r18	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f74:	d2 01       	movw	r26, r4
     f76:	4d 91       	ld	r20, X+
     f78:	5c 91       	ld	r21, X
     f7a:	11 97       	sbiw	r26, 0x01	; 1
     f7c:	12 96       	adiw	r26, 0x02	; 2
     f7e:	8d 91       	ld	r24, X+
     f80:	9c 91       	ld	r25, X
     f82:	13 97       	sbiw	r26, 0x03	; 3
     f84:	b5 01       	movw	r22, r10
     f86:	26 e0       	ldi	r18, 0x06	; 6
     f88:	14 de       	rcall	.-984    	; 0xbb2 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     f8a:	f2 01       	movw	r30, r4
     f8c:	40 81       	ld	r20, Z
     f8e:	51 81       	ldd	r21, Z+1	; 0x01
     f90:	82 81       	ldd	r24, Z+2	; 0x02
     f92:	93 81       	ldd	r25, Z+3	; 0x03
     f94:	b5 01       	movw	r22, r10
     f96:	de de       	rcall	.-580    	; 0xd54 <TCP_GetConnectionInfo>
     f98:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     f9a:	80 81       	ld	r24, Z
     f9c:	91 81       	ldd	r25, Z+1	; 0x01
     f9e:	a2 81       	ldd	r26, Z+2	; 0x02
     fa0:	b3 81       	ldd	r27, Z+3	; 0x03
     fa2:	01 96       	adiw	r24, 0x01	; 1
     fa4:	a1 1d       	adc	r26, r1
     fa6:	b1 1d       	adc	r27, r1
     fa8:	80 83       	st	Z, r24
     faa:	91 83       	std	Z+1, r25	; 0x01
     fac:	a2 83       	std	Z+2, r26	; 0x02
     fae:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     fb0:	24 81       	ldd	r18, Z+4	; 0x04
     fb2:	35 81       	ldd	r19, Z+5	; 0x05
     fb4:	46 81       	ldd	r20, Z+6	; 0x06
     fb6:	57 81       	ldd	r21, Z+7	; 0x07
     fb8:	2f 5f       	subi	r18, 0xFF	; 255
     fba:	3f 4f       	sbci	r19, 0xFF	; 255
     fbc:	4f 4f       	sbci	r20, 0xFF	; 255
     fbe:	5f 4f       	sbci	r21, 0xFF	; 255
     fc0:	24 83       	std	Z+4, r18	; 0x04
     fc2:	35 83       	std	Z+5, r19	; 0x05
     fc4:	46 83       	std	Z+6, r20	; 0x06
     fc6:	57 83       	std	Z+7, r21	; 0x07
     fc8:	25 c1       	rjmp	.+586    	; 0x1214 <TCP_ProcessTCPPacket+0x41e>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     fca:	20 31       	cpi	r18, 0x10	; 16
     fcc:	19 f0       	breq	.+6      	; 0xfd4 <TCP_ProcessTCPPacket+0x1de>
     fce:	28 31       	cpi	r18, 0x18	; 24
     fd0:	09 f0       	breq	.+2      	; 0xfd4 <TCP_ProcessTCPPacket+0x1de>
     fd2:	0b c1       	rjmp	.+534    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
     fd4:	c7 01       	movw	r24, r14
     fd6:	b5 01       	movw	r22, r10
     fd8:	a6 01       	movw	r20, r12
     fda:	bc de       	rcall	.-648    	; 0xd54 <TCP_GetConnectionInfo>
     fdc:	7c 01       	movw	r14, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     fde:	fc 01       	movw	r30, r24
     fe0:	e4 5f       	subi	r30, 0xF4	; 244
     fe2:	fd 4f       	sbci	r31, 0xFD	; 253
     fe4:	80 81       	ld	r24, Z
     fe6:	88 23       	and	r24, r24
     fe8:	89 f4       	brne	.+34     	; 0x100c <TCP_ProcessTCPPacket+0x216>
     fea:	d7 01       	movw	r26, r14
     fec:	a5 5f       	subi	r26, 0xF5	; 245
     fee:	bd 4f       	sbci	r27, 0xFD	; 253
     ff0:	8c 91       	ld	r24, X
     ff2:	88 23       	and	r24, r24
     ff4:	59 f4       	brne	.+22     	; 0x100c <TCP_ProcessTCPPacket+0x216>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     ff6:	d7 01       	movw	r26, r14
     ff8:	a6 5f       	subi	r26, 0xF6	; 246
     ffa:	bd 4f       	sbci	r27, 0xFD	; 253
     ffc:	1c 92       	st	X, r1
							ConnectionInfo->Buffer.InUse     = true;
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    1002:	d7 01       	movw	r26, r14
    1004:	19 96       	adiw	r26, 0x09	; 9
    1006:	1c 92       	st	X, r1
    1008:	1e 92       	st	-X, r1
    100a:	18 97       	sbiw	r26, 0x08	; 8
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    100c:	f7 01       	movw	r30, r14
    100e:	e6 5f       	subi	r30, 0xF6	; 246
    1010:	fd 4f       	sbci	r31, 0xFD	; 253
    1012:	80 81       	ld	r24, Z
    1014:	88 23       	and	r24, r24
    1016:	09 f0       	breq	.+2      	; 0x101a <TCP_ProcessTCPPacket+0x224>
    1018:	e5 c0       	rjmp	.+458    	; 0x11e4 <TCP_ProcessTCPPacket+0x3ee>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    101a:	f7 01       	movw	r30, r14
    101c:	80 84       	ldd	r8, Z+8	; 0x08
    101e:	91 84       	ldd	r9, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	8f 16       	cp	r8, r31
    1024:	f2 e0       	ldi	r31, 0x02	; 2
    1026:	9f 06       	cpc	r9, r31
    1028:	09 f4       	brne	.+2      	; 0x102c <TCP_ProcessTCPPacket+0x236>
    102a:	dc c0       	rjmp	.+440    	; 0x11e4 <TCP_ProcessTCPPacket+0x3ee>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    102c:	d2 01       	movw	r26, r4
    102e:	1c 96       	adiw	r26, 0x0c	; 12
    1030:	cc 90       	ld	r12, X
    1032:	c2 94       	swap	r12
    1034:	ff e0       	ldi	r31, 0x0F	; 15
    1036:	cf 22       	and	r12, r31
    1038:	dd 24       	eor	r13, r13
    103a:	cc 0c       	add	r12, r12
    103c:	dd 1c       	adc	r13, r13
    103e:	cc 0c       	add	r12, r12
    1040:	dd 1c       	adc	r13, r13
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1042:	f3 01       	movw	r30, r6
    1044:	82 81       	ldd	r24, Z+2	; 0x02
    1046:	93 81       	ldd	r25, Z+3	; 0x03
    1048:	b1 db       	rcall	.-2206   	; 0x7ac <SwapEndian_16>

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    104a:	d3 01       	movw	r26, r6
    104c:	2c 91       	ld	r18, X
    104e:	2f 70       	andi	r18, 0x0F	; 15
    1050:	30 e0       	ldi	r19, 0x00	; 0
    1052:	22 0f       	add	r18, r18
    1054:	33 1f       	adc	r19, r19
    1056:	22 0f       	add	r18, r18
    1058:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    105a:	5c 01       	movw	r10, r24
    105c:	a2 1a       	sub	r10, r18
    105e:	b3 0a       	sbc	r11, r19
    1060:	ac 18       	sub	r10, r12
    1062:	bd 08       	sbc	r11, r13

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    1064:	97 01       	movw	r18, r14
    1066:	26 5f       	subi	r18, 0xF6	; 246
    1068:	3f 4f       	sbci	r19, 0xFF	; 255
    106a:	28 0d       	add	r18, r8
    106c:	39 1d       	adc	r19, r9
    106e:	c4 0c       	add	r12, r4
    1070:	d5 1c       	adc	r13, r5
    1072:	c9 01       	movw	r24, r18
    1074:	b6 01       	movw	r22, r12
    1076:	a5 01       	movw	r20, r10
    1078:	0e 94 38 16 	call	0x2c70	; 0x2c70 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    107c:	95 01       	movw	r18, r10
    107e:	40 e0       	ldi	r20, 0x00	; 0
    1080:	50 e0       	ldi	r21, 0x00	; 0
    1082:	f7 01       	movw	r30, r14
    1084:	80 81       	ld	r24, Z
    1086:	91 81       	ldd	r25, Z+1	; 0x01
    1088:	a2 81       	ldd	r26, Z+2	; 0x02
    108a:	b3 81       	ldd	r27, Z+3	; 0x03
    108c:	82 0f       	add	r24, r18
    108e:	93 1f       	adc	r25, r19
    1090:	a4 1f       	adc	r26, r20
    1092:	b5 1f       	adc	r27, r21
    1094:	80 83       	st	Z, r24
    1096:	91 83       	std	Z+1, r25	; 0x01
    1098:	a2 83       	std	Z+2, r26	; 0x02
    109a:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    109c:	80 85       	ldd	r24, Z+8	; 0x08
    109e:	91 85       	ldd	r25, Z+9	; 0x09
    10a0:	8a 0d       	add	r24, r10
    10a2:	9b 1d       	adc	r25, r11
    10a4:	91 87       	std	Z+9, r25	; 0x09
    10a6:	80 87       	std	Z+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    10a8:	f2 e0       	ldi	r31, 0x02	; 2
    10aa:	80 30       	cpi	r24, 0x00	; 0
    10ac:	9f 07       	cpc	r25, r31
    10ae:	31 f0       	breq	.+12     	; 0x10bc <TCP_ProcessTCPPacket+0x2c6>
    10b0:	d2 01       	movw	r26, r4
    10b2:	1d 96       	adiw	r26, 0x0d	; 13
    10b4:	8c 91       	ld	r24, X
    10b6:	1d 97       	sbiw	r26, 0x0d	; 13
    10b8:	83 ff       	sbrs	r24, 3
    10ba:	97 c0       	rjmp	.+302    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
							{
								ConnectionInfo->Buffer.InUse = false;
    10bc:	f7 01       	movw	r30, r14
    10be:	e4 5f       	subi	r30, 0xF4	; 244
    10c0:	fd 4f       	sbci	r31, 0xFD	; 253
    10c2:	10 82       	st	Z, r1
								ConnectionInfo->Buffer.Ready = true;
    10c4:	f7 01       	movw	r30, r14
    10c6:	e5 5f       	subi	r30, 0xF5	; 245
    10c8:	fd 4f       	sbci	r31, 0xFD	; 253
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	80 83       	st	Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    10ce:	80 e1       	ldi	r24, 0x10	; 16
    10d0:	f8 01       	movw	r30, r16
    10d2:	85 87       	std	Z+13, r24	; 0x0d
    10d4:	9f c0       	rjmp	.+318    	; 0x1214 <TCP_ProcessTCPPacket+0x41e>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    10d6:	c7 01       	movw	r24, r14
    10d8:	b5 01       	movw	r22, r10
    10da:	a6 01       	movw	r20, r12
    10dc:	3b de       	rcall	.-906    	; 0xd54 <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    10de:	21 e1       	ldi	r18, 0x11	; 17
    10e0:	d8 01       	movw	r26, r16
    10e2:	1d 96       	adiw	r26, 0x0d	; 13
    10e4:	2c 93       	st	X, r18
    10e6:	1d 97       	sbiw	r26, 0x0d	; 13
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    10e8:	fc 01       	movw	r30, r24
    10ea:	e4 5f       	subi	r30, 0xF4	; 244
    10ec:	fd 4f       	sbci	r31, 0xFD	; 253
    10ee:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    10f0:	f2 01       	movw	r30, r4
    10f2:	40 81       	ld	r20, Z
    10f4:	51 81       	ldd	r21, Z+1	; 0x01
    10f6:	82 81       	ldd	r24, Z+2	; 0x02
    10f8:	93 81       	ldd	r25, Z+3	; 0x03
    10fa:	b5 01       	movw	r22, r10
    10fc:	24 e0       	ldi	r18, 0x04	; 4
    10fe:	34 c0       	rjmp	.+104    	; 0x1168 <TCP_ProcessTCPPacket+0x372>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1100:	21 31       	cpi	r18, 0x11	; 17
    1102:	59 f0       	breq	.+22     	; 0x111a <TCP_ProcessTCPPacket+0x324>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1104:	20 31       	cpi	r18, 0x10	; 16
    1106:	09 f0       	breq	.+2      	; 0x110a <TCP_ProcessTCPPacket+0x314>
    1108:	70 c0       	rjmp	.+224    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    110a:	c7 01       	movw	r24, r14
    110c:	b5 01       	movw	r22, r10
    110e:	a6 01       	movw	r20, r12
    1110:	25 e0       	ldi	r18, 0x05	; 5
    1112:	33 c0       	rjmp	.+102    	; 0x117a <TCP_ProcessTCPPacket+0x384>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1114:	21 31       	cpi	r18, 0x11	; 17
    1116:	09 f0       	breq	.+2      	; 0x111a <TCP_ProcessTCPPacket+0x324>
    1118:	68 c0       	rjmp	.+208    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    111a:	c7 01       	movw	r24, r14
    111c:	b5 01       	movw	r22, r10
    111e:	a6 01       	movw	r20, r12
    1120:	19 de       	rcall	.-974    	; 0xd54 <TCP_GetConnectionInfo>
    1122:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1124:	80 e1       	ldi	r24, 0x10	; 16
    1126:	d8 01       	movw	r26, r16
    1128:	1d 96       	adiw	r26, 0x0d	; 13
    112a:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    112c:	80 81       	ld	r24, Z
    112e:	91 81       	ldd	r25, Z+1	; 0x01
    1130:	a2 81       	ldd	r26, Z+2	; 0x02
    1132:	b3 81       	ldd	r27, Z+3	; 0x03
    1134:	01 96       	adiw	r24, 0x01	; 1
    1136:	a1 1d       	adc	r26, r1
    1138:	b1 1d       	adc	r27, r1
    113a:	80 83       	st	Z, r24
    113c:	91 83       	std	Z+1, r25	; 0x01
    113e:	a2 83       	std	Z+2, r26	; 0x02
    1140:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1142:	24 81       	ldd	r18, Z+4	; 0x04
    1144:	35 81       	ldd	r19, Z+5	; 0x05
    1146:	46 81       	ldd	r20, Z+6	; 0x06
    1148:	57 81       	ldd	r21, Z+7	; 0x07
    114a:	2f 5f       	subi	r18, 0xFF	; 255
    114c:	3f 4f       	sbci	r19, 0xFF	; 255
    114e:	4f 4f       	sbci	r20, 0xFF	; 255
    1150:	5f 4f       	sbci	r21, 0xFF	; 255
    1152:	24 83       	std	Z+4, r18	; 0x04
    1154:	35 83       	std	Z+5, r19	; 0x05
    1156:	46 83       	std	Z+6, r20	; 0x06
    1158:	57 83       	std	Z+7, r21	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    115a:	f2 01       	movw	r30, r4
    115c:	40 81       	ld	r20, Z
    115e:	51 81       	ldd	r21, Z+1	; 0x01
    1160:	82 81       	ldd	r24, Z+2	; 0x02
    1162:	93 81       	ldd	r25, Z+3	; 0x03
    1164:	b5 01       	movw	r22, r10
    1166:	2a e0       	ldi	r18, 0x0A	; 10
    1168:	24 dd       	rcall	.-1464   	; 0xbb2 <TCP_SetConnectionState>
    116a:	54 c0       	rjmp	.+168    	; 0x1214 <TCP_ProcessTCPPacket+0x41e>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    116c:	20 31       	cpi	r18, 0x10	; 16
    116e:	09 f0       	breq	.+2      	; 0x1172 <TCP_ProcessTCPPacket+0x37c>
    1170:	3c c0       	rjmp	.+120    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1172:	c7 01       	movw	r24, r14
    1174:	b5 01       	movw	r22, r10
    1176:	a6 01       	movw	r20, r12
    1178:	2a e0       	ldi	r18, 0x0A	; 10
    117a:	1b dd       	rcall	.-1482   	; 0xbb2 <TCP_SetConnectionState>
    117c:	36 c0       	rjmp	.+108    	; 0x11ea <TCP_ProcessTCPPacket+0x3f4>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    117e:	84 e1       	ldi	r24, 0x14	; 20
    1180:	d8 01       	movw	r26, r16
    1182:	1d 96       	adiw	r26, 0x0d	; 13
    1184:	8c 93       	st	X, r24
    1186:	1d 97       	sbiw	r26, 0x0d	; 13
    1188:	45 c0       	rjmp	.+138    	; 0x1214 <TCP_ProcessTCPPacket+0x41e>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    118a:	80 e0       	ldi	r24, 0x00	; 0
    118c:	92 e0       	ldi	r25, 0x02	; 2
    118e:	09 c0       	rjmp	.+18     	; 0x11a2 <TCP_ProcessTCPPacket+0x3ac>
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1190:	d7 01       	movw	r26, r14
    1192:	18 96       	adiw	r26, 0x08	; 8
    1194:	2d 91       	ld	r18, X+
    1196:	3c 91       	ld	r19, X
    1198:	19 97       	sbiw	r26, 0x09	; 9
    119a:	80 e0       	ldi	r24, 0x00	; 0
    119c:	92 e0       	ldi	r25, 0x02	; 2
    119e:	82 1b       	sub	r24, r18
    11a0:	93 0b       	sbc	r25, r19
    11a2:	04 db       	rcall	.-2552   	; 0x7ac <SwapEndian_16>
    11a4:	f8 01       	movw	r30, r16
    11a6:	97 87       	std	Z+15, r25	; 0x0f
    11a8:	86 87       	std	Z+14, r24	; 0x0e

		TCPHeaderOUT->UrgentPointer        = 0;
    11aa:	d8 01       	movw	r26, r16
    11ac:	53 96       	adiw	r26, 0x13	; 19
    11ae:	1c 92       	st	X, r1
    11b0:	1e 92       	st	-X, r1
    11b2:	52 97       	sbiw	r26, 0x12	; 18
		TCPHeaderOUT->Checksum             = 0;
    11b4:	51 96       	adiw	r26, 0x11	; 17
    11b6:	1c 92       	st	X, r1
    11b8:	1e 92       	st	-X, r1
    11ba:	50 97       	sbiw	r26, 0x10	; 16
		TCPHeaderOUT->Reserved             = 0;
    11bc:	1c 96       	adiw	r26, 0x0c	; 12
    11be:	8c 91       	ld	r24, X
    11c0:	1c 97       	sbiw	r26, 0x0c	; 12
    11c2:	80 7f       	andi	r24, 0xF0	; 240
    11c4:	1c 96       	adiw	r26, 0x0c	; 12
    11c6:	8c 93       	st	X, r24

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    11c8:	b3 01       	movw	r22, r6
    11ca:	60 5f       	subi	r22, 0xF0	; 240
    11cc:	7f 4f       	sbci	r23, 0xFF	; 255
    11ce:	c8 01       	movw	r24, r16
    11d0:	a5 01       	movw	r20, r10
    11d2:	24 e1       	ldi	r18, 0x14	; 20
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	ee da       	rcall	.-2596   	; 0x7b4 <TCP_Checksum16>
    11d8:	f8 01       	movw	r30, r16
    11da:	91 8b       	std	Z+17, r25	; 0x11
    11dc:	80 8b       	std	Z+16, r24	; 0x10
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    11de:	24 e1       	ldi	r18, 0x14	; 20
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	05 c0       	rjmp	.+10     	; 0x11ee <TCP_ProcessTCPPacket+0x3f8>
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    11e4:	2f ef       	ldi	r18, 0xFF	; 255
    11e6:	3f ef       	ldi	r19, 0xFF	; 255
    11e8:	02 c0       	rjmp	.+4      	; 0x11ee <TCP_ProcessTCPPacket+0x3f8>
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    11ea:	20 e0       	ldi	r18, 0x00	; 0
    11ec:	30 e0       	ldi	r19, 0x00	; 0
}
    11ee:	c9 01       	movw	r24, r18
    11f0:	0f 90       	pop	r0
    11f2:	cf 91       	pop	r28
    11f4:	df 91       	pop	r29
    11f6:	1f 91       	pop	r17
    11f8:	0f 91       	pop	r16
    11fa:	ff 90       	pop	r15
    11fc:	ef 90       	pop	r14
    11fe:	df 90       	pop	r13
    1200:	cf 90       	pop	r12
    1202:	bf 90       	pop	r11
    1204:	af 90       	pop	r10
    1206:	9f 90       	pop	r9
    1208:	8f 90       	pop	r8
    120a:	7f 90       	pop	r7
    120c:	6f 90       	pop	r6
    120e:	5f 90       	pop	r5
    1210:	4f 90       	pop	r4
    1212:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1214:	d2 01       	movw	r26, r4
    1216:	12 96       	adiw	r26, 0x02	; 2
    1218:	cd 90       	ld	r12, X+
    121a:	dc 90       	ld	r13, X
    121c:	13 97       	sbiw	r26, 0x03	; 3
    121e:	6c e0       	ldi	r22, 0x0C	; 12
    1220:	a6 2e       	mov	r10, r22
    1222:	b1 2c       	mov	r11, r1
    1224:	a6 0c       	add	r10, r6
    1226:	b7 1c       	adc	r11, r7
    1228:	4d 91       	ld	r20, X+
    122a:	5c 91       	ld	r21, X
    122c:	c6 01       	movw	r24, r12
    122e:	b5 01       	movw	r22, r10
    1230:	91 dd       	rcall	.-1246   	; 0xd54 <TCP_GetConnectionInfo>
    1232:	7c 01       	movw	r14, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1234:	f8 01       	movw	r30, r16
    1236:	d1 82       	std	Z+1, r13	; 0x01
    1238:	c0 82       	st	Z, r12
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    123a:	d2 01       	movw	r26, r4
    123c:	8d 91       	ld	r24, X+
    123e:	9c 91       	ld	r25, X
    1240:	93 83       	std	Z+3, r25	; 0x03
    1242:	82 83       	std	Z+2, r24	; 0x02
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1244:	f7 01       	movw	r30, r14
    1246:	64 81       	ldd	r22, Z+4	; 0x04
    1248:	75 81       	ldd	r23, Z+5	; 0x05
    124a:	86 81       	ldd	r24, Z+6	; 0x06
    124c:	97 81       	ldd	r25, Z+7	; 0x07
    124e:	a8 da       	rcall	.-2736   	; 0x7a0 <SwapEndian_32>
    1250:	d8 01       	movw	r26, r16
    1252:	14 96       	adiw	r26, 0x04	; 4
    1254:	6d 93       	st	X+, r22
    1256:	7d 93       	st	X+, r23
    1258:	8d 93       	st	X+, r24
    125a:	9c 93       	st	X, r25
    125c:	17 97       	sbiw	r26, 0x07	; 7
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    125e:	f7 01       	movw	r30, r14
    1260:	60 81       	ld	r22, Z
    1262:	71 81       	ldd	r23, Z+1	; 0x01
    1264:	82 81       	ldd	r24, Z+2	; 0x02
    1266:	93 81       	ldd	r25, Z+3	; 0x03
    1268:	9b da       	rcall	.-2762   	; 0x7a0 <SwapEndian_32>
    126a:	d8 01       	movw	r26, r16
    126c:	18 96       	adiw	r26, 0x08	; 8
    126e:	6d 93       	st	X+, r22
    1270:	7d 93       	st	X+, r23
    1272:	8d 93       	st	X+, r24
    1274:	9c 93       	st	X, r25
    1276:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1278:	1c 96       	adiw	r26, 0x0c	; 12
    127a:	8c 91       	ld	r24, X
    127c:	1c 97       	sbiw	r26, 0x0c	; 12
    127e:	8f 70       	andi	r24, 0x0F	; 15
    1280:	80 65       	ori	r24, 0x50	; 80
    1282:	1c 96       	adiw	r26, 0x0c	; 12
    1284:	8c 93       	st	X, r24
    1286:	1c 97       	sbiw	r26, 0x0c	; 12

		if (!(ConnectionInfo->Buffer.InUse))
    1288:	f7 01       	movw	r30, r14
    128a:	e4 5f       	subi	r30, 0xF4	; 244
    128c:	fd 4f       	sbci	r31, 0xFD	; 253
    128e:	80 81       	ld	r24, Z
    1290:	88 23       	and	r24, r24
    1292:	09 f4       	brne	.+2      	; 0x1296 <TCP_ProcessTCPPacket+0x4a0>
    1294:	7a cf       	rjmp	.-268    	; 0x118a <TCP_ProcessTCPPacket+0x394>
    1296:	7c cf       	rjmp	.-264    	; 0x1190 <TCP_ProcessTCPPacket+0x39a>

00001298 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
    1298:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
    129a:	89 2f       	mov	r24, r25
    129c:	92 2f       	mov	r25, r18
    129e:	08 95       	ret

000012a0 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    12a0:	ef 92       	push	r14
    12a2:	ff 92       	push	r15
    12a4:	0f 93       	push	r16
    12a6:	1f 93       	push	r17
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	7c 01       	movw	r14, r24
    12ae:	eb 01       	movw	r28, r22
    12b0:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    12b2:	cb 01       	movw	r24, r22
    12b4:	30 da       	rcall	.-2976   	; 0x716 <DecodeUDPHeader>

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    12b6:	8a 81       	ldd	r24, Y+2	; 0x02
    12b8:	9b 81       	ldd	r25, Y+3	; 0x03
    12ba:	ee df       	rcall	.-36     	; 0x1298 <SwapEndian_16>
    12bc:	83 34       	cpi	r24, 0x43	; 67
    12be:	91 05       	cpc	r25, r1
    12c0:	f1 f4       	brne	.+60     	; 0x12fe <UDP_ProcessUDPPacket+0x5e>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    12c2:	be 01       	movw	r22, r28
    12c4:	68 5f       	subi	r22, 0xF8	; 248
    12c6:	7f 4f       	sbci	r23, 0xFF	; 255
    12c8:	a8 01       	movw	r20, r16
    12ca:	48 5f       	subi	r20, 0xF8	; 248
    12cc:	5f 4f       	sbci	r21, 0xFF	; 255
    12ce:	c7 01       	movw	r24, r14
    12d0:	20 d0       	rcall	.+64     	; 0x1312 <DHCP_ProcessDHCPPacket>
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    12d2:	18 16       	cp	r1, r24
    12d4:	19 06       	cpc	r1, r25
    12d6:	9c f4       	brge	.+38     	; 0x12fe <UDP_ProcessUDPPacket+0x5e>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    12d8:	2a 81       	ldd	r18, Y+2	; 0x02
    12da:	3b 81       	ldd	r19, Y+3	; 0x03
    12dc:	f8 01       	movw	r30, r16
    12de:	31 83       	std	Z+1, r19	; 0x01
    12e0:	20 83       	st	Z, r18
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    12e2:	28 81       	ld	r18, Y
    12e4:	39 81       	ldd	r19, Y+1	; 0x01
    12e6:	33 83       	std	Z+3, r19	; 0x03
    12e8:	22 83       	std	Z+2, r18	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    12ea:	17 82       	std	Z+7, r1	; 0x07
    12ec:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    12ee:	ec 01       	movw	r28, r24
    12f0:	28 96       	adiw	r28, 0x08	; 8
    12f2:	ce 01       	movw	r24, r28
    12f4:	d1 df       	rcall	.-94     	; 0x1298 <SwapEndian_16>
    12f6:	f8 01       	movw	r30, r16
    12f8:	95 83       	std	Z+5, r25	; 0x05
    12fa:	84 83       	std	Z+4, r24	; 0x04

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    12fc:	02 c0       	rjmp	.+4      	; 0x1302 <UDP_ProcessUDPPacket+0x62>
	}

	return NO_RESPONSE;
    12fe:	c0 e0       	ldi	r28, 0x00	; 0
    1300:	d0 e0       	ldi	r29, 0x00	; 0
}
    1302:	ce 01       	movw	r24, r28
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	1f 91       	pop	r17
    130a:	0f 91       	pop	r16
    130c:	ff 90       	pop	r15
    130e:	ef 90       	pop	r14
    1310:	08 95       	ret

00001312 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1312:	8f 92       	push	r8
    1314:	9f 92       	push	r9
    1316:	af 92       	push	r10
    1318:	bf 92       	push	r11
    131a:	cf 92       	push	r12
    131c:	df 92       	push	r13
    131e:	ef 92       	push	r14
    1320:	ff 92       	push	r15
    1322:	0f 93       	push	r16
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	8b 01       	movw	r16, r22
    132c:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    132e:	4c 01       	movw	r8, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    1330:	80 ef       	ldi	r24, 0xF0	; 240
    1332:	e8 2e       	mov	r14, r24
    1334:	f1 2c       	mov	r15, r1
    1336:	e6 0e       	add	r14, r22
    1338:	f7 1e       	adc	r15, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    133a:	cb 01       	movw	r24, r22
    133c:	ed d9       	rcall	.-3110   	; 0x718 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    133e:	6e 01       	movw	r12, r28
    1340:	ec 2f       	mov	r30, r28
    1342:	fd 2d       	mov	r31, r13
    1344:	80 ef       	ldi	r24, 0xF0	; 240
    1346:	df 01       	movw	r26, r30
    1348:	1d 92       	st	X+, r1
    134a:	8a 95       	dec	r24
    134c:	e9 f7       	brne	.-6      	; 0x1348 <DHCP_ProcessDHCPPacket+0x36>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    134e:	f8 01       	movw	r30, r16
    1350:	81 81       	ldd	r24, Z+1	; 0x01
    1352:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    1354:	82 e0       	ldi	r24, 0x02	; 2
    1356:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    1358:	82 81       	ldd	r24, Z+2	; 0x02
    135a:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    135c:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    135e:	84 81       	ldd	r24, Z+4	; 0x04
    1360:	95 81       	ldd	r25, Z+5	; 0x05
    1362:	a6 81       	ldd	r26, Z+6	; 0x06
    1364:	b7 81       	ldd	r27, Z+7	; 0x07
    1366:	8c 83       	std	Y+4, r24	; 0x04
    1368:	9d 83       	std	Y+5, r25	; 0x05
    136a:	ae 83       	std	Y+6, r26	; 0x06
    136c:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    136e:	19 86       	std	Y+9, r1	; 0x09
    1370:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    1372:	82 85       	ldd	r24, Z+10	; 0x0a
    1374:	93 85       	ldd	r25, Z+11	; 0x0b
    1376:	9b 87       	std	Y+11, r25	; 0x0b
    1378:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    137a:	a0 90 ca 01 	lds	r10, 0x01CA
    137e:	b0 90 cb 01 	lds	r11, 0x01CB
    1382:	c0 90 cc 01 	lds	r12, 0x01CC
    1386:	d0 90 cd 01 	lds	r13, 0x01CD
    138a:	a8 8a       	std	Y+16, r10	; 0x10
    138c:	b9 8a       	std	Y+17, r11	; 0x11
    138e:	ca 8a       	std	Y+18, r12	; 0x12
    1390:	db 8a       	std	Y+19, r13	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    1392:	b8 01       	movw	r22, r16
    1394:	64 5e       	subi	r22, 0xE4	; 228
    1396:	7f 4f       	sbci	r23, 0xFF	; 255
    1398:	ce 01       	movw	r24, r28
    139a:	4c 96       	adiw	r24, 0x1c	; 28
    139c:	46 e0       	ldi	r20, 0x06	; 6
    139e:	50 e0       	ldi	r21, 0x00	; 0
    13a0:	0e 94 41 16 	call	0x2c82	; 0x2c82 <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    13a4:	fe 01       	movw	r30, r28
    13a6:	e4 51       	subi	r30, 0x14	; 20
    13a8:	ff 4f       	sbci	r31, 0xFF	; 255
    13aa:	83 e6       	ldi	r24, 0x63	; 99
    13ac:	92 e8       	ldi	r25, 0x82	; 130
    13ae:	a3 e5       	ldi	r26, 0x53	; 83
    13b0:	b3 e6       	ldi	r27, 0x63	; 99
    13b2:	80 83       	st	Z, r24
    13b4:	91 83       	std	Z+1, r25	; 0x01
    13b6:	a2 83       	std	Z+2, r26	; 0x02
    13b8:	b3 83       	std	Z+3, r27	; 0x03

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    13ba:	d4 01       	movw	r26, r8
    13bc:	1c 96       	adiw	r26, 0x0c	; 12
    13be:	ad 92       	st	X+, r10
    13c0:	bd 92       	st	X+, r11
    13c2:	cd 92       	st	X+, r12
    13c4:	dc 92       	st	X, r13
    13c6:	1f 97       	sbiw	r26, 0x0f	; 15
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    13c8:	80 91 bc 01 	lds	r24, 0x01BC
    13cc:	90 91 bd 01 	lds	r25, 0x01BD
    13d0:	a0 91 be 01 	lds	r26, 0x01BE
    13d4:	b0 91 bf 01 	lds	r27, 0x01BF
    13d8:	f4 01       	movw	r30, r8
    13da:	80 8b       	std	Z+16, r24	; 0x10
    13dc:	91 8b       	std	Z+17, r25	; 0x11
    13de:	a2 8b       	std	Z+18, r26	; 0x12
    13e0:	b3 8b       	std	Z+19, r27	; 0x13

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    13e2:	59 c0       	rjmp	.+178    	; 0x1496 <DHCP_ProcessDHCPPacket+0x184>
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    13e4:	85 33       	cpi	r24, 0x35	; 53
    13e6:	09 f0       	breq	.+2      	; 0x13ea <DHCP_ProcessDHCPPacket+0xd8>
    13e8:	49 c0       	rjmp	.+146    	; 0x147c <DHCP_ProcessDHCPPacket+0x16a>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    13ea:	d7 01       	movw	r26, r14
    13ec:	12 96       	adiw	r26, 0x02	; 2
    13ee:	f7 01       	movw	r30, r14
    13f0:	82 81       	ldd	r24, Z+2	; 0x02
    13f2:	81 30       	cpi	r24, 0x01	; 1
    13f4:	19 f0       	breq	.+6      	; 0x13fc <DHCP_ProcessDHCPPacket+0xea>
    13f6:	83 30       	cpi	r24, 0x03	; 3
    13f8:	09 f0       	breq	.+2      	; 0x13fc <DHCP_ProcessDHCPPacket+0xea>
    13fa:	42 c0       	rjmp	.+132    	; 0x1480 <DHCP_ProcessDHCPPacket+0x16e>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    13fc:	c0 51       	subi	r28, 0x10	; 16
    13fe:	df 4f       	sbci	r29, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1400:	fe 01       	movw	r30, r28
    1402:	85 e3       	ldi	r24, 0x35	; 53
    1404:	81 93       	st	Z+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	89 83       	std	Y+1, r24	; 0x01
    140a:	ef 01       	movw	r28, r30
    140c:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    140e:	8c 91       	ld	r24, X
    1410:	81 30       	cpi	r24, 0x01	; 1
    1412:	11 f4       	brne	.+4      	; 0x1418 <DHCP_ProcessDHCPPacket+0x106>
    1414:	82 e0       	ldi	r24, 0x02	; 2
    1416:	01 c0       	rjmp	.+2      	; 0x141a <DHCP_ProcessDHCPPacket+0x108>
    1418:	85 e0       	ldi	r24, 0x05	; 5
    141a:	81 83       	std	Z+1, r24	; 0x01
    141c:	de 01       	movw	r26, r28
    141e:	11 96       	adiw	r26, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	89 83       	std	Y+1, r24	; 0x01
    1424:	fd 01       	movw	r30, r26
    1426:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    1428:	84 e0       	ldi	r24, 0x04	; 4
    142a:	11 96       	adiw	r26, 0x01	; 1
    142c:	8c 93       	st	X, r24
    142e:	df 01       	movw	r26, r30
    1430:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1432:	2f ef       	ldi	r18, 0xFF	; 255
    1434:	21 83       	std	Z+1, r18	; 0x01
    1436:	fd 01       	movw	r30, r26
    1438:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    143a:	11 96       	adiw	r26, 0x01	; 1
    143c:	2c 93       	st	X, r18
    143e:	df 01       	movw	r26, r30
    1440:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1442:	21 83       	std	Z+1, r18	; 0x01
    1444:	fd 01       	movw	r30, r26
    1446:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    1448:	11 96       	adiw	r26, 0x01	; 1
    144a:	1c 92       	st	X, r1
    144c:	df 01       	movw	r26, r30
    144e:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    1450:	96 e3       	ldi	r25, 0x36	; 54
    1452:	91 83       	std	Z+1, r25	; 0x01
    1454:	fd 01       	movw	r30, r26
    1456:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    1458:	11 96       	adiw	r26, 0x01	; 1
    145a:	8c 93       	st	X, r24
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    145c:	80 91 bc 01 	lds	r24, 0x01BC
    1460:	90 91 bd 01 	lds	r25, 0x01BD
    1464:	a0 91 be 01 	lds	r26, 0x01BE
    1468:	b0 91 bf 01 	lds	r27, 0x01BF
    146c:	81 83       	std	Z+1, r24	; 0x01
    146e:	92 83       	std	Z+2, r25	; 0x02
    1470:	a3 83       	std	Z+3, r26	; 0x03
    1472:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1474:	25 83       	std	Z+5, r18	; 0x05

				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
    1476:	20 e0       	ldi	r18, 0x00	; 0
    1478:	31 e0       	ldi	r19, 0x01	; 1
    147a:	14 c0       	rjmp	.+40     	; 0x14a4 <DHCP_ProcessDHCPPacket+0x192>
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    147c:	88 23       	and	r24, r24
    147e:	39 f0       	breq	.+14     	; 0x148e <DHCP_ProcessDHCPPacket+0x17c>
    1480:	d7 01       	movw	r26, r14
    1482:	11 96       	adiw	r26, 0x01	; 1
    1484:	8c 91       	ld	r24, X
    1486:	11 97       	sbiw	r26, 0x01	; 1
    1488:	90 e0       	ldi	r25, 0x00	; 0
    148a:	02 96       	adiw	r24, 0x02	; 2
    148c:	02 c0       	rjmp	.+4      	; 0x1492 <DHCP_ProcessDHCPPacket+0x180>
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	e8 0e       	add	r14, r24
    1494:	f9 1e       	adc	r15, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1496:	f7 01       	movw	r30, r14
    1498:	80 81       	ld	r24, Z
    149a:	8f 3f       	cpi	r24, 0xFF	; 255
    149c:	09 f0       	breq	.+2      	; 0x14a0 <DHCP_ProcessDHCPPacket+0x18e>
    149e:	a2 cf       	rjmp	.-188    	; 0x13e4 <DHCP_ProcessDHCPPacket+0xd2>

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	30 e0       	ldi	r19, 0x00	; 0
}
    14a4:	c9 01       	movw	r24, r18
    14a6:	df 91       	pop	r29
    14a8:	cf 91       	pop	r28
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	ff 90       	pop	r15
    14b0:	ef 90       	pop	r14
    14b2:	df 90       	pop	r13
    14b4:	cf 90       	pop	r12
    14b6:	bf 90       	pop	r11
    14b8:	af 90       	pop	r10
    14ba:	9f 90       	pop	r9
    14bc:	8f 90       	pop	r8
    14be:	08 95       	ret

000014c0 <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
    14c0:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
    14c2:	89 2f       	mov	r24, r25
    14c4:	92 2f       	mov	r25, r18
    14c6:	08 95       	ret

000014c8 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    14c8:	cf 92       	push	r12
    14ca:	df 92       	push	r13
    14cc:	ef 92       	push	r14
    14ce:	ff 92       	push	r15
    14d0:	0f 93       	push	r16
    14d2:	1f 93       	push	r17
    14d4:	cf 93       	push	r28
    14d6:	df 93       	push	r29
    14d8:	18 2f       	mov	r17, r24
    14da:	09 2f       	mov	r16, r25
    14dc:	7b 01       	movw	r14, r22
	DecodeARPHeader(InDataStart);
    14de:	17 d9       	rcall	.-3538   	; 0x70e <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    14e0:	c1 2e       	mov	r12, r17
    14e2:	e6 01       	movw	r28, r12
    14e4:	6e 01       	movw	r12, r28
    14e6:	d0 2e       	mov	r13, r16
    14e8:	e6 01       	movw	r28, r12
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    14ea:	8a 81       	ldd	r24, Y+2	; 0x02
    14ec:	9b 81       	ldd	r25, Y+3	; 0x03
    14ee:	e8 df       	rcall	.-48     	; 0x14c0 <SwapEndian_16>
    14f0:	e8 e0       	ldi	r30, 0x08	; 8
    14f2:	80 30       	cpi	r24, 0x00	; 0
    14f4:	9e 07       	cpc	r25, r30
    14f6:	09 f0       	breq	.+2      	; 0x14fa <ARP_ProcessARPPacket+0x32>
    14f8:	5b c0       	rjmp	.+182    	; 0x15b0 <ARP_ProcessARPPacket+0xe8>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
    14fa:	8e 81       	ldd	r24, Y+6	; 0x06
    14fc:	9f 81       	ldd	r25, Y+7	; 0x07
    14fe:	e0 df       	rcall	.-64     	; 0x14c0 <SwapEndian_16>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1500:	81 30       	cpi	r24, 0x01	; 1
    1502:	91 05       	cpc	r25, r1
    1504:	09 f0       	breq	.+2      	; 0x1508 <ARP_ProcessARPPacket+0x40>
    1506:	54 c0       	rjmp	.+168    	; 0x15b0 <ARP_ProcessARPPacket+0xe8>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1508:	c6 01       	movw	r24, r12
    150a:	48 96       	adiw	r24, 0x18	; 24
    150c:	6c eb       	ldi	r22, 0xBC	; 188
    150e:	71 e0       	ldi	r23, 0x01	; 1
    1510:	44 e0       	ldi	r20, 0x04	; 4
    1512:	50 e0       	ldi	r21, 0x00	; 0
    1514:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
    1518:	00 97       	sbiw	r24, 0x00	; 0
    151a:	59 f0       	breq	.+22     	; 0x1532 <ARP_ProcessARPPacket+0x6a>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
    151c:	c6 01       	movw	r24, r12
    151e:	42 96       	adiw	r24, 0x12	; 18
    1520:	66 eb       	ldi	r22, 0xB6	; 182
    1522:	71 e0       	ldi	r23, 0x01	; 1
    1524:	46 e0       	ldi	r20, 0x06	; 6
    1526:	50 e0       	ldi	r21, 0x00	; 0
    1528:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    152c:	00 97       	sbiw	r24, 0x00	; 0
    152e:	09 f0       	breq	.+2      	; 0x1532 <ARP_ProcessARPPacket+0x6a>
    1530:	3f c0       	rjmp	.+126    	; 0x15b0 <ARP_ProcessARPPacket+0xe8>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1532:	87 01       	movw	r16, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1534:	88 81       	ld	r24, Y
    1536:	99 81       	ldd	r25, Y+1	; 0x01
    1538:	f7 01       	movw	r30, r14
    153a:	91 83       	std	Z+1, r25	; 0x01
    153c:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    153e:	8a 81       	ldd	r24, Y+2	; 0x02
    1540:	9b 81       	ldd	r25, Y+3	; 0x03
    1542:	93 83       	std	Z+3, r25	; 0x03
    1544:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1546:	8c 81       	ldd	r24, Y+4	; 0x04
    1548:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    154a:	8d 81       	ldd	r24, Y+5	; 0x05
    154c:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    154e:	82 e0       	ldi	r24, 0x02	; 2
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	b6 df       	rcall	.-148    	; 0x14c0 <SwapEndian_16>
    1554:	f7 01       	movw	r30, r14
    1556:	97 83       	std	Z+7, r25	; 0x07
    1558:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    155a:	d7 01       	movw	r26, r14
    155c:	52 96       	adiw	r26, 0x12	; 18
    155e:	fe 01       	movw	r30, r28
    1560:	38 96       	adiw	r30, 0x08	; 8
    1562:	86 e0       	ldi	r24, 0x06	; 6
    1564:	01 90       	ld	r0, Z+
    1566:	0d 92       	st	X+, r0
    1568:	81 50       	subi	r24, 0x01	; 1
    156a:	e1 f7       	brne	.-8      	; 0x1564 <ARP_ProcessARPPacket+0x9c>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    156c:	8e 85       	ldd	r24, Y+14	; 0x0e
    156e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1570:	a8 89       	ldd	r26, Y+16	; 0x10
    1572:	b9 89       	ldd	r27, Y+17	; 0x11
    1574:	f8 01       	movw	r30, r16
    1576:	80 8f       	std	Z+24, r24	; 0x18
    1578:	91 8f       	std	Z+25, r25	; 0x19
    157a:	a2 8f       	std	Z+26, r26	; 0x1a
    157c:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    157e:	d8 01       	movw	r26, r16
    1580:	18 96       	adiw	r26, 0x08	; 8
    1582:	e6 eb       	ldi	r30, 0xB6	; 182
    1584:	f1 e0       	ldi	r31, 0x01	; 1
    1586:	86 e0       	ldi	r24, 0x06	; 6
    1588:	01 90       	ld	r0, Z+
    158a:	0d 92       	st	X+, r0
    158c:	81 50       	subi	r24, 0x01	; 1
    158e:	e1 f7       	brne	.-8      	; 0x1588 <ARP_ProcessARPPacket+0xc0>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1590:	80 91 bc 01 	lds	r24, 0x01BC
    1594:	90 91 bd 01 	lds	r25, 0x01BD
    1598:	a0 91 be 01 	lds	r26, 0x01BE
    159c:	b0 91 bf 01 	lds	r27, 0x01BF
    15a0:	f8 01       	movw	r30, r16
    15a2:	86 87       	std	Z+14, r24	; 0x0e
    15a4:	97 87       	std	Z+15, r25	; 0x0f
    15a6:	a0 8b       	std	Z+16, r26	; 0x10
    15a8:	b1 8b       	std	Z+17, r27	; 0x11

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    15aa:	2c e1       	ldi	r18, 0x1C	; 28
    15ac:	30 e0       	ldi	r19, 0x00	; 0
    15ae:	02 c0       	rjmp	.+4      	; 0x15b4 <ARP_ProcessARPPacket+0xec>
		}
	}

	return NO_RESPONSE;
    15b0:	20 e0       	ldi	r18, 0x00	; 0
    15b2:	30 e0       	ldi	r19, 0x00	; 0
}
    15b4:	c9 01       	movw	r24, r18
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	ff 90       	pop	r15
    15c0:	ef 90       	pop	r14
    15c2:	df 90       	pop	r13
    15c4:	cf 90       	pop	r12
    15c6:	08 95       	ret

000015c8 <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    15c8:	af 92       	push	r10
    15ca:	bf 92       	push	r11
    15cc:	df 92       	push	r13
    15ce:	ef 92       	push	r14
    15d0:	ff 92       	push	r15
    15d2:	0f 93       	push	r16
    15d4:	1f 93       	push	r17
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	5c 01       	movw	r10, r24
    15dc:	8b 01       	movw	r16, r22
    15de:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    15e0:	cb 01       	movw	r24, r22
    15e2:	96 d8       	rcall	.-3796   	; 0x710 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    15e4:	f8 01       	movw	r30, r16
    15e6:	d0 80       	ld	r13, Z
    15e8:	ff e0       	ldi	r31, 0x0F	; 15
    15ea:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    15ec:	20 e1       	ldi	r18, 0x10	; 16
    15ee:	e2 2e       	mov	r14, r18
    15f0:	f1 2c       	mov	r15, r1
    15f2:	e0 0e       	add	r14, r16
    15f4:	f1 1e       	adc	r15, r17
    15f6:	c7 01       	movw	r24, r14
    15f8:	6c eb       	ldi	r22, 0xBC	; 188
    15fa:	71 e0       	ldi	r23, 0x01	; 1
    15fc:	44 e0       	ldi	r20, 0x04	; 4
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
    1604:	00 97       	sbiw	r24, 0x00	; 0
    1606:	51 f0       	breq	.+20     	; 0x161c <IP_ProcessIPPacket+0x54>
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
    1608:	c7 01       	movw	r24, r14
    160a:	66 ec       	ldi	r22, 0xC6	; 198
    160c:	71 e0       	ldi	r23, 0x01	; 1
    160e:	44 e0       	ldi	r20, 0x04	; 4
    1610:	50 e0       	ldi	r21, 0x00	; 0
    1612:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <memcmp>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1616:	00 97       	sbiw	r24, 0x00	; 0
    1618:	09 f0       	breq	.+2      	; 0x161c <IP_ProcessIPPacket+0x54>
    161a:	58 c0       	rjmp	.+176    	; 0x16cc <IP_ProcessIPPacket+0x104>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    161c:	6d 2d       	mov	r22, r13
    161e:	70 e0       	ldi	r23, 0x00	; 0
    1620:	66 0f       	add	r22, r22
    1622:	77 1f       	adc	r23, r23
    1624:	66 0f       	add	r22, r22
    1626:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1628:	f8 01       	movw	r30, r16
    162a:	81 85       	ldd	r24, Z+9	; 0x09
    162c:	86 30       	cpi	r24, 0x06	; 6
    162e:	69 f0       	breq	.+26     	; 0x164a <IP_ProcessIPPacket+0x82>
    1630:	81 31       	cpi	r24, 0x11	; 17
    1632:	99 f0       	breq	.+38     	; 0x165a <IP_ProcessIPPacket+0x92>
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	09 f0       	breq	.+2      	; 0x163a <IP_ProcessIPPacket+0x72>
    1638:	49 c0       	rjmp	.+146    	; 0x16cc <IP_ProcessIPPacket+0x104>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    163a:	60 0f       	add	r22, r16
    163c:	71 1f       	adc	r23, r17
    163e:	ae 01       	movw	r20, r28
    1640:	4c 5e       	subi	r20, 0xEC	; 236
    1642:	5f 4f       	sbci	r21, 0xFF	; 255
    1644:	c5 01       	movw	r24, r10
    1646:	69 d8       	rcall	.-3886   	; 0x71a <ICMP_ProcessICMPPacket>
    1648:	0f c0       	rjmp	.+30     	; 0x1668 <IP_ProcessIPPacket+0xa0>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    164a:	60 0f       	add	r22, r16
    164c:	71 1f       	adc	r23, r17
    164e:	ae 01       	movw	r20, r28
    1650:	4c 5e       	subi	r20, 0xEC	; 236
    1652:	5f 4f       	sbci	r21, 0xFF	; 255
    1654:	c8 01       	movw	r24, r16
    1656:	cf db       	rcall	.-2146   	; 0xdf6 <TCP_ProcessTCPPacket>
    1658:	07 c0       	rjmp	.+14     	; 0x1668 <IP_ProcessIPPacket+0xa0>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    165a:	60 0f       	add	r22, r16
    165c:	71 1f       	adc	r23, r17
    165e:	ae 01       	movw	r20, r28
    1660:	4c 5e       	subi	r20, 0xEC	; 236
    1662:	5f 4f       	sbci	r21, 0xFF	; 255
    1664:	c8 01       	movw	r24, r16
    1666:	1c de       	rcall	.-968    	; 0x12a0 <UDP_ProcessUDPPacket>
    1668:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    166a:	18 16       	cp	r1, r24
    166c:	19 06       	cpc	r1, r25
    166e:	84 f5       	brge	.+96     	; 0x16d0 <IP_ProcessIPPacket+0x108>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1670:	84 e1       	ldi	r24, 0x14	; 20
    1672:	e8 2e       	mov	r14, r24
    1674:	f1 2c       	mov	r15, r1
    1676:	e2 0e       	add	r14, r18
    1678:	f3 1e       	adc	r15, r19
    167a:	fa 82       	std	Y+2, r15	; 0x02
    167c:	eb 82       	std	Y+3, r14	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    167e:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1680:	85 e4       	ldi	r24, 0x45	; 69
    1682:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1684:	1e 82       	std	Y+6, r1	; 0x06
    1686:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1688:	1d 82       	std	Y+5, r1	; 0x05
    168a:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    168c:	1b 86       	std	Y+11, r1	; 0x0b
    168e:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1690:	f8 01       	movw	r30, r16
    1692:	81 85       	ldd	r24, Z+9	; 0x09
    1694:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1696:	80 e8       	ldi	r24, 0x80	; 128
    1698:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    169a:	80 89       	ldd	r24, Z+16	; 0x10
    169c:	91 89       	ldd	r25, Z+17	; 0x11
    169e:	a2 89       	ldd	r26, Z+18	; 0x12
    16a0:	b3 89       	ldd	r27, Z+19	; 0x13
    16a2:	8c 87       	std	Y+12, r24	; 0x0c
    16a4:	9d 87       	std	Y+13, r25	; 0x0d
    16a6:	ae 87       	std	Y+14, r26	; 0x0e
    16a8:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    16aa:	84 85       	ldd	r24, Z+12	; 0x0c
    16ac:	95 85       	ldd	r25, Z+13	; 0x0d
    16ae:	a6 85       	ldd	r26, Z+14	; 0x0e
    16b0:	b7 85       	ldd	r27, Z+15	; 0x0f
    16b2:	88 8b       	std	Y+16, r24	; 0x10
    16b4:	99 8b       	std	Y+17, r25	; 0x11
    16b6:	aa 8b       	std	Y+18, r26	; 0x12
    16b8:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    16ba:	ce 01       	movw	r24, r28
    16bc:	64 e1       	ldi	r22, 0x14	; 20
    16be:	70 e0       	ldi	r23, 0x00	; 0
    16c0:	0e 94 51 03 	call	0x6a2	; 0x6a2 <Ethernet_Checksum16>
    16c4:	9b 87       	std	Y+11, r25	; 0x0b
    16c6:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    16c8:	97 01       	movw	r18, r14
    16ca:	02 c0       	rjmp	.+4      	; 0x16d0 <IP_ProcessIPPacket+0x108>
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
    16cc:	20 e0       	ldi	r18, 0x00	; 0
    16ce:	30 e0       	ldi	r19, 0x00	; 0
		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
}
    16d0:	c9 01       	movw	r24, r18
    16d2:	df 91       	pop	r29
    16d4:	cf 91       	pop	r28
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	ef 90       	pop	r14
    16de:	df 90       	pop	r13
    16e0:	bf 90       	pop	r11
    16e2:	af 90       	pop	r10
    16e4:	08 95       	ret

000016e6 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    16e6:	db 01       	movw	r26, r22
    16e8:	0d 90       	ld	r0, X+
    16ea:	00 20       	and	r0, r0
    16ec:	e9 f7       	brne	.-6      	; 0x16e8 <IsHTTPCommand+0x2>
    16ee:	ad 01       	movw	r20, r26
    16f0:	41 50       	subi	r20, 0x01	; 1
    16f2:	50 40       	sbci	r21, 0x00	; 0
    16f4:	46 1b       	sub	r20, r22
    16f6:	57 0b       	sbc	r21, r23
    16f8:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <strncmp>
    16fc:	9c 01       	movw	r18, r24
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	21 15       	cp	r18, r1
    1702:	31 05       	cpc	r19, r1
    1704:	09 f0       	breq	.+2      	; 0x1708 <IsHTTPCommand+0x22>
    1706:	80 e0       	ldi	r24, 0x00	; 0
}
    1708:	08 95       	ret

0000170a <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    170a:	8f 92       	push	r8
    170c:	9f 92       	push	r9
    170e:	af 92       	push	r10
    1710:	bf 92       	push	r11
    1712:	cf 92       	push	r12
    1714:	df 92       	push	r13
    1716:	ef 92       	push	r14
    1718:	ff 92       	push	r15
    171a:	0f 93       	push	r16
    171c:	1f 93       	push	r17
    171e:	df 93       	push	r29
    1720:	cf 93       	push	r28
    1722:	00 d0       	rcall	.+0      	; 0x1724 <Webserver_ApplicationCallback+0x1a>
    1724:	cd b7       	in	r28, 0x3d	; 61
    1726:	de b7       	in	r29, 0x3e	; 62
    1728:	5c 01       	movw	r10, r24
    172a:	8b 01       	movw	r16, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    172c:	42 e0       	ldi	r20, 0x02	; 2
    172e:	84 2e       	mov	r8, r20
    1730:	91 2c       	mov	r9, r1
    1732:	86 0e       	add	r8, r22
    1734:	97 1e       	adc	r9, r23
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1736:	33 e0       	ldi	r19, 0x03	; 3
    1738:	e3 2e       	mov	r14, r19
    173a:	32 e0       	ldi	r19, 0x02	; 2
    173c:	f3 2e       	mov	r15, r19
    173e:	e6 0e       	add	r14, r22
    1740:	f7 1e       	adc	r15, r23
    1742:	d7 01       	movw	r26, r14
    1744:	8c 91       	ld	r24, X
    1746:	88 23       	and	r24, r24
    1748:	09 f4       	brne	.+2      	; 0x174c <Webserver_ApplicationCallback+0x42>
    174a:	67 c0       	rjmp	.+206    	; 0x181a <Webserver_ApplicationCallback+0x110>
    174c:	22 e0       	ldi	r18, 0x02	; 2
    174e:	c2 2e       	mov	r12, r18
    1750:	d2 2e       	mov	r13, r18
    1752:	c6 0e       	add	r12, r22
    1754:	d7 1e       	adc	r13, r23
    1756:	f6 01       	movw	r30, r12
    1758:	80 81       	ld	r24, Z
    175a:	88 23       	and	r24, r24
    175c:	09 f0       	breq	.+2      	; 0x1760 <Webserver_ApplicationCallback+0x56>
    175e:	a6 c0       	rjmp	.+332    	; 0x18ac <Webserver_ApplicationCallback+0x1a2>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1760:	c4 01       	movw	r24, r8
    1762:	64 ed       	ldi	r22, 0xD4	; 212
    1764:	71 e0       	ldi	r23, 0x01	; 1
    1766:	bf df       	rcall	.-130    	; 0x16e6 <IsHTTPCommand>
    1768:	88 23       	and	r24, r24
    176a:	09 f1       	breq	.+66     	; 0x17ae <Webserver_ApplicationCallback+0xa4>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    176c:	c4 01       	movw	r24, r8
    176e:	68 ed       	ldi	r22, 0xD8	; 216
    1770:	71 e0       	ldi	r23, 0x01	; 1
    1772:	b9 df       	rcall	.-142    	; 0x16e6 <IsHTTPCommand>
    1774:	88 23       	and	r24, r24
    1776:	59 f1       	breq	.+86     	; 0x17ce <Webserver_ApplicationCallback+0xc4>
			{
				PageBlock = 0;
    1778:	10 92 b6 0d 	sts	0x0DB6, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    177c:	c4 01       	movw	r24, r8
    177e:	60 e3       	ldi	r22, 0x30	; 48
    1780:	71 e0       	ldi	r23, 0x01	; 1
    1782:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	d6 01       	movw	r26, r12
    178a:	8c 93       	st	X, r24
    178c:	f4 01       	movw	r30, r8
    178e:	01 90       	ld	r0, Z+
    1790:	00 20       	and	r0, r0
    1792:	e9 f7       	brne	.-6      	; 0x178e <Webserver_ApplicationCallback+0x84>
    1794:	31 97       	sbiw	r30, 0x01	; 1
    1796:	e8 19       	sub	r30, r8
    1798:	f9 09       	sbc	r31, r9
    179a:	d8 01       	movw	r26, r16
    179c:	11 96       	adiw	r26, 0x01	; 1
    179e:	fc 93       	st	X, r31
    17a0:	ee 93       	st	-X, r30
    17a2:	f7 01       	movw	r30, r14
    17a4:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    17a6:	f8 01       	movw	r30, r16
    17a8:	ec 5f       	subi	r30, 0xFC	; 252
    17aa:	fd 4f       	sbci	r31, 0xFD	; 253
    17ac:	7e c0       	rjmp	.+252    	; 0x18aa <Webserver_ApplicationCallback+0x1a0>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    17ae:	c4 01       	movw	r24, r8
    17b0:	6f ed       	ldi	r22, 0xDF	; 223
    17b2:	71 e0       	ldi	r23, 0x01	; 1
    17b4:	98 df       	rcall	.-208    	; 0x16e6 <IsHTTPCommand>
    17b6:	88 23       	and	r24, r24
    17b8:	f1 f0       	breq	.+60     	; 0x17f6 <Webserver_ApplicationCallback+0xec>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    17ba:	c4 01       	movw	r24, r8
    17bc:	64 ee       	ldi	r22, 0xE4	; 228
    17be:	71 e0       	ldi	r23, 0x01	; 1
    17c0:	92 df       	rcall	.-220    	; 0x16e6 <IsHTTPCommand>
    17c2:	88 23       	and	r24, r24
    17c4:	21 f0       	breq	.+8      	; 0x17ce <Webserver_ApplicationCallback+0xc4>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    17c6:	c4 01       	movw	r24, r8
    17c8:	60 e3       	ldi	r22, 0x30	; 48
    17ca:	71 e0       	ldi	r23, 0x01	; 1
    17cc:	03 c0       	rjmp	.+6      	; 0x17d4 <Webserver_ApplicationCallback+0xca>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    17ce:	c4 01       	movw	r24, r8
    17d0:	64 e8       	ldi	r22, 0x84	; 132
    17d2:	71 e0       	ldi	r23, 0x01	; 1
    17d4:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	d6 01       	movw	r26, r12
    17dc:	8c 93       	st	X, r24
    17de:	f4 01       	movw	r30, r8
    17e0:	01 90       	ld	r0, Z+
    17e2:	00 20       	and	r0, r0
    17e4:	e9 f7       	brne	.-6      	; 0x17e0 <Webserver_ApplicationCallback+0xd6>
    17e6:	31 97       	sbiw	r30, 0x01	; 1
    17e8:	e8 19       	sub	r30, r8
    17ea:	f9 09       	sbc	r31, r9
    17ec:	d8 01       	movw	r26, r16
    17ee:	11 96       	adiw	r26, 0x01	; 1
    17f0:	fc 93       	st	X, r31
    17f2:	ee 93       	st	-X, r30
    17f4:	09 c0       	rjmp	.+18     	; 0x1808 <Webserver_ApplicationCallback+0xfe>
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    17f6:	c4 01       	movw	r24, r8
    17f8:	6c ee       	ldi	r22, 0xEC	; 236
    17fa:	71 e0       	ldi	r23, 0x01	; 1
    17fc:	74 df       	rcall	.-280    	; 0x16e6 <IsHTTPCommand>
    17fe:	88 23       	and	r24, r24
    1800:	31 f0       	breq	.+12     	; 0x180e <Webserver_ApplicationCallback+0x104>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	d6 01       	movw	r26, r12
    1806:	8c 93       	st	X, r24
    1808:	f7 01       	movw	r30, r14
    180a:	80 83       	st	Z, r24
    180c:	4a c0       	rjmp	.+148    	; 0x18a2 <Webserver_ApplicationCallback+0x198>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    180e:	d7 01       	movw	r26, r14
    1810:	1c 92       	st	X, r1
    1812:	f8 01       	movw	r30, r16
    1814:	11 82       	std	Z+1, r1	; 0x01
    1816:	10 82       	st	Z, r1
    1818:	49 c0       	rjmp	.+146    	; 0x18ac <Webserver_ApplicationCallback+0x1a2>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    181a:	fb 01       	movw	r30, r22
    181c:	ec 5f       	subi	r30, 0xFC	; 252
    181e:	fd 4f       	sbci	r31, 0xFD	; 253
    1820:	80 81       	ld	r24, Z
    1822:	88 23       	and	r24, r24
    1824:	09 f4       	brne	.+2      	; 0x1828 <Webserver_ApplicationCallback+0x11e>
    1826:	42 c0       	rjmp	.+132    	; 0x18ac <Webserver_ApplicationCallback+0x1a2>
    1828:	fb 01       	movw	r30, r22
    182a:	ee 5f       	subi	r30, 0xFE	; 254
    182c:	fd 4f       	sbci	r31, 0xFD	; 253
    182e:	80 81       	ld	r24, Z
    1830:	88 23       	and	r24, r24
    1832:	e1 f1       	breq	.+120    	; 0x18ac <Webserver_ApplicationCallback+0x1a2>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1834:	60 91 b6 0d 	lds	r22, 0x0DB6
    1838:	70 e0       	ldi	r23, 0x00	; 0
    183a:	76 95       	lsr	r23
    183c:	76 2f       	mov	r23, r22
    183e:	66 27       	eor	r22, r22
    1840:	77 95       	ror	r23
    1842:	67 95       	ror	r22
    1844:	6a 53       	subi	r22, 0x3A	; 58
    1846:	7e 4f       	sbci	r23, 0xFE	; 254
    1848:	cb 01       	movw	r24, r22
    184a:	69 83       	std	Y+1, r22	; 0x01
    184c:	7a 83       	std	Y+2, r23	; 0x02
    184e:	0e 94 13 16 	call	0x2c26	; 0x2c26 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1852:	e8 2e       	mov	r14, r24
    1854:	f9 2e       	mov	r15, r25
    1856:	69 81       	ldd	r22, Y+1	; 0x01
    1858:	7a 81       	ldd	r23, Y+2	; 0x02
    185a:	f1 e8       	ldi	r31, 0x81	; 129
    185c:	ef 16       	cp	r14, r31
    185e:	f1 04       	cpc	r15, r1
    1860:	18 f0       	brcs	.+6      	; 0x1868 <Webserver_ApplicationCallback+0x15e>
    1862:	80 e8       	ldi	r24, 0x80	; 128
    1864:	e8 2e       	mov	r14, r24
    1866:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1868:	c4 01       	movw	r24, r8
    186a:	a7 01       	movw	r20, r14
    186c:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1870:	f8 01       	movw	r30, r16
    1872:	ee 5f       	subi	r30, 0xFE	; 254
    1874:	fd 4f       	sbci	r31, 0xFD	; 253
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	80 83       	st	Z, r24
    187a:	d8 01       	movw	r26, r16
    187c:	11 96       	adiw	r26, 0x01	; 1
    187e:	fc 92       	st	X, r15
    1880:	ee 92       	st	-X, r14
    1882:	f8 01       	movw	r30, r16
    1884:	ed 5f       	subi	r30, 0xFD	; 253
    1886:	fd 4f       	sbci	r31, 0xFD	; 253
    1888:	80 83       	st	Z, r24

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    188a:	80 91 b6 0d 	lds	r24, 0x0DB6
    188e:	98 2f       	mov	r25, r24
    1890:	9f 5f       	subi	r25, 0xFF	; 255
    1892:	90 93 b6 0d 	sts	0x0DB6, r25
    1896:	83 30       	cpi	r24, 0x03	; 3
    1898:	49 f4       	brne	.+18     	; 0x18ac <Webserver_ApplicationCallback+0x1a2>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    189a:	f8 01       	movw	r30, r16
    189c:	ec 5f       	subi	r30, 0xFC	; 252
    189e:	fd 4f       	sbci	r31, 0xFD	; 253
    18a0:	10 82       	st	Z, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    18a2:	f5 01       	movw	r30, r10
    18a4:	eb 5e       	subi	r30, 0xEB	; 235
    18a6:	fd 4f       	sbci	r31, 0xFD	; 253
    18a8:	87 e0       	ldi	r24, 0x07	; 7
    18aa:	80 83       	st	Z, r24
		}
	}
}
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	cf 91       	pop	r28
    18b2:	df 91       	pop	r29
    18b4:	1f 91       	pop	r17
    18b6:	0f 91       	pop	r16
    18b8:	ff 90       	pop	r15
    18ba:	ef 90       	pop	r14
    18bc:	df 90       	pop	r13
    18be:	cf 90       	pop	r12
    18c0:	bf 90       	pop	r11
    18c2:	af 90       	pop	r10
    18c4:	9f 90       	pop	r9
    18c6:	8f 90       	pop	r8
    18c8:	08 95       	ret

000018ca <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    18ca:	80 e0       	ldi	r24, 0x00	; 0
    18cc:	90 e5       	ldi	r25, 0x50	; 80
    18ce:	61 e0       	ldi	r22, 0x01	; 1
    18d0:	45 e8       	ldi	r20, 0x85	; 133
    18d2:	5b e0       	ldi	r21, 0x0B	; 11
}
    18d4:	47 c9       	rjmp	.-3442   	; 0xb64 <TCP_SetPortState>

000018d6 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    18d6:	8f 92       	push	r8
    18d8:	9f 92       	push	r9
    18da:	bf 92       	push	r11
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	0f 92       	push	r0
    18ee:	cd b7       	in	r28, 0x3d	; 61
    18f0:	de b7       	in	r29, 0x3e	; 62
    18f2:	e8 2e       	mov	r14, r24
    18f4:	4b 01       	movw	r8, r22
    18f6:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    18f8:	99 83       	std	Y+1, r25	; 0x01
    18fa:	42 d2       	rcall	.+1156   	; 0x1d80 <Endpoint_WaitUntilReady>
    18fc:	b8 2e       	mov	r11, r24
    18fe:	99 81       	ldd	r25, Y+1	; 0x01
    1900:	88 23       	and	r24, r24
    1902:	c9 f5       	brne	.+114    	; 0x1976 <Endpoint_Write_Stream_LE+0xa0>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1904:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    1906:	01 15       	cp	r16, r1
    1908:	11 05       	cpc	r17, r1
    190a:	39 f0       	breq	.+14     	; 0x191a <Endpoint_Write_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
    190c:	f8 01       	movw	r30, r16
    190e:	20 81       	ld	r18, Z
    1910:	31 81       	ldd	r19, Z+1	; 0x01
    1912:	82 1a       	sub	r8, r18
    1914:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    1916:	e2 0e       	add	r14, r18
    1918:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    191a:	cc 24       	eor	r12, r12
    191c:	dd 24       	eor	r13, r13
    191e:	26 c0       	rjmp	.+76     	; 0x196c <Endpoint_Write_Stream_LE+0x96>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1920:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1924:	85 fd       	sbrc	r24, 5
    1926:	17 c0       	rjmp	.+46     	; 0x1956 <Endpoint_Write_Stream_LE+0x80>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1928:	80 91 e8 00 	lds	r24, 0x00E8
    192c:	8e 77       	andi	r24, 0x7E	; 126
    192e:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1932:	eb d4       	rcall	.+2518   	; 0x230a <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    1934:	01 15       	cp	r16, r1
    1936:	11 05       	cpc	r17, r1
    1938:	51 f0       	breq	.+20     	; 0x194e <Endpoint_Write_Stream_LE+0x78>
			{
				*BytesProcessed += BytesInTransfer;
    193a:	f8 01       	movw	r30, r16
    193c:	80 81       	ld	r24, Z
    193e:	91 81       	ldd	r25, Z+1	; 0x01
    1940:	8c 0d       	add	r24, r12
    1942:	9d 1d       	adc	r25, r13
    1944:	91 83       	std	Z+1, r25	; 0x01
    1946:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1948:	25 e0       	ldi	r18, 0x05	; 5
    194a:	b2 2e       	mov	r11, r18
    194c:	14 c0       	rjmp	.+40     	; 0x1976 <Endpoint_Write_Stream_LE+0xa0>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    194e:	18 d2       	rcall	.+1072   	; 0x1d80 <Endpoint_WaitUntilReady>
    1950:	88 23       	and	r24, r24
    1952:	61 f0       	breq	.+24     	; 0x196c <Endpoint_Write_Stream_LE+0x96>
    1954:	0f c0       	rjmp	.+30     	; 0x1974 <Endpoint_Write_Stream_LE+0x9e>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1956:	f7 01       	movw	r30, r14
    1958:	81 91       	ld	r24, Z+
    195a:	7f 01       	movw	r14, r30
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    195c:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1960:	08 94       	sec
    1962:	81 08       	sbc	r8, r1
    1964:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    1966:	08 94       	sec
    1968:	c1 1c       	adc	r12, r1
    196a:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    196c:	81 14       	cp	r8, r1
    196e:	91 04       	cpc	r9, r1
    1970:	b9 f6       	brne	.-82     	; 0x1920 <Endpoint_Write_Stream_LE+0x4a>
    1972:	01 c0       	rjmp	.+2      	; 0x1976 <Endpoint_Write_Stream_LE+0xa0>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1974:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    1976:	8b 2d       	mov	r24, r11
    1978:	0f 90       	pop	r0
    197a:	cf 91       	pop	r28
    197c:	df 91       	pop	r29
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	ff 90       	pop	r15
    1984:	ef 90       	pop	r14
    1986:	df 90       	pop	r13
    1988:	cf 90       	pop	r12
    198a:	bf 90       	pop	r11
    198c:	9f 90       	pop	r9
    198e:	8f 90       	pop	r8
    1990:	08 95       	ret

00001992 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    1992:	8f 92       	push	r8
    1994:	9f 92       	push	r9
    1996:	bf 92       	push	r11
    1998:	cf 92       	push	r12
    199a:	df 92       	push	r13
    199c:	ef 92       	push	r14
    199e:	ff 92       	push	r15
    19a0:	0f 93       	push	r16
    19a2:	1f 93       	push	r17
    19a4:	df 93       	push	r29
    19a6:	cf 93       	push	r28
    19a8:	0f 92       	push	r0
    19aa:	cd b7       	in	r28, 0x3d	; 61
    19ac:	de b7       	in	r29, 0x3e	; 62
    19ae:	e8 2e       	mov	r14, r24
    19b0:	4b 01       	movw	r8, r22
    19b2:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    19b4:	99 83       	std	Y+1, r25	; 0x01
    19b6:	e4 d1       	rcall	.+968    	; 0x1d80 <Endpoint_WaitUntilReady>
    19b8:	b8 2e       	mov	r11, r24
    19ba:	99 81       	ldd	r25, Y+1	; 0x01
    19bc:	88 23       	and	r24, r24
    19be:	c9 f5       	brne	.+114    	; 0x1a32 <Endpoint_Read_Stream_LE+0xa0>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    19c0:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    19c2:	01 15       	cp	r16, r1
    19c4:	11 05       	cpc	r17, r1
    19c6:	39 f0       	breq	.+14     	; 0x19d6 <Endpoint_Read_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
    19c8:	f8 01       	movw	r30, r16
    19ca:	20 81       	ld	r18, Z
    19cc:	31 81       	ldd	r19, Z+1	; 0x01
    19ce:	82 1a       	sub	r8, r18
    19d0:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    19d2:	e2 0e       	add	r14, r18
    19d4:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    19d6:	cc 24       	eor	r12, r12
    19d8:	dd 24       	eor	r13, r13
    19da:	26 c0       	rjmp	.+76     	; 0x1a28 <Endpoint_Read_Stream_LE+0x96>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    19dc:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    19e0:	85 fd       	sbrc	r24, 5
    19e2:	17 c0       	rjmp	.+46     	; 0x1a12 <Endpoint_Read_Stream_LE+0x80>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    19e4:	80 91 e8 00 	lds	r24, 0x00E8
    19e8:	8b 77       	andi	r24, 0x7B	; 123
    19ea:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    19ee:	8d d4       	rcall	.+2330   	; 0x230a <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    19f0:	01 15       	cp	r16, r1
    19f2:	11 05       	cpc	r17, r1
    19f4:	51 f0       	breq	.+20     	; 0x1a0a <Endpoint_Read_Stream_LE+0x78>
			{
				*BytesProcessed += BytesInTransfer;
    19f6:	f8 01       	movw	r30, r16
    19f8:	80 81       	ld	r24, Z
    19fa:	91 81       	ldd	r25, Z+1	; 0x01
    19fc:	8c 0d       	add	r24, r12
    19fe:	9d 1d       	adc	r25, r13
    1a00:	91 83       	std	Z+1, r25	; 0x01
    1a02:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    1a04:	45 e0       	ldi	r20, 0x05	; 5
    1a06:	b4 2e       	mov	r11, r20
    1a08:	14 c0       	rjmp	.+40     	; 0x1a32 <Endpoint_Read_Stream_LE+0xa0>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1a0a:	ba d1       	rcall	.+884    	; 0x1d80 <Endpoint_WaitUntilReady>
    1a0c:	88 23       	and	r24, r24
    1a0e:	61 f0       	breq	.+24     	; 0x1a28 <Endpoint_Read_Stream_LE+0x96>
    1a10:	0f c0       	rjmp	.+30     	; 0x1a30 <Endpoint_Read_Stream_LE+0x9e>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1a12:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    1a16:	f7 01       	movw	r30, r14
    1a18:	81 93       	st	Z+, r24
    1a1a:	7f 01       	movw	r14, r30
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1a1c:	08 94       	sec
    1a1e:	81 08       	sbc	r8, r1
    1a20:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    1a22:	08 94       	sec
    1a24:	c1 1c       	adc	r12, r1
    1a26:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    1a28:	81 14       	cp	r8, r1
    1a2a:	91 04       	cpc	r9, r1
    1a2c:	b9 f6       	brne	.-82     	; 0x19dc <Endpoint_Read_Stream_LE+0x4a>
    1a2e:	01 c0       	rjmp	.+2      	; 0x1a32 <Endpoint_Read_Stream_LE+0xa0>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1a30:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    1a32:	8b 2d       	mov	r24, r11
    1a34:	0f 90       	pop	r0
    1a36:	cf 91       	pop	r28
    1a38:	df 91       	pop	r29
    1a3a:	1f 91       	pop	r17
    1a3c:	0f 91       	pop	r16
    1a3e:	ff 90       	pop	r15
    1a40:	ef 90       	pop	r14
    1a42:	df 90       	pop	r13
    1a44:	cf 90       	pop	r12
    1a46:	bf 90       	pop	r11
    1a48:	9f 90       	pop	r9
    1a4a:	8f 90       	pop	r8
    1a4c:	08 95       	ret

00001a4e <Endpoint_Write_Control_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1a4e:	28 2f       	mov	r18, r24
    1a50:	39 2f       	mov	r19, r25
    1a52:	f9 01       	movw	r30, r18
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1a54:	80 91 09 14 	lds	r24, 0x1409
    1a58:	90 91 0a 14 	lds	r25, 0x140A
    1a5c:	86 17       	cp	r24, r22
    1a5e:	97 07       	cpc	r25, r23
    1a60:	18 f4       	brcc	.+6      	; 0x1a68 <Endpoint_Write_Control_Stream_LE+0x1a>
    1a62:	bc 01       	movw	r22, r24
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	37 c0       	rjmp	.+110    	; 0x1ad6 <Endpoint_Write_Control_Stream_LE+0x88>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1a68:	61 15       	cp	r22, r1
    1a6a:	71 05       	cpc	r23, r1
    1a6c:	d9 f7       	brne	.-10     	; 0x1a64 <Endpoint_Write_Control_Stream_LE+0x16>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1a6e:	80 91 e8 00 	lds	r24, 0x00E8
    1a72:	8e 77       	andi	r24, 0x7E	; 126
    1a74:	80 93 e8 00 	sts	0x00E8, r24
    1a78:	f5 cf       	rjmp	.-22     	; 0x1a64 <Endpoint_Write_Control_Stream_LE+0x16>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a7a:	80 91 02 14 	lds	r24, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1a7e:	88 23       	and	r24, r24
    1a80:	09 f4       	brne	.+2      	; 0x1a84 <Endpoint_Write_Control_Stream_LE+0x36>
    1a82:	3f c0       	rjmp	.+126    	; 0x1b02 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1a84:	85 30       	cpi	r24, 0x05	; 5
    1a86:	c9 f1       	breq	.+114    	; 0x1afa <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1a88:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1a8c:	83 fd       	sbrc	r24, 3
    1a8e:	37 c0       	rjmp	.+110    	; 0x1afe <Endpoint_Write_Control_Stream_LE+0xb0>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1a90:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1a94:	82 fd       	sbrc	r24, 2
    1a96:	2b c0       	rjmp	.+86     	; 0x1aee <Endpoint_Write_Control_Stream_LE+0xa0>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1a98:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1a9c:	80 ff       	sbrs	r24, 0
    1a9e:	1b c0       	rjmp	.+54     	; 0x1ad6 <Endpoint_Write_Control_Stream_LE+0x88>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1aa0:	80 91 f2 00 	lds	r24, 0x00F2
    1aa4:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1aa8:	06 c0       	rjmp	.+12     	; 0x1ab6 <Endpoint_Write_Control_Stream_LE+0x68>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1aaa:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1aac:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1ab0:	61 50       	subi	r22, 0x01	; 1
    1ab2:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    1ab4:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1ab6:	61 15       	cp	r22, r1
    1ab8:	71 05       	cpc	r23, r1
    1aba:	19 f0       	breq	.+6      	; 0x1ac2 <Endpoint_Write_Control_Stream_LE+0x74>
    1abc:	88 30       	cpi	r24, 0x08	; 8
    1abe:	91 05       	cpc	r25, r1
    1ac0:	a0 f3       	brcs	.-24     	; 0x1aaa <Endpoint_Write_Control_Stream_LE+0x5c>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1ac2:	21 e0       	ldi	r18, 0x01	; 1
    1ac4:	88 30       	cpi	r24, 0x08	; 8
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	09 f0       	breq	.+2      	; 0x1acc <Endpoint_Write_Control_Stream_LE+0x7e>
    1aca:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1acc:	80 91 e8 00 	lds	r24, 0x00E8
    1ad0:	8e 77       	andi	r24, 0x7E	; 126
    1ad2:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1ad6:	61 15       	cp	r22, r1
    1ad8:	71 05       	cpc	r23, r1
    1ada:	79 f6       	brne	.-98     	; 0x1a7a <Endpoint_Write_Control_Stream_LE+0x2c>
    1adc:	22 23       	and	r18, r18
    1ade:	69 f6       	brne	.-102    	; 0x1a7a <Endpoint_Write_Control_Stream_LE+0x2c>
    1ae0:	06 c0       	rjmp	.+12     	; 0x1aee <Endpoint_Write_Control_Stream_LE+0xa0>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1ae2:	80 91 02 14 	lds	r24, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1ae6:	88 23       	and	r24, r24
    1ae8:	61 f0       	breq	.+24     	; 0x1b02 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1aea:	85 30       	cpi	r24, 0x05	; 5
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1aee:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1af2:	82 ff       	sbrs	r24, 2
    1af4:	f6 cf       	rjmp	.-20     	; 0x1ae2 <Endpoint_Write_Control_Stream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1af6:	80 e0       	ldi	r24, 0x00	; 0
    1af8:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1afa:	83 e0       	ldi	r24, 0x03	; 3
    1afc:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1b02:	82 e0       	ldi	r24, 0x02	; 2
    1b04:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b06:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1b08:	08 95       	ret

00001b0a <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    1b0a:	61 15       	cp	r22, r1
    1b0c:	71 05       	cpc	r23, r1
    1b0e:	31 f5       	brne	.+76     	; 0x1b5c <Endpoint_Read_Control_Stream_LE+0x52>
    1b10:	20 c0       	rjmp	.+64     	; 0x1b52 <Endpoint_Read_Control_Stream_LE+0x48>
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1b12:	20 91 02 14 	lds	r18, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1b16:	22 23       	and	r18, r18
    1b18:	a9 f1       	breq	.+106    	; 0x1b84 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1b1a:	25 30       	cpi	r18, 0x05	; 5
    1b1c:	79 f1       	breq	.+94     	; 0x1b7c <Endpoint_Read_Control_Stream_LE+0x72>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1b1e:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1b22:	23 fd       	sbrc	r18, 3
    1b24:	2d c0       	rjmp	.+90     	; 0x1b80 <Endpoint_Read_Control_Stream_LE+0x76>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b26:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1b2a:	22 ff       	sbrs	r18, 2
    1b2c:	f2 cf       	rjmp	.-28     	; 0x1b12 <Endpoint_Read_Control_Stream_LE+0x8>
    1b2e:	e8 2f       	mov	r30, r24
    1b30:	f9 2f       	mov	r31, r25
    1b32:	07 c0       	rjmp	.+14     	; 0x1b42 <Endpoint_Read_Control_Stream_LE+0x38>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1b34:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1b38:	81 93       	st	Z+, r24
    1b3a:	cf 01       	movw	r24, r30
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1b3c:	61 50       	subi	r22, 0x01	; 1
    1b3e:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1b40:	41 f0       	breq	.+16     	; 0x1b52 <Endpoint_Read_Control_Stream_LE+0x48>
    1b42:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1b44:	20 91 f2 00 	lds	r18, 0x00F2
    1b48:	30 91 f3 00 	lds	r19, 0x00F3
    1b4c:	21 15       	cp	r18, r1
    1b4e:	31 05       	cpc	r19, r1
    1b50:	89 f7       	brne	.-30     	; 0x1b34 <Endpoint_Read_Control_Stream_LE+0x2a>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1b52:	20 91 e8 00 	lds	r18, 0x00E8
    1b56:	2b 77       	andi	r18, 0x7B	; 123
    1b58:	20 93 e8 00 	sts	0x00E8, r18
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    1b5c:	61 15       	cp	r22, r1
    1b5e:	71 05       	cpc	r23, r1
    1b60:	c1 f6       	brne	.-80     	; 0x1b12 <Endpoint_Read_Control_Stream_LE+0x8>
    1b62:	06 c0       	rjmp	.+12     	; 0x1b70 <Endpoint_Read_Control_Stream_LE+0x66>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1b64:	80 91 02 14 	lds	r24, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1b68:	88 23       	and	r24, r24
    1b6a:	61 f0       	breq	.+24     	; 0x1b84 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1b6c:	85 30       	cpi	r24, 0x05	; 5
    1b6e:	61 f0       	breq	.+24     	; 0x1b88 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b70:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1b74:	80 ff       	sbrs	r24, 0
    1b76:	f6 cf       	rjmp	.-20     	; 0x1b64 <Endpoint_Read_Control_Stream_LE+0x5a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1b78:	80 e0       	ldi	r24, 0x00	; 0
    1b7a:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b7c:	83 e0       	ldi	r24, 0x03	; 3
    1b7e:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1b84:	82 e0       	ldi	r24, 0x02	; 2
    1b86:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b88:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1b8a:	08 95       	ret

00001b8c <Endpoint_Write_Control_PStream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1b8c:	e8 2f       	mov	r30, r24
    1b8e:	f9 2f       	mov	r31, r25
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1b90:	80 91 09 14 	lds	r24, 0x1409
    1b94:	90 91 0a 14 	lds	r25, 0x140A
    1b98:	86 17       	cp	r24, r22
    1b9a:	97 07       	cpc	r25, r23
    1b9c:	18 f4       	brcc	.+6      	; 0x1ba4 <Endpoint_Write_Control_PStream_LE+0x18>
    1b9e:	bc 01       	movw	r22, r24
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	38 c0       	rjmp	.+112    	; 0x1c14 <Endpoint_Write_Control_PStream_LE+0x88>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1ba4:	61 15       	cp	r22, r1
    1ba6:	71 05       	cpc	r23, r1
    1ba8:	d9 f7       	brne	.-10     	; 0x1ba0 <Endpoint_Write_Control_PStream_LE+0x14>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1baa:	80 91 e8 00 	lds	r24, 0x00E8
    1bae:	8e 77       	andi	r24, 0x7E	; 126
    1bb0:	80 93 e8 00 	sts	0x00E8, r24
    1bb4:	f5 cf       	rjmp	.-22     	; 0x1ba0 <Endpoint_Write_Control_PStream_LE+0x14>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1bb6:	80 91 02 14 	lds	r24, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1bba:	88 23       	and	r24, r24
    1bbc:	09 f4       	brne	.+2      	; 0x1bc0 <Endpoint_Write_Control_PStream_LE+0x34>
    1bbe:	40 c0       	rjmp	.+128    	; 0x1c40 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1bc0:	85 30       	cpi	r24, 0x05	; 5
    1bc2:	d1 f1       	breq	.+116    	; 0x1c38 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1bc4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1bc8:	83 fd       	sbrc	r24, 3
    1bca:	38 c0       	rjmp	.+112    	; 0x1c3c <Endpoint_Write_Control_PStream_LE+0xb0>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1bcc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1bd0:	82 fd       	sbrc	r24, 2
    1bd2:	2c c0       	rjmp	.+88     	; 0x1c2c <Endpoint_Write_Control_PStream_LE+0xa0>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1bd4:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1bd8:	80 ff       	sbrs	r24, 0
    1bda:	1c c0       	rjmp	.+56     	; 0x1c14 <Endpoint_Write_Control_PStream_LE+0x88>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    1bdc:	80 91 f2 00 	lds	r24, 0x00F2
    1be0:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1be4:	07 c0       	rjmp	.+14     	; 0x1bf4 <Endpoint_Write_Control_PStream_LE+0x68>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1be6:	24 91       	lpm	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1be8:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1bec:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1bee:	61 50       	subi	r22, 0x01	; 1
    1bf0:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    1bf2:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1bf4:	61 15       	cp	r22, r1
    1bf6:	71 05       	cpc	r23, r1
    1bf8:	19 f0       	breq	.+6      	; 0x1c00 <Endpoint_Write_Control_PStream_LE+0x74>
    1bfa:	88 30       	cpi	r24, 0x08	; 8
    1bfc:	91 05       	cpc	r25, r1
    1bfe:	98 f3       	brcs	.-26     	; 0x1be6 <Endpoint_Write_Control_PStream_LE+0x5a>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1c00:	21 e0       	ldi	r18, 0x01	; 1
    1c02:	88 30       	cpi	r24, 0x08	; 8
    1c04:	91 05       	cpc	r25, r1
    1c06:	09 f0       	breq	.+2      	; 0x1c0a <Endpoint_Write_Control_PStream_LE+0x7e>
    1c08:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1c0a:	80 91 e8 00 	lds	r24, 0x00E8
    1c0e:	8e 77       	andi	r24, 0x7E	; 126
    1c10:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1c14:	61 15       	cp	r22, r1
    1c16:	71 05       	cpc	r23, r1
    1c18:	71 f6       	brne	.-100    	; 0x1bb6 <Endpoint_Write_Control_PStream_LE+0x2a>
    1c1a:	22 23       	and	r18, r18
    1c1c:	61 f6       	brne	.-104    	; 0x1bb6 <Endpoint_Write_Control_PStream_LE+0x2a>
    1c1e:	06 c0       	rjmp	.+12     	; 0x1c2c <Endpoint_Write_Control_PStream_LE+0xa0>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1c20:	80 91 02 14 	lds	r24, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1c24:	88 23       	and	r24, r24
    1c26:	61 f0       	breq	.+24     	; 0x1c40 <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1c28:	85 30       	cpi	r24, 0x05	; 5
    1c2a:	61 f0       	breq	.+24     	; 0x1c44 <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c2c:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1c30:	82 ff       	sbrs	r24, 2
    1c32:	f6 cf       	rjmp	.-20     	; 0x1c20 <Endpoint_Write_Control_PStream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1c38:	83 e0       	ldi	r24, 0x03	; 3
    1c3a:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1c40:	82 e0       	ldi	r24, 0x02	; 2
    1c42:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1c44:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1c46:	08 95       	ret

00001c48 <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c48:	98 2f       	mov	r25, r24
    1c4a:	2c c0       	rjmp	.+88     	; 0x1ca4 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1c4c:	29 2f       	mov	r18, r25
    1c4e:	2f 70       	andi	r18, 0x0F	; 15
    1c50:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    1c54:	98 17       	cp	r25, r24
    1c56:	39 f0       	breq	.+14     	; 0x1c66 <Endpoint_ConfigureEndpoint_Prv+0x1e>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1c58:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1c5c:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    1c60:	50 91 f0 00 	lds	r21, 0x00F0
    1c64:	03 c0       	rjmp	.+6      	; 0x1c6c <Endpoint_ConfigureEndpoint_Prv+0x24>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    1c66:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    1c68:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    1c6a:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1c6c:	21 ff       	sbrs	r18, 1
    1c6e:	19 c0       	rjmp	.+50     	; 0x1ca2 <Endpoint_ConfigureEndpoint_Prv+0x5a>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1c70:	30 91 eb 00 	lds	r19, 0x00EB
    1c74:	3e 7f       	andi	r19, 0xFE	; 254
    1c76:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1c7a:	30 91 ed 00 	lds	r19, 0x00ED
    1c7e:	3d 7f       	andi	r19, 0xFD	; 253
    1c80:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1c84:	30 91 eb 00 	lds	r19, 0x00EB
    1c88:	31 60       	ori	r19, 0x01	; 1
    1c8a:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1c8e:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1c92:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    1c96:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1c9a:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    1c9e:	27 ff       	sbrs	r18, 7
    1ca0:	08 c0       	rjmp	.+16     	; 0x1cb2 <Endpoint_ConfigureEndpoint_Prv+0x6a>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1ca2:	9f 5f       	subi	r25, 0xFF	; 255
    1ca4:	97 30       	cpi	r25, 0x07	; 7
    1ca6:	90 f2       	brcs	.-92     	; 0x1c4c <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1ca8:	8f 70       	andi	r24, 0x0F	; 15
    1caa:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    1cb2:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1cb4:	08 95       	ret

00001cb6 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1cb6:	ef 92       	push	r14
    1cb8:	ff 92       	push	r15
    1cba:	0f 93       	push	r16
    1cbc:	1f 93       	push	r17
    1cbe:	cf 93       	push	r28
    1cc0:	df 93       	push	r29
    1cc2:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1cc4:	e8 2e       	mov	r14, r24
    1cc6:	e7 01       	movw	r28, r14
    1cc8:	7e 01       	movw	r14, r28
    1cca:	f9 2e       	mov	r15, r25
    1ccc:	e7 01       	movw	r28, r14
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1cce:	00 e0       	ldi	r16, 0x00	; 0
    1cd0:	2a c0       	rjmp	.+84     	; 0x1d26 <Endpoint_ConfigureEndpointTable+0x70>
	{
		if (!(Table[i].Address))
    1cd2:	98 81       	ld	r25, Y
    1cd4:	99 23       	and	r25, r25
    1cd6:	29 f1       	breq	.+74     	; 0x1d22 <Endpoint_ConfigureEndpointTable+0x6c>
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1cd8:	6b 81       	ldd	r22, Y+3	; 0x03
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    1ce0:	89 2f       	mov	r24, r25
    1ce2:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    1ce4:	87 30       	cpi	r24, 0x07	; 7
    1ce6:	18 f5       	brcc	.+70     	; 0x1d2e <Endpoint_ConfigureEndpointTable+0x78>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    1ce8:	62 95       	swap	r22
    1cea:	66 0f       	add	r22, r22
    1cec:	66 0f       	add	r22, r22
    1cee:	60 7c       	andi	r22, 0xC0	; 192
    1cf0:	99 1f       	adc	r25, r25
    1cf2:	99 27       	eor	r25, r25
    1cf4:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1cf6:	69 2b       	or	r22, r25
    1cf8:	22 30       	cpi	r18, 0x02	; 2
    1cfa:	10 f0       	brcs	.+4      	; 0x1d00 <Endpoint_ConfigureEndpointTable+0x4a>
    1cfc:	96 e0       	ldi	r25, 0x06	; 6
    1cfe:	01 c0       	rjmp	.+2      	; 0x1d02 <Endpoint_ConfigureEndpointTable+0x4c>
    1d00:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    1d02:	28 e0       	ldi	r18, 0x08	; 8
    1d04:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1d06:	40 e0       	ldi	r20, 0x00	; 0
    1d08:	03 c0       	rjmp	.+6      	; 0x1d10 <Endpoint_ConfigureEndpointTable+0x5a>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    1d0a:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    1d0c:	22 0f       	add	r18, r18
    1d0e:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1d10:	2e 17       	cp	r18, r30
    1d12:	3f 07       	cpc	r19, r31
    1d14:	d0 f3       	brcs	.-12     	; 0x1d0a <Endpoint_ConfigureEndpointTable+0x54>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    1d16:	42 95       	swap	r20
    1d18:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1d1a:	49 2b       	or	r20, r25
    1d1c:	95 df       	rcall	.-214    	; 0x1c48 <Endpoint_ConfigureEndpoint_Prv>
    1d1e:	88 23       	and	r24, r24
    1d20:	31 f0       	breq	.+12     	; 0x1d2e <Endpoint_ConfigureEndpointTable+0x78>
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1d22:	0f 5f       	subi	r16, 0xFF	; 255
    1d24:	25 96       	adiw	r28, 0x05	; 5
    1d26:	01 17       	cp	r16, r17
    1d28:	a0 f2       	brcs	.-88     	; 0x1cd2 <Endpoint_ConfigureEndpointTable+0x1c>
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}
	
	return true;
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	01 c0       	rjmp	.+2      	; 0x1d30 <Endpoint_ConfigureEndpointTable+0x7a>
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1d2e:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	return true;
}
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	1f 91       	pop	r17
    1d36:	0f 91       	pop	r16
    1d38:	ff 90       	pop	r15
    1d3a:	ef 90       	pop	r14
    1d3c:	08 95       	ret

00001d3e <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1d3e:	80 91 03 14 	lds	r24, 0x1403
    1d42:	87 ff       	sbrs	r24, 7
    1d44:	13 c0       	rjmp	.+38     	; 0x1d6c <Endpoint_ClearStatusStage+0x2e>
    1d46:	04 c0       	rjmp	.+8      	; 0x1d50 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1d48:	80 91 02 14 	lds	r24, 0x1402
    1d4c:	88 23       	and	r24, r24
    1d4e:	b9 f0       	breq	.+46     	; 0x1d7e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1d50:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1d54:	82 ff       	sbrs	r24, 2
    1d56:	f8 cf       	rjmp	.-16     	; 0x1d48 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1d58:	80 91 e8 00 	lds	r24, 0x00E8
    1d5c:	8b 77       	andi	r24, 0x7B	; 123
    1d5e:	80 93 e8 00 	sts	0x00E8, r24
    1d62:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1d64:	80 91 02 14 	lds	r24, 0x1402
    1d68:	88 23       	and	r24, r24
    1d6a:	49 f0       	breq	.+18     	; 0x1d7e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1d6c:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1d70:	80 ff       	sbrs	r24, 0
    1d72:	f8 cf       	rjmp	.-16     	; 0x1d64 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1d74:	80 91 e8 00 	lds	r24, 0x00E8
    1d78:	8e 77       	andi	r24, 0x7E	; 126
    1d7a:	80 93 e8 00 	sts	0x00E8, r24
    1d7e:	08 95       	ret

00001d80 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1d80:	80 91 e4 00 	lds	r24, 0x00E4
    1d84:	90 91 e5 00 	lds	r25, 0x00E5

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    1d88:	44 e6       	ldi	r20, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1d8a:	20 91 ec 00 	lds	r18, 0x00EC
    1d8e:	20 ff       	sbrs	r18, 0
    1d90:	26 c0       	rjmp	.+76     	; 0x1dde <Endpoint_WaitUntilReady+0x5e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1d92:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1d96:	20 fd       	sbrc	r18, 0
    1d98:	16 c0       	rjmp	.+44     	; 0x1dc6 <Endpoint_WaitUntilReady+0x46>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1d9a:	20 91 02 14 	lds	r18, 0x1402

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1d9e:	22 23       	and	r18, r18
    1da0:	a1 f0       	breq	.+40     	; 0x1dca <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1da2:	25 30       	cpi	r18, 0x05	; 5
    1da4:	a1 f0       	breq	.+40     	; 0x1dce <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1da6:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1daa:	25 fd       	sbrc	r18, 5
    1dac:	12 c0       	rjmp	.+36     	; 0x1dd2 <Endpoint_WaitUntilReady+0x52>
    1dae:	20 91 e4 00 	lds	r18, 0x00E4
    1db2:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1db6:	28 17       	cp	r18, r24
    1db8:	39 07       	cpc	r19, r25
    1dba:	39 f3       	breq	.-50     	; 0x1d8a <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1dbc:	44 23       	and	r20, r20
    1dbe:	59 f0       	breq	.+22     	; 0x1dd6 <Endpoint_WaitUntilReady+0x56>
    1dc0:	41 50       	subi	r20, 0x01	; 1
    1dc2:	c9 01       	movw	r24, r18
    1dc4:	e2 cf       	rjmp	.-60     	; 0x1d8a <Endpoint_WaitUntilReady+0xa>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1dc6:	80 e0       	ldi	r24, 0x00	; 0
    1dc8:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1dca:	82 e0       	ldi	r24, 0x02	; 2
    1dcc:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1dce:	83 e0       	ldi	r24, 0x03	; 3
    1dd0:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1dd2:	81 e0       	ldi	r24, 0x01	; 1
    1dd4:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    1dd6:	84 e0       	ldi	r24, 0x04	; 4
    1dd8:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    1dda:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1ddc:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1dde:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1de2:	22 ff       	sbrs	r18, 2
    1de4:	da cf       	rjmp	.-76     	; 0x1d9a <Endpoint_WaitUntilReady+0x1a>
    1de6:	f9 cf       	rjmp	.-14     	; 0x1dda <Endpoint_WaitUntilReady+0x5a>

00001de8 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    1de8:	0f 93       	push	r16
    1dea:	1f 93       	push	r17
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1df0:	4e d0       	rcall	.+156    	; 0x1e8e <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1df2:	55 d0       	rcall	.+170    	; 0x1e9e <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1df4:	c8 ed       	ldi	r28, 0xD8	; 216
    1df6:	d0 e0       	ldi	r29, 0x00	; 0
    1df8:	88 81       	ld	r24, Y
    1dfa:	8f 77       	andi	r24, 0x7F	; 127
    1dfc:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    1dfe:	88 81       	ld	r24, Y
    1e00:	80 68       	ori	r24, 0x80	; 128
    1e02:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1e04:	88 81       	ld	r24, Y
    1e06:	8f 7d       	andi	r24, 0xDF	; 223
    1e08:	88 83       	st	Y, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1e0a:	e7 ed       	ldi	r30, 0xD7	; 215
    1e0c:	f0 e0       	ldi	r31, 0x00	; 0
    1e0e:	80 81       	ld	r24, Z
    1e10:	80 68       	ori	r24, 0x80	; 128
    1e12:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1e14:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1e16:	10 92 02 14 	sts	0x1402, r1
	USB_Device_ConfigurationNumber  = 0;
    1e1a:	10 92 fe 13 	sts	0x13FE, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1e1e:	10 92 00 14 	sts	0x1400, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1e22:	10 92 ff 13 	sts	0x13FF, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1e26:	00 ee       	ldi	r16, 0xE0	; 224
    1e28:	10 e0       	ldi	r17, 0x00	; 0
    1e2a:	f8 01       	movw	r30, r16
    1e2c:	80 81       	ld	r24, Z
    1e2e:	8b 7f       	andi	r24, 0xFB	; 251
    1e30:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1e32:	88 81       	ld	r24, Y
    1e34:	81 60       	ori	r24, 0x01	; 1
    1e36:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1e38:	80 e0       	ldi	r24, 0x00	; 0
    1e3a:	60 e0       	ldi	r22, 0x00	; 0
    1e3c:	42 e0       	ldi	r20, 0x02	; 2
    1e3e:	04 df       	rcall	.-504    	; 0x1c48 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1e40:	e1 ee       	ldi	r30, 0xE1	; 225
    1e42:	f0 e0       	ldi	r31, 0x00	; 0
    1e44:	80 81       	ld	r24, Z
    1e46:	8e 7f       	andi	r24, 0xFE	; 254
    1e48:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1e4a:	e2 ee       	ldi	r30, 0xE2	; 226
    1e4c:	f0 e0       	ldi	r31, 0x00	; 0
    1e4e:	80 81       	ld	r24, Z
    1e50:	81 60       	ori	r24, 0x01	; 1
    1e52:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1e54:	80 81       	ld	r24, Z
    1e56:	88 60       	ori	r24, 0x08	; 8
    1e58:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1e5a:	f8 01       	movw	r30, r16
    1e5c:	80 81       	ld	r24, Z
    1e5e:	8e 7f       	andi	r24, 0xFE	; 254
    1e60:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    1e62:	88 81       	ld	r24, Y
    1e64:	80 61       	ori	r24, 0x10	; 16
    1e66:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1e68:	df 91       	pop	r29
    1e6a:	cf 91       	pop	r28
    1e6c:	1f 91       	pop	r17
    1e6e:	0f 91       	pop	r16
    1e70:	08 95       	ret

00001e72 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    1e72:	e8 ed       	ldi	r30, 0xD8	; 216
    1e74:	f0 e0       	ldi	r31, 0x00	; 0
    1e76:	80 81       	ld	r24, Z
    1e78:	8f 7e       	andi	r24, 0xEF	; 239
    1e7a:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    1e7c:	e7 ed       	ldi	r30, 0xD7	; 215
    1e7e:	f0 e0       	ldi	r31, 0x00	; 0
    1e80:	80 81       	ld	r24, Z
    1e82:	81 60       	ori	r24, 0x01	; 1
    1e84:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	80 93 01 14 	sts	0x1401, r24

	USB_ResetInterface();
}
    1e8c:	ad cf       	rjmp	.-166    	; 0x1de8 <USB_ResetInterface>

00001e8e <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1e8e:	e8 ed       	ldi	r30, 0xD8	; 216
    1e90:	f0 e0       	ldi	r31, 0x00	; 0
    1e92:	80 81       	ld	r24, Z
    1e94:	8c 7f       	andi	r24, 0xFC	; 252
    1e96:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1e98:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1e9c:	08 95       	ret

00001e9e <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1e9e:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1ea2:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1ea6:	08 95       	ret

00001ea8 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1ea8:	1f 92       	push	r1
    1eaa:	0f 92       	push	r0
    1eac:	0f b6       	in	r0, 0x3f	; 63
    1eae:	0f 92       	push	r0
    1eb0:	0b b6       	in	r0, 0x3b	; 59
    1eb2:	0f 92       	push	r0
    1eb4:	11 24       	eor	r1, r1
    1eb6:	2f 93       	push	r18
    1eb8:	3f 93       	push	r19
    1eba:	4f 93       	push	r20
    1ebc:	5f 93       	push	r21
    1ebe:	6f 93       	push	r22
    1ec0:	7f 93       	push	r23
    1ec2:	8f 93       	push	r24
    1ec4:	9f 93       	push	r25
    1ec6:	af 93       	push	r26
    1ec8:	bf 93       	push	r27
    1eca:	ef 93       	push	r30
    1ecc:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1ece:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1ed2:	82 ff       	sbrs	r24, 2
    1ed4:	0a c0       	rjmp	.+20     	; 0x1eea <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1ed6:	80 91 e2 00 	lds	r24, 0x00E2
    1eda:	82 ff       	sbrs	r24, 2
    1edc:	06 c0       	rjmp	.+12     	; 0x1eea <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1ede:	80 91 e1 00 	lds	r24, 0x00E1
    1ee2:	8b 7f       	andi	r24, 0xFB	; 251
    1ee4:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1ee8:	0f d2       	rcall	.+1054   	; 0x2308 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1eea:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1eee:	80 ff       	sbrs	r24, 0
    1ef0:	1f c0       	rjmp	.+62     	; 0x1f30 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1ef2:	80 91 d8 00 	lds	r24, 0x00D8
    1ef6:	80 ff       	sbrs	r24, 0
    1ef8:	1b c0       	rjmp	.+54     	; 0x1f30 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1efa:	80 91 da 00 	lds	r24, 0x00DA
    1efe:	8e 7f       	andi	r24, 0xFE	; 254
    1f00:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1f04:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1f08:	80 ff       	sbrs	r24, 0
    1f0a:	0d c0       	rjmp	.+26     	; 0x1f26 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1f0c:	8c e0       	ldi	r24, 0x0C	; 12
    1f0e:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1f10:	8e e0       	ldi	r24, 0x0E	; 14
    1f12:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1f14:	09 b4       	in	r0, 0x29	; 41
    1f16:	00 fe       	sbrs	r0, 0
    1f18:	fd cf       	rjmp	.-6      	; 0x1f14 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	80 93 02 14 	sts	0x1402, r24
			EVENT_USB_Device_Connect();
    1f20:	0e 94 9f 02 	call	0x53e	; 0x53e <EVENT_USB_Device_Connect>
    1f24:	05 c0       	rjmp	.+10     	; 0x1f30 <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1f26:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1f28:	10 92 02 14 	sts	0x1402, r1
			EVENT_USB_Device_Disconnect();
    1f2c:	0e 94 a1 02 	call	0x542	; 0x542 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1f30:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1f34:	80 ff       	sbrs	r24, 0
    1f36:	18 c0       	rjmp	.+48     	; 0x1f68 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1f38:	80 91 e2 00 	lds	r24, 0x00E2
    1f3c:	80 ff       	sbrs	r24, 0
    1f3e:	14 c0       	rjmp	.+40     	; 0x1f68 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1f40:	80 91 e2 00 	lds	r24, 0x00E2
    1f44:	8e 7f       	andi	r24, 0xFE	; 254
    1f46:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1f4a:	80 91 e2 00 	lds	r24, 0x00E2
    1f4e:	80 61       	ori	r24, 0x10	; 16
    1f50:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    1f54:	80 91 d8 00 	lds	r24, 0x00D8
    1f58:	80 62       	ori	r24, 0x20	; 32
    1f5a:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1f5e:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1f60:	85 e0       	ldi	r24, 0x05	; 5
    1f62:	80 93 02 14 	sts	0x1402, r24
		EVENT_USB_Device_Suspend();
    1f66:	d0 d1       	rcall	.+928    	; 0x2308 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1f68:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1f6c:	84 ff       	sbrs	r24, 4
    1f6e:	2d c0       	rjmp	.+90     	; 0x1fca <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1f70:	80 91 e2 00 	lds	r24, 0x00E2
    1f74:	84 ff       	sbrs	r24, 4
    1f76:	29 c0       	rjmp	.+82     	; 0x1fca <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1f78:	8c e0       	ldi	r24, 0x0C	; 12
    1f7a:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1f7c:	8e e0       	ldi	r24, 0x0E	; 14
    1f7e:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1f80:	09 b4       	in	r0, 0x29	; 41
    1f82:	00 fe       	sbrs	r0, 0
    1f84:	fd cf       	rjmp	.-6      	; 0x1f80 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1f86:	80 91 d8 00 	lds	r24, 0x00D8
    1f8a:	8f 7d       	andi	r24, 0xDF	; 223
    1f8c:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1f90:	80 91 e1 00 	lds	r24, 0x00E1
    1f94:	8f 7e       	andi	r24, 0xEF	; 239
    1f96:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1f9a:	80 91 e2 00 	lds	r24, 0x00E2
    1f9e:	8f 7e       	andi	r24, 0xEF	; 239
    1fa0:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1fa4:	80 91 e2 00 	lds	r24, 0x00E2
    1fa8:	81 60       	ori	r24, 0x01	; 1
    1faa:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1fae:	80 91 fe 13 	lds	r24, 0x13FE
    1fb2:	88 23       	and	r24, r24
    1fb4:	21 f4       	brne	.+8      	; 0x1fbe <__vector_10+0x116>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1fb6:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1fba:	87 ff       	sbrs	r24, 7
    1fbc:	02 c0       	rjmp	.+4      	; 0x1fc2 <__vector_10+0x11a>
    1fbe:	84 e0       	ldi	r24, 0x04	; 4
    1fc0:	01 c0       	rjmp	.+2      	; 0x1fc4 <__vector_10+0x11c>
    1fc2:	81 e0       	ldi	r24, 0x01	; 1
    1fc4:	80 93 02 14 	sts	0x1402, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1fc8:	9f d1       	rcall	.+830    	; 0x2308 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1fca:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1fce:	83 ff       	sbrs	r24, 3
    1fd0:	22 c0       	rjmp	.+68     	; 0x2016 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1fd2:	80 91 e2 00 	lds	r24, 0x00E2
    1fd6:	83 ff       	sbrs	r24, 3
    1fd8:	1e c0       	rjmp	.+60     	; 0x2016 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1fda:	80 91 e1 00 	lds	r24, 0x00E1
    1fde:	87 7f       	andi	r24, 0xF7	; 247
    1fe0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1fe4:	82 e0       	ldi	r24, 0x02	; 2
    1fe6:	80 93 02 14 	sts	0x1402, r24
		USB_Device_ConfigurationNumber = 0;
    1fea:	10 92 fe 13 	sts	0x13FE, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1fee:	80 91 e1 00 	lds	r24, 0x00E1
    1ff2:	8e 7f       	andi	r24, 0xFE	; 254
    1ff4:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1ff8:	80 91 e2 00 	lds	r24, 0x00E2
    1ffc:	8e 7f       	andi	r24, 0xFE	; 254
    1ffe:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2002:	80 91 e2 00 	lds	r24, 0x00E2
    2006:	80 61       	ori	r24, 0x10	; 16
    2008:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    200c:	80 e0       	ldi	r24, 0x00	; 0
    200e:	60 e0       	ldi	r22, 0x00	; 0
    2010:	42 e0       	ldi	r20, 0x02	; 2
    2012:	1a de       	rcall	.-972    	; 0x1c48 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2014:	79 d1       	rcall	.+754    	; 0x2308 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2016:	ff 91       	pop	r31
    2018:	ef 91       	pop	r30
    201a:	bf 91       	pop	r27
    201c:	af 91       	pop	r26
    201e:	9f 91       	pop	r25
    2020:	8f 91       	pop	r24
    2022:	7f 91       	pop	r23
    2024:	6f 91       	pop	r22
    2026:	5f 91       	pop	r21
    2028:	4f 91       	pop	r20
    202a:	3f 91       	pop	r19
    202c:	2f 91       	pop	r18
    202e:	0f 90       	pop	r0
    2030:	0b be       	out	0x3b, r0	; 59
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63
    2036:	0f 90       	pop	r0
    2038:	1f 90       	pop	r1
    203a:	18 95       	reti

0000203c <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    203c:	1f 93       	push	r17
    203e:	df 93       	push	r29
    2040:	cf 93       	push	r28
    2042:	cd b7       	in	r28, 0x3d	; 61
    2044:	de b7       	in	r29, 0x3e	; 62
    2046:	ac 97       	sbiw	r28, 0x2c	; 44
    2048:	0f b6       	in	r0, 0x3f	; 63
    204a:	f8 94       	cli
    204c:	de bf       	out	0x3e, r29	; 62
    204e:	0f be       	out	0x3f, r0	; 63
    2050:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    2052:	e3 e0       	ldi	r30, 0x03	; 3
    2054:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2056:	80 91 f1 00 	lds	r24, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    205a:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    205c:	24 e1       	ldi	r18, 0x14	; 20
    205e:	eb 30       	cpi	r30, 0x0B	; 11
    2060:	f2 07       	cpc	r31, r18
    2062:	c9 f7       	brne	.-14     	; 0x2056 <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2064:	0e 94 ad 02 	call	0x55a	; 0x55a <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2068:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    206c:	83 ff       	sbrs	r24, 3
    206e:	34 c1       	rjmp	.+616    	; 0x22d8 <__stack+0x1d9>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2070:	80 91 03 14 	lds	r24, 0x1403

		switch (USB_ControlRequest.bRequest)
    2074:	20 91 04 14 	lds	r18, 0x1404
    2078:	25 30       	cpi	r18, 0x05	; 5
    207a:	09 f4       	brne	.+2      	; 0x207e <USB_Device_ProcessControlRequest+0x42>
    207c:	84 c0       	rjmp	.+264    	; 0x2186 <__stack+0x87>
    207e:	26 30       	cpi	r18, 0x06	; 6
    2080:	40 f4       	brcc	.+16     	; 0x2092 <USB_Device_ProcessControlRequest+0x56>
    2082:	21 30       	cpi	r18, 0x01	; 1
    2084:	a1 f1       	breq	.+104    	; 0x20ee <USB_Device_ProcessControlRequest+0xb2>
    2086:	21 30       	cpi	r18, 0x01	; 1
    2088:	70 f0       	brcs	.+28     	; 0x20a6 <USB_Device_ProcessControlRequest+0x6a>
    208a:	23 30       	cpi	r18, 0x03	; 3
    208c:	09 f0       	breq	.+2      	; 0x2090 <USB_Device_ProcessControlRequest+0x54>
    208e:	24 c1       	rjmp	.+584    	; 0x22d8 <__stack+0x1d9>
    2090:	2e c0       	rjmp	.+92     	; 0x20ee <USB_Device_ProcessControlRequest+0xb2>
    2092:	28 30       	cpi	r18, 0x08	; 8
    2094:	09 f4       	brne	.+2      	; 0x2098 <USB_Device_ProcessControlRequest+0x5c>
    2096:	f1 c0       	rjmp	.+482    	; 0x227a <__stack+0x17b>
    2098:	29 30       	cpi	r18, 0x09	; 9
    209a:	09 f4       	brne	.+2      	; 0x209e <USB_Device_ProcessControlRequest+0x62>
    209c:	00 c1       	rjmp	.+512    	; 0x229e <__stack+0x19f>
    209e:	26 30       	cpi	r18, 0x06	; 6
    20a0:	09 f0       	breq	.+2      	; 0x20a4 <USB_Device_ProcessControlRequest+0x68>
    20a2:	1a c1       	rjmp	.+564    	; 0x22d8 <__stack+0x1d9>
    20a4:	93 c0       	rjmp	.+294    	; 0x21cc <__stack+0xcd>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    20a6:	80 38       	cpi	r24, 0x80	; 128
    20a8:	21 f0       	breq	.+8      	; 0x20b2 <USB_Device_ProcessControlRequest+0x76>
    20aa:	82 38       	cpi	r24, 0x82	; 130
    20ac:	09 f0       	breq	.+2      	; 0x20b0 <USB_Device_ProcessControlRequest+0x74>
    20ae:	14 c1       	rjmp	.+552    	; 0x22d8 <__stack+0x1d9>
    20b0:	08 c0       	rjmp	.+16     	; 0x20c2 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    20b2:	80 91 ff 13 	lds	r24, 0x13FF
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    20b6:	90 91 00 14 	lds	r25, 0x1400
    20ba:	99 23       	and	r25, r25
    20bc:	71 f0       	breq	.+28     	; 0x20da <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    20be:	82 60       	ori	r24, 0x02	; 2
    20c0:	0c c0       	rjmp	.+24     	; 0x20da <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    20c2:	80 91 07 14 	lds	r24, 0x1407
    20c6:	8f 70       	andi	r24, 0x0F	; 15
    20c8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    20cc:	90 91 eb 00 	lds	r25, 0x00EB
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);

			CurrentStatus = Endpoint_IsStalled();
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	95 ff       	sbrs	r25, 5
    20d4:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    20d6:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20da:	90 91 e8 00 	lds	r25, 0x00E8
    20de:	97 7f       	andi	r25, 0xF7	; 247
    20e0:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    20e4:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    20e8:	10 92 f1 00 	sts	0x00F1, r1
    20ec:	d1 c0       	rjmp	.+418    	; 0x2290 <__stack+0x191>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    20ee:	88 23       	and	r24, r24
    20f0:	19 f0       	breq	.+6      	; 0x20f8 <USB_Device_ProcessControlRequest+0xbc>
    20f2:	82 30       	cpi	r24, 0x02	; 2
    20f4:	09 f0       	breq	.+2      	; 0x20f8 <USB_Device_ProcessControlRequest+0xbc>
    20f6:	f0 c0       	rjmp	.+480    	; 0x22d8 <__stack+0x1d9>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    20f8:	90 e0       	ldi	r25, 0x00	; 0
    20fa:	8f 71       	andi	r24, 0x1F	; 31
    20fc:	90 70       	andi	r25, 0x00	; 0
    20fe:	00 97       	sbiw	r24, 0x00	; 0
    2100:	29 f0       	breq	.+10     	; 0x210c <__stack+0xd>
    2102:	82 30       	cpi	r24, 0x02	; 2
    2104:	91 05       	cpc	r25, r1
    2106:	09 f0       	breq	.+2      	; 0x210a <__stack+0xb>
    2108:	e7 c0       	rjmp	.+462    	; 0x22d8 <__stack+0x1d9>
    210a:	0b c0       	rjmp	.+22     	; 0x2122 <__stack+0x23>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    210c:	80 91 05 14 	lds	r24, 0x1405
    2110:	81 30       	cpi	r24, 0x01	; 1
    2112:	09 f0       	breq	.+2      	; 0x2116 <__stack+0x17>
    2114:	e1 c0       	rjmp	.+450    	; 0x22d8 <__stack+0x1d9>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2116:	23 30       	cpi	r18, 0x03	; 3
    2118:	09 f0       	breq	.+2      	; 0x211c <__stack+0x1d>
    211a:	80 e0       	ldi	r24, 0x00	; 0
    211c:	80 93 00 14 	sts	0x1400, r24
    2120:	2c c0       	rjmp	.+88     	; 0x217a <__stack+0x7b>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    2122:	80 91 05 14 	lds	r24, 0x1405
    2126:	88 23       	and	r24, r24
    2128:	41 f5       	brne	.+80     	; 0x217a <__stack+0x7b>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    212a:	20 91 07 14 	lds	r18, 0x1407
    212e:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2130:	09 f4       	brne	.+2      	; 0x2134 <__stack+0x35>
    2132:	d2 c0       	rjmp	.+420    	; 0x22d8 <__stack+0x1d9>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2134:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2138:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    213c:	80 ff       	sbrs	r24, 0
    213e:	1d c0       	rjmp	.+58     	; 0x217a <__stack+0x7b>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2140:	80 91 04 14 	lds	r24, 0x1404
    2144:	83 30       	cpi	r24, 0x03	; 3
    2146:	21 f4       	brne	.+8      	; 0x2150 <__stack+0x51>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2148:	80 91 eb 00 	lds	r24, 0x00EB
    214c:	80 62       	ori	r24, 0x20	; 32
    214e:	13 c0       	rjmp	.+38     	; 0x2176 <__stack+0x77>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2150:	80 91 eb 00 	lds	r24, 0x00EB
    2154:	80 61       	ori	r24, 0x10	; 16
    2156:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	02 c0       	rjmp	.+4      	; 0x2164 <__stack+0x65>
    2160:	88 0f       	add	r24, r24
    2162:	99 1f       	adc	r25, r25
    2164:	2a 95       	dec	r18
    2166:	e2 f7       	brpl	.-8      	; 0x2160 <__stack+0x61>
    2168:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    216c:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2170:	80 91 eb 00 	lds	r24, 0x00EB
    2174:	88 60       	ori	r24, 0x08	; 8
    2176:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    217a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    217e:	80 91 e8 00 	lds	r24, 0x00E8
    2182:	87 7f       	andi	r24, 0xF7	; 247
    2184:	88 c0       	rjmp	.+272    	; 0x2296 <__stack+0x197>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2186:	88 23       	and	r24, r24
    2188:	09 f0       	breq	.+2      	; 0x218c <__stack+0x8d>
    218a:	a6 c0       	rjmp	.+332    	; 0x22d8 <__stack+0x1d9>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    218c:	10 91 05 14 	lds	r17, 0x1405
    2190:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2192:	80 91 e3 00 	lds	r24, 0x00E3
    2196:	80 78       	andi	r24, 0x80	; 128
    2198:	81 2b       	or	r24, r17
    219a:	80 93 e3 00 	sts	0x00E3, r24
    219e:	80 91 e8 00 	lds	r24, 0x00E8
    21a2:	87 7f       	andi	r24, 0xF7	; 247
    21a4:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    21a8:	ca dd       	rcall	.-1132   	; 0x1d3e <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    21aa:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    21ae:	80 ff       	sbrs	r24, 0
    21b0:	fc cf       	rjmp	.-8      	; 0x21aa <__stack+0xab>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    21b2:	80 91 e3 00 	lds	r24, 0x00E3
    21b6:	80 68       	ori	r24, 0x80	; 128
    21b8:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    21bc:	11 23       	and	r17, r17
    21be:	11 f0       	breq	.+4      	; 0x21c4 <__stack+0xc5>
    21c0:	83 e0       	ldi	r24, 0x03	; 3
    21c2:	01 c0       	rjmp	.+2      	; 0x21c6 <__stack+0xc7>
    21c4:	82 e0       	ldi	r24, 0x02	; 2
    21c6:	80 93 02 14 	sts	0x1402, r24
    21ca:	86 c0       	rjmp	.+268    	; 0x22d8 <__stack+0x1d9>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    21cc:	80 58       	subi	r24, 0x80	; 128
    21ce:	82 30       	cpi	r24, 0x02	; 2
    21d0:	08 f0       	brcs	.+2      	; 0x21d4 <__stack+0xd5>
    21d2:	82 c0       	rjmp	.+260    	; 0x22d8 <__stack+0x1d9>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    21d4:	80 91 05 14 	lds	r24, 0x1405
    21d8:	90 91 06 14 	lds	r25, 0x1406
    21dc:	23 e0       	ldi	r18, 0x03	; 3
    21de:	8c 3d       	cpi	r24, 0xDC	; 220
    21e0:	92 07       	cpc	r25, r18
    21e2:	91 f5       	brne	.+100    	; 0x2248 <__stack+0x149>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    21e4:	83 e0       	ldi	r24, 0x03	; 3
    21e6:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    21e8:	8a e2       	ldi	r24, 0x2A	; 42
    21ea:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    21ec:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    21ee:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    21f0:	de 01       	movw	r26, r28
    21f2:	15 96       	adiw	r26, 0x05	; 5
    21f4:	80 e0       	ldi	r24, 0x00	; 0
    21f6:	90 e0       	ldi	r25, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    21f8:	4e e0       	ldi	r20, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    21fa:	61 e2       	ldi	r22, 0x21	; 33
    21fc:	e4 2f       	mov	r30, r20
    21fe:	f0 e0       	ldi	r31, 0x00	; 0
    2200:	60 93 57 00 	sts	0x0057, r22
    2204:	e4 91       	lpm	r30, Z+

					if (SerialCharNum & 0x01)
    2206:	80 ff       	sbrs	r24, 0
    2208:	03 c0       	rjmp	.+6      	; 0x2210 <__stack+0x111>
					{
						SerialByte >>= 4;
    220a:	e2 95       	swap	r30
    220c:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    220e:	4f 5f       	subi	r20, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2210:	ef 70       	andi	r30, 0x0F	; 15
    2212:	2e 2f       	mov	r18, r30
    2214:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2216:	ea 30       	cpi	r30, 0x0A	; 10
    2218:	18 f0       	brcs	.+6      	; 0x2220 <__stack+0x121>
    221a:	29 5c       	subi	r18, 0xC9	; 201
    221c:	3f 4f       	sbci	r19, 0xFF	; 255
    221e:	02 c0       	rjmp	.+4      	; 0x2224 <__stack+0x125>
    2220:	20 5d       	subi	r18, 0xD0	; 208
    2222:	3f 4f       	sbci	r19, 0xFF	; 255
    2224:	2d 93       	st	X+, r18
    2226:	3d 93       	st	X+, r19
    2228:	01 96       	adiw	r24, 0x01	; 1
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    222a:	84 31       	cpi	r24, 0x14	; 20
    222c:	91 05       	cpc	r25, r1
    222e:	31 f7       	brne	.-52     	; 0x21fc <__stack+0xfd>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2230:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2232:	80 91 e8 00 	lds	r24, 0x00E8
    2236:	87 7f       	andi	r24, 0xF7	; 247
    2238:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    223c:	ce 01       	movw	r24, r28
    223e:	03 96       	adiw	r24, 0x03	; 3
    2240:	6a e2       	ldi	r22, 0x2A	; 42
    2242:	70 e0       	ldi	r23, 0x00	; 0
    2244:	04 dc       	rcall	.-2040   	; 0x1a4e <Endpoint_Write_Control_Stream_LE>
    2246:	13 c0       	rjmp	.+38     	; 0x226e <__stack+0x16f>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2248:	60 91 07 14 	lds	r22, 0x1407
    224c:	ae 01       	movw	r20, r28
    224e:	4f 5f       	subi	r20, 0xFF	; 255
    2250:	5f 4f       	sbci	r21, 0xFF	; 255
    2252:	0e 94 b1 02 	call	0x562	; 0x562 <CALLBACK_USB_GetDescriptor>
    2256:	bc 01       	movw	r22, r24
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	09 f4       	brne	.+2      	; 0x225e <__stack+0x15f>
    225c:	3d c0       	rjmp	.+122    	; 0x22d8 <__stack+0x1d9>
    225e:	80 91 e8 00 	lds	r24, 0x00E8
    2262:	87 7f       	andi	r24, 0xF7	; 247
    2264:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2268:	89 81       	ldd	r24, Y+1	; 0x01
    226a:	9a 81       	ldd	r25, Y+2	; 0x02
    226c:	8f dc       	rcall	.-1762   	; 0x1b8c <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    226e:	80 91 e8 00 	lds	r24, 0x00E8
    2272:	8b 77       	andi	r24, 0x7B	; 123
    2274:	80 93 e8 00 	sts	0x00E8, r24
    2278:	2f c0       	rjmp	.+94     	; 0x22d8 <__stack+0x1d9>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    227a:	80 38       	cpi	r24, 0x80	; 128
    227c:	69 f5       	brne	.+90     	; 0x22d8 <__stack+0x1d9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    227e:	80 91 e8 00 	lds	r24, 0x00E8
    2282:	87 7f       	andi	r24, 0xF7	; 247
    2284:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2288:	80 91 fe 13 	lds	r24, 0x13FE
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    228c:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2290:	80 91 e8 00 	lds	r24, 0x00E8
    2294:	8e 77       	andi	r24, 0x7E	; 126
    2296:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    229a:	51 dd       	rcall	.-1374   	; 0x1d3e <Endpoint_ClearStatusStage>
    229c:	1d c0       	rjmp	.+58     	; 0x22d8 <__stack+0x1d9>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    229e:	88 23       	and	r24, r24
    22a0:	d9 f4       	brne	.+54     	; 0x22d8 <__stack+0x1d9>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    22a2:	90 91 05 14 	lds	r25, 0x1405
    22a6:	92 30       	cpi	r25, 0x02	; 2
    22a8:	b8 f4       	brcc	.+46     	; 0x22d8 <__stack+0x1d9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    22aa:	80 91 e8 00 	lds	r24, 0x00E8
    22ae:	87 7f       	andi	r24, 0xF7	; 247
    22b0:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    22b4:	90 93 fe 13 	sts	0x13FE, r25

	Endpoint_ClearStatusStage();
    22b8:	42 dd       	rcall	.-1404   	; 0x1d3e <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    22ba:	80 91 fe 13 	lds	r24, 0x13FE
    22be:	88 23       	and	r24, r24
    22c0:	21 f4       	brne	.+8      	; 0x22ca <__stack+0x1cb>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    22c2:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    22c6:	87 ff       	sbrs	r24, 7
    22c8:	02 c0       	rjmp	.+4      	; 0x22ce <__stack+0x1cf>
    22ca:	84 e0       	ldi	r24, 0x04	; 4
    22cc:	01 c0       	rjmp	.+2      	; 0x22d0 <__stack+0x1d1>
    22ce:	81 e0       	ldi	r24, 0x01	; 1
    22d0:	80 93 02 14 	sts	0x1402, r24

	EVENT_USB_Device_ConfigurationChanged();
    22d4:	0e 94 a3 02 	call	0x546	; 0x546 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22d8:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    22dc:	83 ff       	sbrs	r24, 3
    22de:	0a c0       	rjmp	.+20     	; 0x22f4 <__stack+0x1f5>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    22e0:	80 91 e8 00 	lds	r24, 0x00E8
    22e4:	87 7f       	andi	r24, 0xF7	; 247
    22e6:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    22ea:	80 91 eb 00 	lds	r24, 0x00EB
    22ee:	80 62       	ori	r24, 0x20	; 32
    22f0:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    22f4:	ac 96       	adiw	r28, 0x2c	; 44
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	de bf       	out	0x3e, r29	; 62
    22fc:	0f be       	out	0x3f, r0	; 63
    22fe:	cd bf       	out	0x3d, r28	; 61
    2300:	cf 91       	pop	r28
    2302:	df 91       	pop	r29
    2304:	1f 91       	pop	r17
    2306:	08 95       	ret

00002308 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2308:	08 95       	ret

0000230a <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    230a:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    230c:	80 91 02 14 	lds	r24, 0x1402
    2310:	88 23       	and	r24, r24
    2312:	a9 f0       	breq	.+42     	; 0x233e <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2314:	80 91 e9 00 	lds	r24, 0x00E9
    2318:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    231a:	90 91 ec 00 	lds	r25, 0x00EC
    231e:	90 ff       	sbrs	r25, 0
    2320:	02 c0       	rjmp	.+4      	; 0x2326 <USB_USBTask+0x1c>
    2322:	10 e8       	ldi	r17, 0x80	; 128
    2324:	01 c0       	rjmp	.+2      	; 0x2328 <USB_USBTask+0x1e>
    2326:	10 e0       	ldi	r17, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2328:	18 2b       	or	r17, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    232a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    232e:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    2332:	83 ff       	sbrs	r24, 3
    2334:	01 c0       	rjmp	.+2      	; 0x2338 <USB_USBTask+0x2e>
	  USB_Device_ProcessControlRequest();
    2336:	82 de       	rcall	.-764    	; 0x203c <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2338:	1f 70       	andi	r17, 0x0F	; 15
    233a:	10 93 e9 00 	sts	0x00E9, r17
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    233e:	1f 91       	pop	r17
    2340:	08 95       	ret

00002342 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2342:	ef 92       	push	r14
    2344:	ff 92       	push	r15
    2346:	0f 93       	push	r16
    2348:	1f 93       	push	r17
    234a:	cf 93       	push	r28
    234c:	df 93       	push	r29
    234e:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2350:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    2354:	83 ff       	sbrs	r24, 3
    2356:	c8 c2       	rjmp	.+1424   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    2358:	88 81       	ld	r24, Y
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	20 91 07 14 	lds	r18, 0x1407
    2360:	30 91 08 14 	lds	r19, 0x1408
    2364:	28 17       	cp	r18, r24
    2366:	39 07       	cpc	r19, r25
    2368:	09 f0       	breq	.+2      	; 0x236c <RNDIS_Device_ProcessControlRequest+0x2a>
    236a:	be c2       	rjmp	.+1404   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
	  return;

	switch (USB_ControlRequest.bRequest)
    236c:	80 91 04 14 	lds	r24, 0x1404
    2370:	88 23       	and	r24, r24
    2372:	21 f0       	breq	.+8      	; 0x237c <RNDIS_Device_ProcessControlRequest+0x3a>
    2374:	81 30       	cpi	r24, 0x01	; 1
    2376:	09 f0       	breq	.+2      	; 0x237a <RNDIS_Device_ProcessControlRequest+0x38>
    2378:	b7 c2       	rjmp	.+1390   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
    237a:	6b c2       	rjmp	.+1238   	; 0x2852 <RNDIS_Device_ProcessControlRequest+0x510>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    237c:	80 91 03 14 	lds	r24, 0x1403
    2380:	81 32       	cpi	r24, 0x21	; 33
    2382:	09 f0       	breq	.+2      	; 0x2386 <RNDIS_Device_ProcessControlRequest+0x44>
    2384:	b1 c2       	rjmp	.+1378   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2386:	80 91 e8 00 	lds	r24, 0x00E8
    238a:	87 7f       	andi	r24, 0xF7	; 247
    238c:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    2390:	8e 01       	movw	r16, r28
    2392:	08 5e       	subi	r16, 0xE8	; 232
    2394:	1f 4f       	sbci	r17, 0xFF	; 255
    2396:	60 91 09 14 	lds	r22, 0x1409
    239a:	70 91 0a 14 	lds	r23, 0x140A
    239e:	c8 01       	movw	r24, r16
    23a0:	b4 db       	rcall	.-2200   	; 0x1b0a <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23a2:	80 91 e8 00 	lds	r24, 0x00E8
    23a6:	8e 77       	andi	r24, 0x7E	; 126
    23a8:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    23ac:	88 8d       	ldd	r24, Y+24	; 0x18
    23ae:	99 8d       	ldd	r25, Y+25	; 0x19
    23b0:	aa 8d       	ldd	r26, Y+26	; 0x1a
    23b2:	bb 8d       	ldd	r27, Y+27	; 0x1b
    23b4:	84 30       	cpi	r24, 0x04	; 4
    23b6:	91 05       	cpc	r25, r1
    23b8:	a1 05       	cpc	r26, r1
    23ba:	b1 05       	cpc	r27, r1
    23bc:	09 f4       	brne	.+2      	; 0x23c0 <RNDIS_Device_ProcessControlRequest+0x7e>
    23be:	7b c0       	rjmp	.+246    	; 0x24b6 <RNDIS_Device_ProcessControlRequest+0x174>
    23c0:	85 30       	cpi	r24, 0x05	; 5
    23c2:	91 05       	cpc	r25, r1
    23c4:	a1 05       	cpc	r26, r1
    23c6:	b1 05       	cpc	r27, r1
    23c8:	60 f4       	brcc	.+24     	; 0x23e2 <RNDIS_Device_ProcessControlRequest+0xa0>
    23ca:	82 30       	cpi	r24, 0x02	; 2
    23cc:	91 05       	cpc	r25, r1
    23ce:	a1 05       	cpc	r26, r1
    23d0:	b1 05       	cpc	r27, r1
    23d2:	d1 f0       	breq	.+52     	; 0x2408 <RNDIS_Device_ProcessControlRequest+0xc6>
    23d4:	83 30       	cpi	r24, 0x03	; 3
    23d6:	91 05       	cpc	r25, r1
    23d8:	a1 05       	cpc	r26, r1
    23da:	b1 05       	cpc	r27, r1
    23dc:	09 f0       	breq	.+2      	; 0x23e0 <RNDIS_Device_ProcessControlRequest+0x9e>
    23de:	84 c2       	rjmp	.+1288   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
    23e0:	5d c0       	rjmp	.+186    	; 0x249c <RNDIS_Device_ProcessControlRequest+0x15a>
    23e2:	86 30       	cpi	r24, 0x06	; 6
    23e4:	91 05       	cpc	r25, r1
    23e6:	a1 05       	cpc	r26, r1
    23e8:	b1 05       	cpc	r27, r1
    23ea:	09 f4       	brne	.+2      	; 0x23ee <RNDIS_Device_ProcessControlRequest+0xac>
    23ec:	fc c1       	rjmp	.+1016   	; 0x27e6 <RNDIS_Device_ProcessControlRequest+0x4a4>
    23ee:	86 30       	cpi	r24, 0x06	; 6
    23f0:	91 05       	cpc	r25, r1
    23f2:	a1 05       	cpc	r26, r1
    23f4:	b1 05       	cpc	r27, r1
    23f6:	08 f4       	brcc	.+2      	; 0x23fa <RNDIS_Device_ProcessControlRequest+0xb8>
    23f8:	a1 c1       	rjmp	.+834    	; 0x273c <RNDIS_Device_ProcessControlRequest+0x3fa>
    23fa:	88 30       	cpi	r24, 0x08	; 8
    23fc:	91 05       	cpc	r25, r1
    23fe:	a1 05       	cpc	r26, r1
    2400:	b1 05       	cpc	r27, r1
    2402:	09 f0       	breq	.+2      	; 0x2406 <RNDIS_Device_ProcessControlRequest+0xc4>
    2404:	71 c2       	rjmp	.+1250   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
    2406:	0a c2       	rjmp	.+1044   	; 0x281c <RNDIS_Device_ProcessControlRequest+0x4da>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2408:	fe 01       	movw	r30, r28
    240a:	e8 56       	subi	r30, 0x68	; 104
    240c:	ff 4f       	sbci	r31, 0xFF	; 255
    240e:	21 e0       	ldi	r18, 0x01	; 1
    2410:	20 83       	st	Z, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    2412:	82 e0       	ldi	r24, 0x02	; 2
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	a0 e0       	ldi	r26, 0x00	; 0
    2418:	b0 e8       	ldi	r27, 0x80	; 128
    241a:	88 8f       	std	Y+24, r24	; 0x18
    241c:	99 8f       	std	Y+25, r25	; 0x19
    241e:	aa 8f       	std	Y+26, r26	; 0x1a
    2420:	bb 8f       	std	Y+27, r27	; 0x1b
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    2422:	84 e3       	ldi	r24, 0x34	; 52
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	a0 e0       	ldi	r26, 0x00	; 0
    2428:	b0 e0       	ldi	r27, 0x00	; 0
    242a:	f8 01       	movw	r30, r16
    242c:	84 83       	std	Z+4, r24	; 0x04
    242e:	95 83       	std	Z+5, r25	; 0x05
    2430:	a6 83       	std	Z+6, r26	; 0x06
    2432:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2434:	14 86       	std	Z+12, r1	; 0x0c
    2436:	15 86       	std	Z+13, r1	; 0x0d
    2438:	16 86       	std	Z+14, r1	; 0x0e
    243a:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    243c:	81 e0       	ldi	r24, 0x01	; 1
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	a0 e0       	ldi	r26, 0x00	; 0
    2442:	b0 e0       	ldi	r27, 0x00	; 0
    2444:	80 8b       	std	Z+16, r24	; 0x10
    2446:	91 8b       	std	Z+17, r25	; 0x11
    2448:	a2 8b       	std	Z+18, r26	; 0x12
    244a:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    244c:	14 8a       	std	Z+20, r1	; 0x14
    244e:	15 8a       	std	Z+21, r1	; 0x15
    2450:	16 8a       	std	Z+22, r1	; 0x16
    2452:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    2454:	80 8f       	std	Z+24, r24	; 0x18
    2456:	91 8f       	std	Z+25, r25	; 0x19
    2458:	a2 8f       	std	Z+26, r26	; 0x1a
    245a:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    245c:	14 8e       	std	Z+28, r1	; 0x1c
    245e:	15 8e       	std	Z+29, r1	; 0x1d
    2460:	16 8e       	std	Z+30, r1	; 0x1e
    2462:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    2464:	80 a3       	std	Z+32, r24	; 0x20
    2466:	91 a3       	std	Z+33, r25	; 0x21
    2468:	a2 a3       	std	Z+34, r26	; 0x22
    246a:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    246c:	88 e0       	ldi	r24, 0x08	; 8
    246e:	96 e0       	ldi	r25, 0x06	; 6
    2470:	a0 e0       	ldi	r26, 0x00	; 0
    2472:	b0 e0       	ldi	r27, 0x00	; 0
    2474:	84 a3       	std	Z+36, r24	; 0x24
    2476:	95 a3       	std	Z+37, r25	; 0x25
    2478:	a6 a3       	std	Z+38, r26	; 0x26
    247a:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    247c:	10 a6       	std	Z+40, r1	; 0x28
    247e:	11 a6       	std	Z+41, r1	; 0x29
    2480:	12 a6       	std	Z+42, r1	; 0x2a
    2482:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    2484:	14 a6       	std	Z+44, r1	; 0x2c
    2486:	15 a6       	std	Z+45, r1	; 0x2d
    2488:	16 a6       	std	Z+46, r1	; 0x2e
    248a:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    248c:	10 aa       	std	Z+48, r1	; 0x30
    248e:	11 aa       	std	Z+49, r1	; 0x31
    2490:	12 aa       	std	Z+50, r1	; 0x32
    2492:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    2494:	c7 56       	subi	r28, 0x67	; 103
    2496:	df 4f       	sbci	r29, 0xFF	; 255
    2498:	28 83       	st	Y, r18
    249a:	26 c2       	rjmp	.+1100   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    249c:	fe 01       	movw	r30, r28
    249e:	e8 56       	subi	r30, 0x68	; 104
    24a0:	ff 4f       	sbci	r31, 0xFF	; 255
    24a2:	10 82       	st	Z, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    24a4:	f8 01       	movw	r30, r16
    24a6:	14 82       	std	Z+4, r1	; 0x04
    24a8:	15 82       	std	Z+5, r1	; 0x05
    24aa:	16 82       	std	Z+6, r1	; 0x06
    24ac:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    24ae:	c7 56       	subi	r28, 0x67	; 103
    24b0:	df 4f       	sbci	r29, 0xFF	; 255
    24b2:	18 82       	st	Y, r1
    24b4:	19 c2       	rjmp	.+1074   	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    24b6:	fe 01       	movw	r30, r28
    24b8:	e8 56       	subi	r30, 0x68	; 104
    24ba:	ff 4f       	sbci	r31, 0xFF	; 255
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	80 83       	st	Z, r24

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    24c0:	f8 01       	movw	r30, r16
    24c2:	24 85       	ldd	r18, Z+12	; 0x0c
    24c4:	35 85       	ldd	r19, Z+13	; 0x0d
    24c6:	46 85       	ldd	r20, Z+14	; 0x0e
    24c8:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    24ca:	fe 01       	movw	r30, r28
    24cc:	f0 96       	adiw	r30, 0x30	; 48
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    24ce:	84 e0       	ldi	r24, 0x04	; 4
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	a0 e0       	ldi	r26, 0x00	; 0
    24d4:	b0 e8       	ldi	r27, 0x80	; 128
    24d6:	88 8f       	std	Y+24, r24	; 0x18
    24d8:	99 8f       	std	Y+25, r25	; 0x19
    24da:	aa 8f       	std	Y+26, r26	; 0x1a
    24dc:	bb 8f       	std	Y+27, r27	; 0x1b
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    24de:	2e 30       	cpi	r18, 0x0E	; 14
    24e0:	61 e0       	ldi	r22, 0x01	; 1
    24e2:	36 07       	cpc	r19, r22
    24e4:	61 e0       	ldi	r22, 0x01	; 1
    24e6:	46 07       	cpc	r20, r22
    24e8:	60 e0       	ldi	r22, 0x00	; 0
    24ea:	56 07       	cpc	r21, r22
    24ec:	09 f4       	brne	.+2      	; 0x24f0 <RNDIS_Device_ProcessControlRequest+0x1ae>
    24ee:	f4 c0       	rjmp	.+488    	; 0x26d8 <RNDIS_Device_ProcessControlRequest+0x396>
    24f0:	2f 30       	cpi	r18, 0x0F	; 15
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	38 07       	cpc	r19, r24
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	48 07       	cpc	r20, r24
    24fa:	80 e0       	ldi	r24, 0x00	; 0
    24fc:	58 07       	cpc	r21, r24
    24fe:	08 f0       	brcs	.+2      	; 0x2502 <RNDIS_Device_ProcessControlRequest+0x1c0>
    2500:	64 c0       	rjmp	.+200    	; 0x25ca <RNDIS_Device_ProcessControlRequest+0x288>
    2502:	26 30       	cpi	r18, 0x06	; 6
    2504:	61 e0       	ldi	r22, 0x01	; 1
    2506:	36 07       	cpc	r19, r22
    2508:	61 e0       	ldi	r22, 0x01	; 1
    250a:	46 07       	cpc	r20, r22
    250c:	60 e0       	ldi	r22, 0x00	; 0
    250e:	56 07       	cpc	r21, r22
    2510:	09 f4       	brne	.+2      	; 0x2514 <RNDIS_Device_ProcessControlRequest+0x1d2>
    2512:	bd c0       	rjmp	.+378    	; 0x268e <RNDIS_Device_ProcessControlRequest+0x34c>
    2514:	27 30       	cpi	r18, 0x07	; 7
    2516:	81 e0       	ldi	r24, 0x01	; 1
    2518:	38 07       	cpc	r19, r24
    251a:	81 e0       	ldi	r24, 0x01	; 1
    251c:	48 07       	cpc	r20, r24
    251e:	80 e0       	ldi	r24, 0x00	; 0
    2520:	58 07       	cpc	r21, r24
    2522:	28 f5       	brcc	.+74     	; 0x256e <RNDIS_Device_ProcessControlRequest+0x22c>
    2524:	22 30       	cpi	r18, 0x02	; 2
    2526:	61 e0       	ldi	r22, 0x01	; 1
    2528:	36 07       	cpc	r19, r22
    252a:	61 e0       	ldi	r22, 0x01	; 1
    252c:	46 07       	cpc	r20, r22
    252e:	60 e0       	ldi	r22, 0x00	; 0
    2530:	56 07       	cpc	r21, r22
    2532:	09 f4       	brne	.+2      	; 0x2536 <RNDIS_Device_ProcessControlRequest+0x1f4>
    2534:	d9 c0       	rjmp	.+434    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
    2536:	23 30       	cpi	r18, 0x03	; 3
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	38 07       	cpc	r19, r24
    253c:	81 e0       	ldi	r24, 0x01	; 1
    253e:	48 07       	cpc	r20, r24
    2540:	80 e0       	ldi	r24, 0x00	; 0
    2542:	58 07       	cpc	r21, r24
    2544:	50 f4       	brcc	.+20     	; 0x255a <RNDIS_Device_ProcessControlRequest+0x218>
    2546:	21 30       	cpi	r18, 0x01	; 1
    2548:	61 e0       	ldi	r22, 0x01	; 1
    254a:	36 07       	cpc	r19, r22
    254c:	61 e0       	ldi	r22, 0x01	; 1
    254e:	46 07       	cpc	r20, r22
    2550:	60 e0       	ldi	r22, 0x00	; 0
    2552:	56 07       	cpc	r21, r22
    2554:	09 f0       	breq	.+2      	; 0x2558 <RNDIS_Device_ProcessControlRequest+0x216>
    2556:	d8 c0       	rjmp	.+432    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    2558:	8c c0       	rjmp	.+280    	; 0x2672 <RNDIS_Device_ProcessControlRequest+0x330>
    255a:	25 30       	cpi	r18, 0x05	; 5
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	38 07       	cpc	r19, r24
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	48 07       	cpc	r20, r24
    2564:	80 e0       	ldi	r24, 0x00	; 0
    2566:	58 07       	cpc	r21, r24
    2568:	08 f0       	brcs	.+2      	; 0x256c <RNDIS_Device_ProcessControlRequest+0x22a>
    256a:	ce c0       	rjmp	.+412    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    256c:	bd c0       	rjmp	.+378    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
    256e:	2c 30       	cpi	r18, 0x0C	; 12
    2570:	61 e0       	ldi	r22, 0x01	; 1
    2572:	36 07       	cpc	r19, r22
    2574:	61 e0       	ldi	r22, 0x01	; 1
    2576:	46 07       	cpc	r20, r22
    2578:	60 e0       	ldi	r22, 0x00	; 0
    257a:	56 07       	cpc	r21, r22
    257c:	98 f4       	brcc	.+38     	; 0x25a4 <RNDIS_Device_ProcessControlRequest+0x262>
    257e:	2a 30       	cpi	r18, 0x0A	; 10
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	38 07       	cpc	r19, r24
    2584:	81 e0       	ldi	r24, 0x01	; 1
    2586:	48 07       	cpc	r20, r24
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	58 07       	cpc	r21, r24
    258c:	08 f0       	brcs	.+2      	; 0x2590 <RNDIS_Device_ProcessControlRequest+0x24e>
    258e:	7f c0       	rjmp	.+254    	; 0x268e <RNDIS_Device_ProcessControlRequest+0x34c>
    2590:	27 30       	cpi	r18, 0x07	; 7
    2592:	e1 e0       	ldi	r30, 0x01	; 1
    2594:	3e 07       	cpc	r19, r30
    2596:	e1 e0       	ldi	r30, 0x01	; 1
    2598:	4e 07       	cpc	r20, r30
    259a:	e0 e0       	ldi	r30, 0x00	; 0
    259c:	5e 07       	cpc	r21, r30
    259e:	09 f0       	breq	.+2      	; 0x25a2 <RNDIS_Device_ProcessControlRequest+0x260>
    25a0:	b3 c0       	rjmp	.+358    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    25a2:	87 c0       	rjmp	.+270    	; 0x26b2 <RNDIS_Device_ProcessControlRequest+0x370>
    25a4:	2c 30       	cpi	r18, 0x0C	; 12
    25a6:	61 e0       	ldi	r22, 0x01	; 1
    25a8:	36 07       	cpc	r19, r22
    25aa:	61 e0       	ldi	r22, 0x01	; 1
    25ac:	46 07       	cpc	r20, r22
    25ae:	60 e0       	ldi	r22, 0x00	; 0
    25b0:	56 07       	cpc	r21, r22
    25b2:	09 f4       	brne	.+2      	; 0x25b6 <RNDIS_Device_ProcessControlRequest+0x274>
    25b4:	67 c0       	rjmp	.+206    	; 0x2684 <RNDIS_Device_ProcessControlRequest+0x342>
    25b6:	2d 30       	cpi	r18, 0x0D	; 13
    25b8:	81 e0       	ldi	r24, 0x01	; 1
    25ba:	38 07       	cpc	r19, r24
    25bc:	81 e0       	ldi	r24, 0x01	; 1
    25be:	48 07       	cpc	r20, r24
    25c0:	80 e0       	ldi	r24, 0x00	; 0
    25c2:	58 07       	cpc	r21, r24
    25c4:	09 f0       	breq	.+2      	; 0x25c8 <RNDIS_Device_ProcessControlRequest+0x286>
    25c6:	a0 c0       	rjmp	.+320    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    25c8:	67 c0       	rjmp	.+206    	; 0x2698 <RNDIS_Device_ProcessControlRequest+0x356>
    25ca:	26 30       	cpi	r18, 0x06	; 6
    25cc:	61 e0       	ldi	r22, 0x01	; 1
    25ce:	36 07       	cpc	r19, r22
    25d0:	62 e0       	ldi	r22, 0x02	; 2
    25d2:	46 07       	cpc	r20, r22
    25d4:	60 e0       	ldi	r22, 0x00	; 0
    25d6:	56 07       	cpc	r21, r22
    25d8:	28 f5       	brcc	.+74     	; 0x2624 <RNDIS_Device_ProcessControlRequest+0x2e2>
    25da:	21 30       	cpi	r18, 0x01	; 1
    25dc:	81 e0       	ldi	r24, 0x01	; 1
    25de:	38 07       	cpc	r19, r24
    25e0:	82 e0       	ldi	r24, 0x02	; 2
    25e2:	48 07       	cpc	r20, r24
    25e4:	80 e0       	ldi	r24, 0x00	; 0
    25e6:	58 07       	cpc	r21, r24
    25e8:	08 f0       	brcs	.+2      	; 0x25ec <RNDIS_Device_ProcessControlRequest+0x2aa>
    25ea:	7e c0       	rjmp	.+252    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
    25ec:	24 31       	cpi	r18, 0x14	; 20
    25ee:	e1 e0       	ldi	r30, 0x01	; 1
    25f0:	3e 07       	cpc	r19, r30
    25f2:	e1 e0       	ldi	r30, 0x01	; 1
    25f4:	4e 07       	cpc	r20, r30
    25f6:	e0 e0       	ldi	r30, 0x00	; 0
    25f8:	5e 07       	cpc	r21, r30
    25fa:	09 f4       	brne	.+2      	; 0x25fe <RNDIS_Device_ProcessControlRequest+0x2bc>
    25fc:	75 c0       	rjmp	.+234    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
    25fe:	22 30       	cpi	r18, 0x02	; 2
    2600:	f2 e0       	ldi	r31, 0x02	; 2
    2602:	3f 07       	cpc	r19, r31
    2604:	f1 e0       	ldi	r31, 0x01	; 1
    2606:	4f 07       	cpc	r20, r31
    2608:	f0 e0       	ldi	r31, 0x00	; 0
    260a:	5f 07       	cpc	r21, r31
    260c:	09 f4       	brne	.+2      	; 0x2610 <RNDIS_Device_ProcessControlRequest+0x2ce>
    260e:	6c c0       	rjmp	.+216    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
    2610:	21 31       	cpi	r18, 0x11	; 17
    2612:	61 e0       	ldi	r22, 0x01	; 1
    2614:	36 07       	cpc	r19, r22
    2616:	61 e0       	ldi	r22, 0x01	; 1
    2618:	46 07       	cpc	r20, r22
    261a:	60 e0       	ldi	r22, 0x00	; 0
    261c:	56 07       	cpc	r21, r22
    261e:	09 f0       	breq	.+2      	; 0x2622 <RNDIS_Device_ProcessControlRequest+0x2e0>
    2620:	73 c0       	rjmp	.+230    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    2622:	67 c0       	rjmp	.+206    	; 0x26f2 <RNDIS_Device_ProcessControlRequest+0x3b0>
    2624:	24 30       	cpi	r18, 0x04	; 4
    2626:	81 e0       	ldi	r24, 0x01	; 1
    2628:	38 07       	cpc	r19, r24
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	48 07       	cpc	r20, r24
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	58 07       	cpc	r21, r24
    2632:	09 f4       	brne	.+2      	; 0x2636 <RNDIS_Device_ProcessControlRequest+0x2f4>
    2634:	4c c0       	rjmp	.+152    	; 0x26ce <RNDIS_Device_ProcessControlRequest+0x38c>
    2636:	25 30       	cpi	r18, 0x05	; 5
    2638:	61 e0       	ldi	r22, 0x01	; 1
    263a:	36 07       	cpc	r19, r22
    263c:	61 e0       	ldi	r22, 0x01	; 1
    263e:	46 07       	cpc	r20, r22
    2640:	61 e0       	ldi	r22, 0x01	; 1
    2642:	56 07       	cpc	r21, r22
    2644:	58 f4       	brcc	.+22     	; 0x265c <RNDIS_Device_ProcessControlRequest+0x31a>
    2646:	21 50       	subi	r18, 0x01	; 1
    2648:	31 40       	sbci	r19, 0x01	; 1
    264a:	41 40       	sbci	r20, 0x01	; 1
    264c:	51 40       	sbci	r21, 0x01	; 1
    264e:	22 30       	cpi	r18, 0x02	; 2
    2650:	31 05       	cpc	r19, r1
    2652:	41 05       	cpc	r20, r1
    2654:	51 05       	cpc	r21, r1
    2656:	08 f0       	brcs	.+2      	; 0x265a <RNDIS_Device_ProcessControlRequest+0x318>
    2658:	57 c0       	rjmp	.+174    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    265a:	30 c0       	rjmp	.+96     	; 0x26bc <RNDIS_Device_ProcessControlRequest+0x37a>
    265c:	21 50       	subi	r18, 0x01	; 1
    265e:	31 40       	sbci	r19, 0x01	; 1
    2660:	42 40       	sbci	r20, 0x02	; 2
    2662:	51 40       	sbci	r21, 0x01	; 1
    2664:	23 30       	cpi	r18, 0x03	; 3
    2666:	31 05       	cpc	r19, r1
    2668:	41 05       	cpc	r20, r1
    266a:	51 05       	cpc	r21, r1
    266c:	08 f0       	brcs	.+2      	; 0x2670 <RNDIS_Device_ProcessControlRequest+0x32e>
    266e:	4c c0       	rjmp	.+152    	; 0x2708 <RNDIS_Device_ProcessControlRequest+0x3c6>
    2670:	3b c0       	rjmp	.+118    	; 0x26e8 <RNDIS_Device_ProcessControlRequest+0x3a6>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2672:	cf 01       	movw	r24, r30
    2674:	66 eb       	ldi	r22, 0xB6	; 182
    2676:	73 e0       	ldi	r23, 0x03	; 3
    2678:	4c e6       	ldi	r20, 0x6C	; 108
    267a:	50 e0       	ldi	r21, 0x00	; 0
    267c:	c4 d2       	rcall	.+1416   	; 0x2c06 <memcpy_P>
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    267e:	cc e6       	ldi	r28, 0x6C	; 108
    2680:	d0 e0       	ldi	r29, 0x00	; 0
    2682:	16 c1       	rjmp	.+556    	; 0x28b0 <RNDIS_Device_ProcessControlRequest+0x56e>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    2684:	8f ef       	ldi	r24, 0xFF	; 255
    2686:	9f ef       	ldi	r25, 0xFF	; 255
    2688:	af ef       	ldi	r26, 0xFF	; 255
    268a:	b0 e0       	ldi	r27, 0x00	; 0
    268c:	36 c0       	rjmp	.+108    	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x3b8>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    268e:	8c ed       	ldi	r24, 0xDC	; 220
    2690:	95 e0       	ldi	r25, 0x05	; 5
    2692:	a0 e0       	ldi	r26, 0x00	; 0
    2694:	b0 e0       	ldi	r27, 0x00	; 0
    2696:	31 c0       	rjmp	.+98     	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x3b8>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2698:	68 89       	ldd	r22, Y+16	; 0x10
    269a:	79 89       	ldd	r23, Y+17	; 0x11
    269c:	db 01       	movw	r26, r22
    269e:	ed 01       	movw	r28, r26
    26a0:	09 90       	ld	r0, Y+
    26a2:	00 20       	and	r0, r0
    26a4:	e9 f7       	brne	.-6      	; 0x26a0 <RNDIS_Device_ProcessControlRequest+0x35e>
    26a6:	ca 1b       	sub	r28, r26
    26a8:	db 0b       	sbc	r29, r27

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    26aa:	cf 01       	movw	r24, r30
    26ac:	ae 01       	movw	r20, r28
    26ae:	e0 d2       	rcall	.+1472   	; 0x2c70 <memcpy>
    26b0:	ff c0       	rjmp	.+510    	; 0x28b0 <RNDIS_Device_ProcessControlRequest+0x56e>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    26b2:	80 ea       	ldi	r24, 0xA0	; 160
    26b4:	96 e8       	ldi	r25, 0x86	; 134
    26b6:	a1 e0       	ldi	r26, 0x01	; 1
    26b8:	b0 e0       	ldi	r27, 0x00	; 0
    26ba:	1f c0       	rjmp	.+62     	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x3b8>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    26bc:	62 96       	adiw	r28, 0x12	; 18
    26be:	86 e0       	ldi	r24, 0x06	; 6
    26c0:	09 90       	ld	r0, Y+
    26c2:	01 92       	st	Z+, r0
    26c4:	81 50       	subi	r24, 0x01	; 1
    26c6:	e1 f7       	brne	.-8      	; 0x26c0 <RNDIS_Device_ProcessControlRequest+0x37e>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    26c8:	c6 e0       	ldi	r28, 0x06	; 6
    26ca:	d0 e0       	ldi	r29, 0x00	; 0
    26cc:	f1 c0       	rjmp	.+482    	; 0x28b0 <RNDIS_Device_ProcessControlRequest+0x56e>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    26ce:	81 e0       	ldi	r24, 0x01	; 1
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	a0 e0       	ldi	r26, 0x00	; 0
    26d4:	b0 e0       	ldi	r27, 0x00	; 0
    26d6:	11 c0       	rjmp	.+34     	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x3b8>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    26d8:	fe 01       	movw	r30, r28
    26da:	e6 56       	subi	r30, 0x66	; 102
    26dc:	ff 4f       	sbci	r31, 0xFF	; 255
    26de:	80 81       	ld	r24, Z
    26e0:	91 81       	ldd	r25, Z+1	; 0x01
    26e2:	a2 81       	ldd	r26, Z+2	; 0x02
    26e4:	b3 81       	ldd	r27, Z+3	; 0x03
    26e6:	09 c0       	rjmp	.+18     	; 0x26fa <RNDIS_Device_ProcessControlRequest+0x3b8>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    26e8:	18 aa       	std	Y+48, r1	; 0x30
    26ea:	19 aa       	std	Y+49, r1	; 0x31
    26ec:	1a aa       	std	Y+50, r1	; 0x32
    26ee:	1b aa       	std	Y+51, r1	; 0x33
    26f0:	08 c0       	rjmp	.+16     	; 0x2702 <RNDIS_Device_ProcessControlRequest+0x3c0>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    26f2:	8c e5       	ldi	r24, 0x5C	; 92
    26f4:	96 e0       	ldi	r25, 0x06	; 6
    26f6:	a0 e0       	ldi	r26, 0x00	; 0
    26f8:	b0 e0       	ldi	r27, 0x00	; 0
    26fa:	88 ab       	std	Y+48, r24	; 0x30
    26fc:	99 ab       	std	Y+49, r25	; 0x31
    26fe:	aa ab       	std	Y+50, r26	; 0x32
    2700:	bb ab       	std	Y+51, r27	; 0x33
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    2702:	c4 e0       	ldi	r28, 0x04	; 4
    2704:	d0 e0       	ldi	r29, 0x00	; 0
    2706:	d4 c0       	rjmp	.+424    	; 0x28b0 <RNDIS_Device_ProcessControlRequest+0x56e>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    2708:	8b eb       	ldi	r24, 0xBB	; 187
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	a0 e0       	ldi	r26, 0x00	; 0
    270e:	b0 ec       	ldi	r27, 0xC0	; 192
    2710:	f8 01       	movw	r30, r16
    2712:	84 87       	std	Z+12, r24	; 0x0c
    2714:	95 87       	std	Z+13, r25	; 0x0d
    2716:	a6 87       	std	Z+14, r26	; 0x0e
    2718:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    271a:	88 e1       	ldi	r24, 0x18	; 24
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	a0 e0       	ldi	r26, 0x00	; 0
    2720:	b0 e0       	ldi	r27, 0x00	; 0
    2722:	84 83       	std	Z+4, r24	; 0x04
    2724:	95 83       	std	Z+5, r25	; 0x05
    2726:	a6 83       	std	Z+6, r26	; 0x06
    2728:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    272a:	10 8a       	std	Z+16, r1	; 0x10
    272c:	11 8a       	std	Z+17, r1	; 0x11
    272e:	12 8a       	std	Z+18, r1	; 0x12
    2730:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    2732:	14 8a       	std	Z+20, r1	; 0x14
    2734:	15 8a       	std	Z+21, r1	; 0x15
    2736:	16 8a       	std	Z+22, r1	; 0x16
    2738:	17 8a       	std	Z+23, r1	; 0x17
    273a:	d6 c0       	rjmp	.+428    	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    273c:	fe 01       	movw	r30, r28
    273e:	e8 56       	subi	r30, 0x68	; 104
    2740:	ff 4f       	sbci	r31, 0xFF	; 255
    2742:	81 e0       	ldi	r24, 0x01	; 1
    2744:	80 83       	st	Z, r24

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    2746:	f8 01       	movw	r30, r16
    2748:	84 85       	ldd	r24, Z+12	; 0x0c
    274a:	95 85       	ldd	r25, Z+13	; 0x0d
    274c:	a6 85       	ldd	r26, Z+14	; 0x0e
    274e:	b7 85       	ldd	r27, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2750:	25 e0       	ldi	r18, 0x05	; 5
    2752:	30 e0       	ldi	r19, 0x00	; 0
    2754:	40 e0       	ldi	r20, 0x00	; 0
    2756:	50 e8       	ldi	r21, 0x80	; 128
    2758:	28 8f       	std	Y+24, r18	; 0x18
    275a:	39 8f       	std	Y+25, r19	; 0x19
    275c:	4a 8f       	std	Y+26, r20	; 0x1a
    275e:	5b 8f       	std	Y+27, r21	; 0x1b
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2760:	20 e1       	ldi	r18, 0x10	; 16
    2762:	30 e0       	ldi	r19, 0x00	; 0
    2764:	40 e0       	ldi	r20, 0x00	; 0
    2766:	50 e0       	ldi	r21, 0x00	; 0
    2768:	24 83       	std	Z+4, r18	; 0x04
    276a:	35 83       	std	Z+5, r19	; 0x05
    276c:	46 83       	std	Z+6, r20	; 0x06
    276e:	57 83       	std	Z+7, r21	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2770:	24 89       	ldd	r18, Z+20	; 0x14
    2772:	35 89       	ldd	r19, Z+21	; 0x15
    2774:	46 89       	ldd	r20, Z+22	; 0x16
    2776:	57 89       	ldd	r21, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2778:	8e 30       	cpi	r24, 0x0E	; 14
    277a:	f1 e0       	ldi	r31, 0x01	; 1
    277c:	9f 07       	cpc	r25, r31
    277e:	f1 e0       	ldi	r31, 0x01	; 1
    2780:	af 07       	cpc	r26, r31
    2782:	f0 e0       	ldi	r31, 0x00	; 0
    2784:	bf 07       	cpc	r27, r31
    2786:	49 f0       	breq	.+18     	; 0x279a <RNDIS_Device_ProcessControlRequest+0x458>
    2788:	83 30       	cpi	r24, 0x03	; 3
    278a:	21 e0       	ldi	r18, 0x01	; 1
    278c:	92 07       	cpc	r25, r18
    278e:	21 e0       	ldi	r18, 0x01	; 1
    2790:	a2 07       	cpc	r26, r18
    2792:	21 e0       	ldi	r18, 0x01	; 1
    2794:	b2 07       	cpc	r27, r18
    2796:	e9 f4       	brne	.+58     	; 0x27d2 <RNDIS_Device_ProcessControlRequest+0x490>
    2798:	18 c0       	rjmp	.+48     	; 0x27ca <RNDIS_Device_ProcessControlRequest+0x488>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    279a:	20 0f       	add	r18, r16
    279c:	31 1f       	adc	r19, r17
    279e:	f9 01       	movw	r30, r18
    27a0:	80 85       	ldd	r24, Z+8	; 0x08
    27a2:	91 85       	ldd	r25, Z+9	; 0x09
    27a4:	a2 85       	ldd	r26, Z+10	; 0x0a
    27a6:	b3 85       	ldd	r27, Z+11	; 0x0b
    27a8:	fe 01       	movw	r30, r28
    27aa:	e6 56       	subi	r30, 0x66	; 102
    27ac:	ff 4f       	sbci	r31, 0xFF	; 255
    27ae:	80 83       	st	Z, r24
    27b0:	91 83       	std	Z+1, r25	; 0x01
    27b2:	a2 83       	std	Z+2, r26	; 0x02
    27b4:	b3 83       	std	Z+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    27b6:	00 97       	sbiw	r24, 0x00	; 0
    27b8:	a1 05       	cpc	r26, r1
    27ba:	b1 05       	cpc	r27, r1
    27bc:	11 f0       	breq	.+4      	; 0x27c2 <RNDIS_Device_ProcessControlRequest+0x480>
    27be:	82 e0       	ldi	r24, 0x02	; 2
    27c0:	01 c0       	rjmp	.+2      	; 0x27c4 <RNDIS_Device_ProcessControlRequest+0x482>
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	c7 56       	subi	r28, 0x67	; 103
    27c6:	df 4f       	sbci	r29, 0xFF	; 255
    27c8:	88 83       	st	Y, r24
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    27ca:	80 e0       	ldi	r24, 0x00	; 0
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	dc 01       	movw	r26, r24
    27d0:	04 c0       	rjmp	.+8      	; 0x27da <RNDIS_Device_ProcessControlRequest+0x498>
    27d2:	8b eb       	ldi	r24, 0xBB	; 187
    27d4:	90 e0       	ldi	r25, 0x00	; 0
    27d6:	a0 e0       	ldi	r26, 0x00	; 0
    27d8:	b0 ec       	ldi	r27, 0xC0	; 192
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    27da:	f8 01       	movw	r30, r16
    27dc:	84 87       	std	Z+12, r24	; 0x0c
    27de:	95 87       	std	Z+13, r25	; 0x0d
    27e0:	a6 87       	std	Z+14, r26	; 0x0e
    27e2:	b7 87       	std	Z+15, r27	; 0x0f
    27e4:	81 c0       	rjmp	.+258    	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    27e6:	fe 01       	movw	r30, r28
    27e8:	e8 56       	subi	r30, 0x68	; 104
    27ea:	ff 4f       	sbci	r31, 0xFF	; 255
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	80 83       	st	Z, r24

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    27f0:	86 e0       	ldi	r24, 0x06	; 6
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	a0 e0       	ldi	r26, 0x00	; 0
    27f6:	b0 e8       	ldi	r27, 0x80	; 128
    27f8:	88 8f       	std	Y+24, r24	; 0x18
    27fa:	99 8f       	std	Y+25, r25	; 0x19
    27fc:	aa 8f       	std	Y+26, r26	; 0x1a
    27fe:	bb 8f       	std	Y+27, r27	; 0x1b
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2800:	80 e1       	ldi	r24, 0x10	; 16
    2802:	90 e0       	ldi	r25, 0x00	; 0
    2804:	a0 e0       	ldi	r26, 0x00	; 0
    2806:	b0 e0       	ldi	r27, 0x00	; 0
    2808:	f8 01       	movw	r30, r16
    280a:	84 83       	std	Z+4, r24	; 0x04
    280c:	95 83       	std	Z+5, r25	; 0x05
    280e:	a6 83       	std	Z+6, r26	; 0x06
    2810:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2812:	10 86       	std	Z+8, r1	; 0x08
    2814:	11 86       	std	Z+9, r1	; 0x09
    2816:	12 86       	std	Z+10, r1	; 0x0a
    2818:	13 86       	std	Z+11, r1	; 0x0b
    281a:	16 c0       	rjmp	.+44     	; 0x2848 <RNDIS_Device_ProcessControlRequest+0x506>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    281c:	fe 01       	movw	r30, r28
    281e:	e8 56       	subi	r30, 0x68	; 104
    2820:	ff 4f       	sbci	r31, 0xFF	; 255
    2822:	81 e0       	ldi	r24, 0x01	; 1
    2824:	80 83       	st	Z, r24
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    2826:	88 e0       	ldi	r24, 0x08	; 8
    2828:	90 e0       	ldi	r25, 0x00	; 0
    282a:	a0 e0       	ldi	r26, 0x00	; 0
    282c:	b0 e8       	ldi	r27, 0x80	; 128
    282e:	88 8f       	std	Y+24, r24	; 0x18
    2830:	99 8f       	std	Y+25, r25	; 0x19
    2832:	aa 8f       	std	Y+26, r26	; 0x1a
    2834:	bb 8f       	std	Y+27, r27	; 0x1b
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    2836:	80 e1       	ldi	r24, 0x10	; 16
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	a0 e0       	ldi	r26, 0x00	; 0
    283c:	b0 e0       	ldi	r27, 0x00	; 0
    283e:	f8 01       	movw	r30, r16
    2840:	84 83       	std	Z+4, r24	; 0x04
    2842:	95 83       	std	Z+5, r25	; 0x05
    2844:	a6 83       	std	Z+6, r26	; 0x06
    2846:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2848:	14 86       	std	Z+12, r1	; 0x0c
    284a:	15 86       	std	Z+13, r1	; 0x0d
    284c:	16 86       	std	Z+14, r1	; 0x0e
    284e:	17 86       	std	Z+15, r1	; 0x0f
    2850:	4b c0       	rjmp	.+150    	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2852:	80 91 03 14 	lds	r24, 0x1403
    2856:	81 3a       	cpi	r24, 0xA1	; 161
    2858:	09 f0       	breq	.+2      	; 0x285c <RNDIS_Device_ProcessControlRequest+0x51a>
    285a:	46 c0       	rjmp	.+140    	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    285c:	8e 01       	movw	r16, r28
    285e:	08 5e       	subi	r16, 0xE8	; 232
    2860:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2862:	f8 01       	movw	r30, r16
    2864:	84 81       	ldd	r24, Z+4	; 0x04
    2866:	95 81       	ldd	r25, Z+5	; 0x05
    2868:	a6 81       	ldd	r26, Z+6	; 0x06
    286a:	b7 81       	ldd	r27, Z+7	; 0x07
    286c:	00 97       	sbiw	r24, 0x00	; 0
    286e:	a1 05       	cpc	r26, r1
    2870:	b1 05       	cpc	r27, r1
    2872:	49 f4       	brne	.+18     	; 0x2886 <RNDIS_Device_ProcessControlRequest+0x544>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2874:	18 8e       	std	Y+24, r1	; 0x18
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    2876:	81 e0       	ldi	r24, 0x01	; 1
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	a0 e0       	ldi	r26, 0x00	; 0
    287c:	b0 e0       	ldi	r27, 0x00	; 0
    287e:	84 83       	std	Z+4, r24	; 0x04
    2880:	95 83       	std	Z+5, r25	; 0x05
    2882:	a6 83       	std	Z+6, r26	; 0x06
    2884:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2886:	80 91 e8 00 	lds	r24, 0x00E8
    288a:	87 7f       	andi	r24, 0xF7	; 247
    288c:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2890:	f8 01       	movw	r30, r16
    2892:	64 81       	ldd	r22, Z+4	; 0x04
    2894:	75 81       	ldd	r23, Z+5	; 0x05
    2896:	c8 01       	movw	r24, r16
    2898:	da d8       	rcall	.-3660   	; 0x1a4e <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    289a:	80 91 e8 00 	lds	r24, 0x00E8
    289e:	8b 77       	andi	r24, 0x7B	; 123
    28a0:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    28a4:	f8 01       	movw	r30, r16
    28a6:	14 82       	std	Z+4, r1	; 0x04
    28a8:	15 82       	std	Z+5, r1	; 0x05
    28aa:	16 82       	std	Z+6, r1	; 0x06
    28ac:	17 82       	std	Z+7, r1	; 0x07
    28ae:	1c c0       	rjmp	.+56     	; 0x28e8 <RNDIS_Device_ProcessControlRequest+0x5a6>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    28b0:	f8 01       	movw	r30, r16
    28b2:	14 86       	std	Z+12, r1	; 0x0c
    28b4:	15 86       	std	Z+13, r1	; 0x0d
    28b6:	16 86       	std	Z+14, r1	; 0x0e
    28b8:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    28ba:	ce 01       	movw	r24, r28
    28bc:	48 96       	adiw	r24, 0x18	; 24
    28be:	a0 e0       	ldi	r26, 0x00	; 0
    28c0:	b0 e0       	ldi	r27, 0x00	; 0
    28c2:	84 83       	std	Z+4, r24	; 0x04
    28c4:	95 83       	std	Z+5, r25	; 0x05
    28c6:	a6 83       	std	Z+6, r26	; 0x06
    28c8:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    28ca:	ce 01       	movw	r24, r28
    28cc:	a0 e0       	ldi	r26, 0x00	; 0
    28ce:	b0 e0       	ldi	r27, 0x00	; 0
    28d0:	80 8b       	std	Z+16, r24	; 0x10
    28d2:	91 8b       	std	Z+17, r25	; 0x11
    28d4:	a2 8b       	std	Z+18, r26	; 0x12
    28d6:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    28d8:	80 e1       	ldi	r24, 0x10	; 16
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	a0 e0       	ldi	r26, 0x00	; 0
    28de:	b0 e0       	ldi	r27, 0x00	; 0
    28e0:	84 8b       	std	Z+20, r24	; 0x14
    28e2:	95 8b       	std	Z+21, r25	; 0x15
    28e4:	a6 8b       	std	Z+22, r26	; 0x16
    28e6:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    28e8:	df 91       	pop	r29
    28ea:	cf 91       	pop	r28
    28ec:	1f 91       	pop	r17
    28ee:	0f 91       	pop	r16
    28f0:	ff 90       	pop	r15
    28f2:	ef 90       	pop	r14
    28f4:	08 95       	ret

000028f6 <RNDIS_Device_ConfigureEndpoints>:

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    28f6:	cf 93       	push	r28
    28f8:	df 93       	push	r29
    28fa:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    28fc:	48 96       	adiw	r24, 0x18	; 24
    28fe:	fc 01       	movw	r30, r24
    2900:	86 e8       	ldi	r24, 0x86	; 134
    2902:	df 01       	movw	r26, r30
    2904:	1d 92       	st	X+, r1
    2906:	8a 95       	dec	r24
    2908:	e9 f7       	brne	.-6      	; 0x2904 <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    290a:	82 e0       	ldi	r24, 0x02	; 2
    290c:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    290e:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    2910:	83 e0       	ldi	r24, 0x03	; 3
    2912:	8e 87       	std	Y+14, r24	; 0x0e

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    2914:	ce 01       	movw	r24, r28
    2916:	01 96       	adiw	r24, 0x01	; 1
    2918:	61 e0       	ldi	r22, 0x01	; 1
    291a:	cd d9       	rcall	.-3174   	; 0x1cb6 <Endpoint_ConfigureEndpointTable>
    291c:	88 23       	and	r24, r24
    291e:	59 f0       	breq	.+22     	; 0x2936 <RNDIS_Device_ConfigureEndpoints+0x40>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    2920:	ce 01       	movw	r24, r28
    2922:	06 96       	adiw	r24, 0x06	; 6
    2924:	61 e0       	ldi	r22, 0x01	; 1
    2926:	c7 d9       	rcall	.-3186   	; 0x1cb6 <Endpoint_ConfigureEndpointTable>
    2928:	88 23       	and	r24, r24
    292a:	29 f0       	breq	.+10     	; 0x2936 <RNDIS_Device_ConfigureEndpoints+0x40>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    292c:	ce 01       	movw	r24, r28
    292e:	0b 96       	adiw	r24, 0x0b	; 11
    2930:	61 e0       	ldi	r22, 0x01	; 1
    2932:	c1 d9       	rcall	.-3198   	; 0x1cb6 <Endpoint_ConfigureEndpointTable>
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <RNDIS_Device_ConfigureEndpoints+0x42>

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;
    2936:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
	  return false;

	return true;
}
    2938:	df 91       	pop	r29
    293a:	cf 91       	pop	r28
    293c:	08 95       	ret

0000293e <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    293e:	0f 93       	push	r16
    2940:	1f 93       	push	r17
    2942:	df 93       	push	r29
    2944:	cf 93       	push	r28
    2946:	cd b7       	in	r28, 0x3d	; 61
    2948:	de b7       	in	r29, 0x3e	; 62
    294a:	28 97       	sbiw	r28, 0x08	; 8
    294c:	0f b6       	in	r0, 0x3f	; 63
    294e:	f8 94       	cli
    2950:	de bf       	out	0x3e, r29	; 62
    2952:	0f be       	out	0x3f, r0	; 63
    2954:	cd bf       	out	0x3d, r28	; 61
    2956:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    2958:	80 91 02 14 	lds	r24, 0x1402
    295c:	84 30       	cpi	r24, 0x04	; 4
    295e:	41 f5       	brne	.+80     	; 0x29b0 <RNDIS_Device_USBTask+0x72>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2960:	f8 01       	movw	r30, r16
    2962:	83 85       	ldd	r24, Z+11	; 0x0b
    2964:	8f 70       	andi	r24, 0x0F	; 15
    2966:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    296a:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    296e:	80 ff       	sbrs	r24, 0
    2970:	1f c0       	rjmp	.+62     	; 0x29b0 <RNDIS_Device_USBTask+0x72>
    2972:	e8 56       	subi	r30, 0x68	; 104
    2974:	ff 4f       	sbci	r31, 0xFF	; 255
    2976:	80 81       	ld	r24, Z
    2978:	88 23       	and	r24, r24
    297a:	d1 f0       	breq	.+52     	; 0x29b0 <RNDIS_Device_USBTask+0x72>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    297c:	de 01       	movw	r26, r28
    297e:	11 96       	adiw	r26, 0x01	; 1
    2980:	e2 ef       	ldi	r30, 0xF2	; 242
    2982:	f1 e0       	ldi	r31, 0x01	; 1
    2984:	88 e0       	ldi	r24, 0x08	; 8
    2986:	01 90       	ld	r0, Z+
    2988:	0d 92       	st	X+, r0
    298a:	81 50       	subi	r24, 0x01	; 1
    298c:	e1 f7       	brne	.-8      	; 0x2986 <RNDIS_Device_USBTask+0x48>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    298e:	ce 01       	movw	r24, r28
    2990:	01 96       	adiw	r24, 0x01	; 1
    2992:	68 e0       	ldi	r22, 0x08	; 8
    2994:	70 e0       	ldi	r23, 0x00	; 0
    2996:	40 e0       	ldi	r20, 0x00	; 0
    2998:	50 e0       	ldi	r21, 0x00	; 0
    299a:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    299e:	80 91 e8 00 	lds	r24, 0x00E8
    29a2:	8e 77       	andi	r24, 0x7E	; 126
    29a4:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    29a8:	f8 01       	movw	r30, r16
    29aa:	e8 56       	subi	r30, 0x68	; 104
    29ac:	ff 4f       	sbci	r31, 0xFF	; 255
    29ae:	10 82       	st	Z, r1
	}
}
    29b0:	28 96       	adiw	r28, 0x08	; 8
    29b2:	0f b6       	in	r0, 0x3f	; 63
    29b4:	f8 94       	cli
    29b6:	de bf       	out	0x3e, r29	; 62
    29b8:	0f be       	out	0x3f, r0	; 63
    29ba:	cd bf       	out	0x3d, r28	; 61
    29bc:	cf 91       	pop	r28
    29be:	df 91       	pop	r29
    29c0:	1f 91       	pop	r17
    29c2:	0f 91       	pop	r16
    29c4:	08 95       	ret

000029c6 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    29c6:	20 91 02 14 	lds	r18, 0x1402
    29ca:	24 30       	cpi	r18, 0x04	; 4
    29cc:	81 f4       	brne	.+32     	; 0x29ee <RNDIS_Device_IsPacketReceived+0x28>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    29ce:	fc 01       	movw	r30, r24
    29d0:	e7 56       	subi	r30, 0x67	; 103
    29d2:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    29d4:	20 81       	ld	r18, Z
    29d6:	22 30       	cpi	r18, 0x02	; 2
    29d8:	61 f4       	brne	.+24     	; 0x29f2 <RNDIS_Device_IsPacketReceived+0x2c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    29da:	fc 01       	movw	r30, r24
    29dc:	86 81       	ldd	r24, Z+6	; 0x06
    29de:	8f 70       	andi	r24, 0x0F	; 15
    29e0:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    29e4:	90 91 e8 00 	lds	r25, 0x00E8
    29e8:	81 e0       	ldi	r24, 0x01	; 1
    29ea:	92 fd       	sbrc	r25, 2
    29ec:	03 c0       	rjmp	.+6      	; 0x29f4 <RNDIS_Device_IsPacketReceived+0x2e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    29ee:	80 e0       	ldi	r24, 0x00	; 0
    29f0:	08 95       	ret
    29f2:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    29f4:	08 95       	ret

000029f6 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    29f6:	ef 92       	push	r14
    29f8:	ff 92       	push	r15
    29fa:	0f 93       	push	r16
    29fc:	1f 93       	push	r17
    29fe:	df 93       	push	r29
    2a00:	cf 93       	push	r28
    2a02:	cd b7       	in	r28, 0x3d	; 61
    2a04:	de b7       	in	r29, 0x3e	; 62
    2a06:	ac 97       	sbiw	r28, 0x2c	; 44
    2a08:	0f b6       	in	r0, 0x3f	; 63
    2a0a:	f8 94       	cli
    2a0c:	de bf       	out	0x3e, r29	; 62
    2a0e:	0f be       	out	0x3f, r0	; 63
    2a10:	cd bf       	out	0x3d, r28	; 61
    2a12:	7b 01       	movw	r14, r22
    2a14:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2a16:	20 91 02 14 	lds	r18, 0x1402
    2a1a:	24 30       	cpi	r18, 0x04	; 4
    2a1c:	e1 f5       	brne	.+120    	; 0x2a96 <RNDIS_Device_ReadPacket+0xa0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    2a1e:	fc 01       	movw	r30, r24
    2a20:	e7 56       	subi	r30, 0x67	; 103
    2a22:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2a24:	20 81       	ld	r18, Z
    2a26:	22 30       	cpi	r18, 0x02	; 2
    2a28:	b1 f5       	brne	.+108    	; 0x2a96 <RNDIS_Device_ReadPacket+0xa0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	86 81       	ldd	r24, Z+6	; 0x06
    2a2e:	8f 70       	andi	r24, 0x0F	; 15
    2a30:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    2a34:	fa 01       	movw	r30, r20
    2a36:	11 82       	std	Z+1, r1	; 0x01
    2a38:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2a3a:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    2a3e:	82 ff       	sbrs	r24, 2
    2a40:	2c c0       	rjmp	.+88     	; 0x2a9a <RNDIS_Device_ReadPacket+0xa4>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2a42:	ce 01       	movw	r24, r28
    2a44:	01 96       	adiw	r24, 0x01	; 1
    2a46:	6c e2       	ldi	r22, 0x2C	; 44
    2a48:	70 e0       	ldi	r23, 0x00	; 0
    2a4a:	40 e0       	ldi	r20, 0x00	; 0
    2a4c:	50 e0       	ldi	r21, 0x00	; 0
    2a4e:	0e 94 c9 0c 	call	0x1992	; 0x1992 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    2a52:	2d 85       	ldd	r18, Y+13	; 0x0d
    2a54:	3e 85       	ldd	r19, Y+14	; 0x0e
    2a56:	4f 85       	ldd	r20, Y+15	; 0x0f
    2a58:	58 89       	ldd	r21, Y+16	; 0x10
    2a5a:	2d 3d       	cpi	r18, 0xDD	; 221
    2a5c:	f5 e0       	ldi	r31, 0x05	; 5
    2a5e:	3f 07       	cpc	r19, r31
    2a60:	f0 e0       	ldi	r31, 0x00	; 0
    2a62:	4f 07       	cpc	r20, r31
    2a64:	f0 e0       	ldi	r31, 0x00	; 0
    2a66:	5f 07       	cpc	r21, r31
    2a68:	38 f0       	brcs	.+14     	; 0x2a78 <RNDIS_Device_ReadPacket+0x82>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2a6a:	80 91 eb 00 	lds	r24, 0x00EB
    2a6e:	80 62       	ori	r24, 0x20	; 32
    2a70:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    2a74:	80 e8       	ldi	r24, 0x80	; 128
    2a76:	12 c0       	rjmp	.+36     	; 0x2a9c <RNDIS_Device_ReadPacket+0xa6>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    2a78:	f8 01       	movw	r30, r16
    2a7a:	31 83       	std	Z+1, r19	; 0x01
    2a7c:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    2a7e:	c7 01       	movw	r24, r14
    2a80:	b9 01       	movw	r22, r18
    2a82:	40 e0       	ldi	r20, 0x00	; 0
    2a84:	50 e0       	ldi	r21, 0x00	; 0
    2a86:	0e 94 c9 0c 	call	0x1992	; 0x1992 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2a8a:	80 91 e8 00 	lds	r24, 0x00E8
    2a8e:	8b 77       	andi	r24, 0x7B	; 123
    2a90:	80 93 e8 00 	sts	0x00E8, r24
    2a94:	02 c0       	rjmp	.+4      	; 0x2a9a <RNDIS_Device_ReadPacket+0xa4>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2a96:	82 e0       	ldi	r24, 0x02	; 2
    2a98:	01 c0       	rjmp	.+2      	; 0x2a9c <RNDIS_Device_ReadPacket+0xa6>
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    2a9a:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    2a9c:	ac 96       	adiw	r28, 0x2c	; 44
    2a9e:	0f b6       	in	r0, 0x3f	; 63
    2aa0:	f8 94       	cli
    2aa2:	de bf       	out	0x3e, r29	; 62
    2aa4:	0f be       	out	0x3f, r0	; 63
    2aa6:	cd bf       	out	0x3d, r28	; 61
    2aa8:	cf 91       	pop	r28
    2aaa:	df 91       	pop	r29
    2aac:	1f 91       	pop	r17
    2aae:	0f 91       	pop	r16
    2ab0:	ff 90       	pop	r15
    2ab2:	ef 90       	pop	r14
    2ab4:	08 95       	ret

00002ab6 <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    2ab6:	ef 92       	push	r14
    2ab8:	ff 92       	push	r15
    2aba:	0f 93       	push	r16
    2abc:	1f 93       	push	r17
    2abe:	df 93       	push	r29
    2ac0:	cf 93       	push	r28
    2ac2:	cd b7       	in	r28, 0x3d	; 61
    2ac4:	de b7       	in	r29, 0x3e	; 62
    2ac6:	ad 97       	sbiw	r28, 0x2d	; 45
    2ac8:	0f b6       	in	r0, 0x3f	; 63
    2aca:	f8 94       	cli
    2acc:	de bf       	out	0x3e, r29	; 62
    2ace:	0f be       	out	0x3f, r0	; 63
    2ad0:	cd bf       	out	0x3d, r28	; 61
    2ad2:	7b 01       	movw	r14, r22
    2ad4:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2ad6:	20 91 02 14 	lds	r18, 0x1402
    2ada:	24 30       	cpi	r18, 0x04	; 4
    2adc:	09 f0       	breq	.+2      	; 0x2ae0 <RNDIS_Device_SendPacket+0x2a>
    2ade:	4b c0       	rjmp	.+150    	; 0x2b76 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    2ae0:	fc 01       	movw	r30, r24
    2ae2:	e7 56       	subi	r30, 0x67	; 103
    2ae4:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2ae6:	20 81       	ld	r18, Z
    2ae8:	22 30       	cpi	r18, 0x02	; 2
    2aea:	09 f0       	breq	.+2      	; 0x2aee <RNDIS_Device_SendPacket+0x38>
    2aec:	44 c0       	rjmp	.+136    	; 0x2b76 <RNDIS_Device_SendPacket+0xc0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2aee:	fc 01       	movw	r30, r24
    2af0:	81 81       	ldd	r24, Z+1	; 0x01
    2af2:	8f 70       	andi	r24, 0x0F	; 15
    2af4:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    2af8:	43 d9       	rcall	.-3450   	; 0x1d80 <Endpoint_WaitUntilReady>
    2afa:	28 2f       	mov	r18, r24
    2afc:	88 23       	and	r24, r24
    2afe:	e1 f5       	brne	.+120    	; 0x2b78 <RNDIS_Device_SendPacket+0xc2>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    2b00:	ce 01       	movw	r24, r28
    2b02:	01 96       	adiw	r24, 0x01	; 1
    2b04:	3c e2       	ldi	r19, 0x2C	; 44
    2b06:	fc 01       	movw	r30, r24
    2b08:	11 92       	st	Z+, r1
    2b0a:	3a 95       	dec	r19
    2b0c:	e9 f7       	brne	.-6      	; 0x2b08 <RNDIS_Device_SendPacket+0x52>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    2b0e:	41 e0       	ldi	r20, 0x01	; 1
    2b10:	50 e0       	ldi	r21, 0x00	; 0
    2b12:	60 e0       	ldi	r22, 0x00	; 0
    2b14:	70 e0       	ldi	r23, 0x00	; 0
    2b16:	49 83       	std	Y+1, r20	; 0x01
    2b18:	5a 83       	std	Y+2, r21	; 0x02
    2b1a:	6b 83       	std	Y+3, r22	; 0x03
    2b1c:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    2b1e:	a8 01       	movw	r20, r16
    2b20:	44 5d       	subi	r20, 0xD4	; 212
    2b22:	5f 4f       	sbci	r21, 0xFF	; 255
    2b24:	60 e0       	ldi	r22, 0x00	; 0
    2b26:	70 e0       	ldi	r23, 0x00	; 0
    2b28:	4d 83       	std	Y+5, r20	; 0x05
    2b2a:	5e 83       	std	Y+6, r21	; 0x06
    2b2c:	6f 83       	std	Y+7, r22	; 0x07
    2b2e:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2b30:	44 e2       	ldi	r20, 0x24	; 36
    2b32:	50 e0       	ldi	r21, 0x00	; 0
    2b34:	60 e0       	ldi	r22, 0x00	; 0
    2b36:	70 e0       	ldi	r23, 0x00	; 0
    2b38:	49 87       	std	Y+9, r20	; 0x09
    2b3a:	5a 87       	std	Y+10, r21	; 0x0a
    2b3c:	6b 87       	std	Y+11, r22	; 0x0b
    2b3e:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2b40:	a8 01       	movw	r20, r16
    2b42:	60 e0       	ldi	r22, 0x00	; 0
    2b44:	70 e0       	ldi	r23, 0x00	; 0
    2b46:	4d 87       	std	Y+13, r20	; 0x0d
    2b48:	5e 87       	std	Y+14, r21	; 0x0e
    2b4a:	6f 87       	std	Y+15, r22	; 0x0f
    2b4c:	78 8b       	std	Y+16, r23	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2b4e:	6c e2       	ldi	r22, 0x2C	; 44
    2b50:	70 e0       	ldi	r23, 0x00	; 0
    2b52:	40 e0       	ldi	r20, 0x00	; 0
    2b54:	50 e0       	ldi	r21, 0x00	; 0
    2b56:	2d a7       	std	Y+45, r18	; 0x2d
    2b58:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    2b5c:	c7 01       	movw	r24, r14
    2b5e:	b8 01       	movw	r22, r16
    2b60:	40 e0       	ldi	r20, 0x00	; 0
    2b62:	50 e0       	ldi	r21, 0x00	; 0
    2b64:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2b68:	80 91 e8 00 	lds	r24, 0x00E8
    2b6c:	8e 77       	andi	r24, 0x7E	; 126
    2b6e:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    2b72:	2d a5       	ldd	r18, Y+45	; 0x2d
    2b74:	01 c0       	rjmp	.+2      	; 0x2b78 <RNDIS_Device_SendPacket+0xc2>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    2b76:	22 e0       	ldi	r18, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    2b78:	82 2f       	mov	r24, r18
    2b7a:	ad 96       	adiw	r28, 0x2d	; 45
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	de bf       	out	0x3e, r29	; 62
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	cd bf       	out	0x3d, r28	; 61
    2b86:	cf 91       	pop	r28
    2b88:	df 91       	pop	r29
    2b8a:	1f 91       	pop	r17
    2b8c:	0f 91       	pop	r16
    2b8e:	ff 90       	pop	r15
    2b90:	ef 90       	pop	r14
    2b92:	08 95       	ret

00002b94 <Serial_putchar>:
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2b94:	90 91 c8 00 	lds	r25, 0x00C8
    2b98:	95 ff       	sbrs	r25, 5
    2b9a:	fc cf       	rjmp	.-8      	; 0x2b94 <Serial_putchar>
				UDR1 = DataByte;
    2b9c:	80 93 ce 00 	sts	0x00CE, r24
{
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2ba0:	80 e0       	ldi	r24, 0x00	; 0
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	08 95       	ret

00002ba6 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2ba6:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2baa:	87 ff       	sbrs	r24, 7
    2bac:	08 c0       	rjmp	.+16     	; 0x2bbe <Serial_getchar+0x18>
    2bae:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2bb2:	87 ff       	sbrs	r24, 7
    2bb4:	07 c0       	rjmp	.+14     	; 0x2bc4 <Serial_getchar+0x1e>
				  return -1;

				return UDR1;
    2bb6:	20 91 ce 00 	lds	r18, 0x00CE
    2bba:	30 e0       	ldi	r19, 0x00	; 0
    2bbc:	05 c0       	rjmp	.+10     	; 0x2bc8 <Serial_getchar+0x22>
	  return _FDEV_EOF;
    2bbe:	2e ef       	ldi	r18, 0xFE	; 254
    2bc0:	3f ef       	ldi	r19, 0xFF	; 255
    2bc2:	02 c0       	rjmp	.+4      	; 0x2bc8 <Serial_getchar+0x22>
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
				  return -1;
    2bc4:	2f ef       	ldi	r18, 0xFF	; 255
    2bc6:	3f ef       	ldi	r19, 0xFF	; 255

	return Serial_ReceiveByte();
}
    2bc8:	c9 01       	movw	r24, r18
    2bca:	08 95       	ret

00002bcc <Serial_CreateStream>:
	while (Length--)
	  Serial_SendByte(*((uint8_t*)Buffer++));
}

void Serial_CreateStream(FILE* Stream)
{
    2bcc:	fc 01       	movw	r30, r24
	if (!(Stream))
    2bce:	00 97       	sbiw	r24, 0x00	; 0
    2bd0:	51 f4       	brne	.+20     	; 0x2be6 <Serial_CreateStream+0x1a>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    2bd2:	eb e0       	ldi	r30, 0x0B	; 11
    2bd4:	f4 e1       	ldi	r31, 0x14	; 20
    2bd6:	f0 93 1a 14 	sts	0x141A, r31
    2bda:	e0 93 19 14 	sts	0x1419, r30
		stdout = Stream;
    2bde:	f0 93 1c 14 	sts	0x141C, r31
    2be2:	e0 93 1b 14 	sts	0x141B, r30
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    2be6:	8e e0       	ldi	r24, 0x0E	; 14
    2be8:	df 01       	movw	r26, r30
    2bea:	1d 92       	st	X+, r1
    2bec:	8a 95       	dec	r24
    2bee:	e9 f7       	brne	.-6      	; 0x2bea <Serial_CreateStream+0x1e>
    2bf0:	83 e0       	ldi	r24, 0x03	; 3
    2bf2:	83 83       	std	Z+3, r24	; 0x03
    2bf4:	8a ec       	ldi	r24, 0xCA	; 202
    2bf6:	95 e1       	ldi	r25, 0x15	; 21
    2bf8:	91 87       	std	Z+9, r25	; 0x09
    2bfa:	80 87       	std	Z+8, r24	; 0x08
    2bfc:	83 ed       	ldi	r24, 0xD3	; 211
    2bfe:	95 e1       	ldi	r25, 0x15	; 21
    2c00:	93 87       	std	Z+11, r25	; 0x0b
    2c02:	82 87       	std	Z+10, r24	; 0x0a
}
    2c04:	08 95       	ret

00002c06 <memcpy_P>:
    2c06:	fb 01       	movw	r30, r22
    2c08:	dc 01       	movw	r26, r24
    2c0a:	02 c0       	rjmp	.+4      	; 0x2c10 <memcpy_P+0xa>
    2c0c:	05 90       	lpm	r0, Z+
    2c0e:	0d 92       	st	X+, r0
    2c10:	41 50       	subi	r20, 0x01	; 1
    2c12:	50 40       	sbci	r21, 0x00	; 0
    2c14:	d8 f7       	brcc	.-10     	; 0x2c0c <memcpy_P+0x6>
    2c16:	08 95       	ret

00002c18 <strcpy_P>:
    2c18:	fb 01       	movw	r30, r22
    2c1a:	dc 01       	movw	r26, r24
    2c1c:	05 90       	lpm	r0, Z+
    2c1e:	0d 92       	st	X+, r0
    2c20:	00 20       	and	r0, r0
    2c22:	e1 f7       	brne	.-8      	; 0x2c1c <strcpy_P+0x4>
    2c24:	08 95       	ret

00002c26 <strlen_P>:
    2c26:	fc 01       	movw	r30, r24
    2c28:	05 90       	lpm	r0, Z+
    2c2a:	00 20       	and	r0, r0
    2c2c:	e9 f7       	brne	.-6      	; 0x2c28 <strlen_P+0x2>
    2c2e:	80 95       	com	r24
    2c30:	90 95       	com	r25
    2c32:	8e 0f       	add	r24, r30
    2c34:	9f 1f       	adc	r25, r31
    2c36:	08 95       	ret

00002c38 <strncpy_P>:
    2c38:	fb 01       	movw	r30, r22
    2c3a:	dc 01       	movw	r26, r24
    2c3c:	41 50       	subi	r20, 0x01	; 1
    2c3e:	50 40       	sbci	r21, 0x00	; 0
    2c40:	48 f0       	brcs	.+18     	; 0x2c54 <strncpy_P+0x1c>
    2c42:	05 90       	lpm	r0, Z+
    2c44:	0d 92       	st	X+, r0
    2c46:	00 20       	and	r0, r0
    2c48:	c9 f7       	brne	.-14     	; 0x2c3c <strncpy_P+0x4>
    2c4a:	01 c0       	rjmp	.+2      	; 0x2c4e <strncpy_P+0x16>
    2c4c:	1d 92       	st	X+, r1
    2c4e:	41 50       	subi	r20, 0x01	; 1
    2c50:	50 40       	sbci	r21, 0x00	; 0
    2c52:	e0 f7       	brcc	.-8      	; 0x2c4c <strncpy_P+0x14>
    2c54:	08 95       	ret

00002c56 <memcmp>:
    2c56:	fb 01       	movw	r30, r22
    2c58:	dc 01       	movw	r26, r24
    2c5a:	04 c0       	rjmp	.+8      	; 0x2c64 <memcmp+0xe>
    2c5c:	8d 91       	ld	r24, X+
    2c5e:	01 90       	ld	r0, Z+
    2c60:	80 19       	sub	r24, r0
    2c62:	21 f4       	brne	.+8      	; 0x2c6c <memcmp+0x16>
    2c64:	41 50       	subi	r20, 0x01	; 1
    2c66:	50 40       	sbci	r21, 0x00	; 0
    2c68:	c8 f7       	brcc	.-14     	; 0x2c5c <memcmp+0x6>
    2c6a:	88 1b       	sub	r24, r24
    2c6c:	99 0b       	sbc	r25, r25
    2c6e:	08 95       	ret

00002c70 <memcpy>:
    2c70:	fb 01       	movw	r30, r22
    2c72:	dc 01       	movw	r26, r24
    2c74:	02 c0       	rjmp	.+4      	; 0x2c7a <memcpy+0xa>
    2c76:	01 90       	ld	r0, Z+
    2c78:	0d 92       	st	X+, r0
    2c7a:	41 50       	subi	r20, 0x01	; 1
    2c7c:	50 40       	sbci	r21, 0x00	; 0
    2c7e:	d8 f7       	brcc	.-10     	; 0x2c76 <memcpy+0x6>
    2c80:	08 95       	ret

00002c82 <memmove>:
    2c82:	68 17       	cp	r22, r24
    2c84:	79 07       	cpc	r23, r25
    2c86:	68 f4       	brcc	.+26     	; 0x2ca2 <memmove+0x20>
    2c88:	fb 01       	movw	r30, r22
    2c8a:	dc 01       	movw	r26, r24
    2c8c:	e4 0f       	add	r30, r20
    2c8e:	f5 1f       	adc	r31, r21
    2c90:	a4 0f       	add	r26, r20
    2c92:	b5 1f       	adc	r27, r21
    2c94:	02 c0       	rjmp	.+4      	; 0x2c9a <memmove+0x18>
    2c96:	02 90       	ld	r0, -Z
    2c98:	0e 92       	st	-X, r0
    2c9a:	41 50       	subi	r20, 0x01	; 1
    2c9c:	50 40       	sbci	r21, 0x00	; 0
    2c9e:	d8 f7       	brcc	.-10     	; 0x2c96 <memmove+0x14>
    2ca0:	08 95       	ret
    2ca2:	e6 cf       	rjmp	.-52     	; 0x2c70 <memcpy>

00002ca4 <strncmp>:
    2ca4:	fb 01       	movw	r30, r22
    2ca6:	dc 01       	movw	r26, r24
    2ca8:	41 50       	subi	r20, 0x01	; 1
    2caa:	50 40       	sbci	r21, 0x00	; 0
    2cac:	30 f0       	brcs	.+12     	; 0x2cba <strncmp+0x16>
    2cae:	8d 91       	ld	r24, X+
    2cb0:	01 90       	ld	r0, Z+
    2cb2:	80 19       	sub	r24, r0
    2cb4:	19 f4       	brne	.+6      	; 0x2cbc <strncmp+0x18>
    2cb6:	00 20       	and	r0, r0
    2cb8:	b9 f7       	brne	.-18     	; 0x2ca8 <strncmp+0x4>
    2cba:	88 1b       	sub	r24, r24
    2cbc:	99 0b       	sbc	r25, r25
    2cbe:	08 95       	ret

00002cc0 <_exit>:
    2cc0:	f8 94       	cli

00002cc2 <__stop_program>:
    2cc2:	ff cf       	rjmp	.-2      	; 0x2cc2 <__stop_program>
